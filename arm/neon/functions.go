package neon

/*
#include <arm_neon.h>

void VabdqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vabdq_u8(*v0, *v1); }
void VabdqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vabdq_u32(*v0, *v1); }
void VabdqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vabdq_u16(*v0, *v1); }
void VabdqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vabdq_s8(*v0, *v1); }
void VabdqF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vabdq_f32(*v0, *v1); }
void VabdqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vabdq_s32(*v0, *v1); }
void VabdqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vabdq_s16(*v0, *v1); }
void VabdU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vabd_u8(*v0, *v1); }
void VabdU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vabd_u32(*v0, *v1); }
void VabdU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vabd_u16(*v0, *v1); }
void VabdS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vabd_s8(*v0, *v1); }
void VabdF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vabd_f32(*v0, *v1); }
void VabdS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vabd_s32(*v0, *v1); }
void VabdS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vabd_s16(*v0, *v1); }
void VabsqS8(int8x16_t* r, int8x16_t* v0) { *r = vabsq_s8(*v0); }
void VabsqF32(float32x4_t* r, float32x4_t* v0) { *r = vabsq_f32(*v0); }
void VabsqS32(int32x4_t* r, int32x4_t* v0) { *r = vabsq_s32(*v0); }
void VabsqS16(int16x8_t* r, int16x8_t* v0) { *r = vabsq_s16(*v0); }
void VabsS8(int8x8_t* r, int8x8_t* v0) { *r = vabs_s8(*v0); }
void VabsF32(float32x2_t* r, float32x2_t* v0) { *r = vabs_f32(*v0); }
void VabsS32(int32x2_t* r, int32x2_t* v0) { *r = vabs_s32(*v0); }
void VabsS16(int16x4_t* r, int16x4_t* v0) { *r = vabs_s16(*v0); }
void VaddqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vaddq_u8(*v0, *v1); }
void VaddqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vaddq_u32(*v0, *v1); }
void VaddqU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vaddq_u64(*v0, *v1); }
void VaddqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vaddq_u16(*v0, *v1); }
void VaddqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vaddq_s8(*v0, *v1); }
void VaddqF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vaddq_f32(*v0, *v1); }
void VaddqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vaddq_s32(*v0, *v1); }
void VaddqS64(int64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vaddq_s64(*v0, *v1); }
void VaddqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vaddq_s16(*v0, *v1); }
void VaddU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vadd_u8(*v0, *v1); }
void VaddU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vadd_u32(*v0, *v1); }
void VaddU64(uint64x1_t* r, uint64x1_t* v0, uint64x1_t* v1) { *r = vadd_u64(*v0, *v1); }
void VaddU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vadd_u16(*v0, *v1); }
void VaddS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vadd_s8(*v0, *v1); }
void VaddF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vadd_f32(*v0, *v1); }
void VaddS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vadd_s32(*v0, *v1); }
void VaddS64(int64x1_t* r, int64x1_t* v0, int64x1_t* v1) { *r = vadd_s64(*v0, *v1); }
void VaddS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vadd_s16(*v0, *v1); }
void VaddP8(poly8x8_t* r, poly8x8_t* v0, poly8x8_t* v1) { *r = vadd_p8(*v0, *v1); }
void VaddP64(poly64x1_t* r, poly64x1_t* v0, poly64x1_t* v1) { *r = vadd_p64(*v0, *v1); }
void VaddP16(poly16x4_t* r, poly16x4_t* v0, poly16x4_t* v1) { *r = vadd_p16(*v0, *v1); }
void VaddqP8(poly8x16_t* r, poly8x16_t* v0, poly8x16_t* v1) { *r = vaddq_p8(*v0, *v1); }
void VaddqP64(poly64x2_t* r, poly64x2_t* v0, poly64x2_t* v1) { *r = vaddq_p64(*v0, *v1); }
void VaddqP16(poly16x8_t* r, poly16x8_t* v0, poly16x8_t* v1) { *r = vaddq_p16(*v0, *v1); }
void VaddhnU32(uint16x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vaddhn_u32(*v0, *v1); }
void VaddhnU64(uint32x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vaddhn_u64(*v0, *v1); }
void VaddhnU16(uint8x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vaddhn_u16(*v0, *v1); }
void VaddhnS32(int16x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vaddhn_s32(*v0, *v1); }
void VaddhnS64(int32x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vaddhn_s64(*v0, *v1); }
void VaddhnS16(int8x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vaddhn_s16(*v0, *v1); }
void VandqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vandq_u8(*v0, *v1); }
void VandqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vandq_u32(*v0, *v1); }
void VandqU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vandq_u64(*v0, *v1); }
void VandqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vandq_u16(*v0, *v1); }
void VandqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vandq_s8(*v0, *v1); }
void VandqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vandq_s32(*v0, *v1); }
void VandqS64(int64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vandq_s64(*v0, *v1); }
void VandqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vandq_s16(*v0, *v1); }
void VandU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vand_u8(*v0, *v1); }
void VandU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vand_u32(*v0, *v1); }
void VandU64(uint64x1_t* r, uint64x1_t* v0, uint64x1_t* v1) { *r = vand_u64(*v0, *v1); }
void VandU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vand_u16(*v0, *v1); }
void VandS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vand_s8(*v0, *v1); }
void VandS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vand_s32(*v0, *v1); }
void VandS64(int64x1_t* r, int64x1_t* v0, int64x1_t* v1) { *r = vand_s64(*v0, *v1); }
void VandS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vand_s16(*v0, *v1); }
void VbicqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vbicq_u8(*v0, *v1); }
void VbicqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vbicq_u32(*v0, *v1); }
void VbicqU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vbicq_u64(*v0, *v1); }
void VbicqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vbicq_u16(*v0, *v1); }
void VbicqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vbicq_s8(*v0, *v1); }
void VbicqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vbicq_s32(*v0, *v1); }
void VbicqS64(int64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vbicq_s64(*v0, *v1); }
void VbicqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vbicq_s16(*v0, *v1); }
void VbicU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vbic_u8(*v0, *v1); }
void VbicU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vbic_u32(*v0, *v1); }
void VbicU64(uint64x1_t* r, uint64x1_t* v0, uint64x1_t* v1) { *r = vbic_u64(*v0, *v1); }
void VbicU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vbic_u16(*v0, *v1); }
void VbicS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vbic_s8(*v0, *v1); }
void VbicS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vbic_s32(*v0, *v1); }
void VbicS64(int64x1_t* r, int64x1_t* v0, int64x1_t* v1) { *r = vbic_s64(*v0, *v1); }
void VbicS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vbic_s16(*v0, *v1); }
void VbslP8(poly8x8_t* r, uint8x8_t* v0, poly8x8_t* v1, poly8x8_t* v2) { *r = vbsl_p8(*v0, *v1, *v2); }
void VbslP16(poly16x4_t* r, uint16x4_t* v0, poly16x4_t* v1, poly16x4_t* v2) { *r = vbsl_p16(*v0, *v1, *v2); }
void VbslqP8(poly8x16_t* r, uint8x16_t* v0, poly8x16_t* v1, poly8x16_t* v2) { *r = vbslq_p8(*v0, *v1, *v2); }
void VbslqP16(poly16x8_t* r, uint16x8_t* v0, poly16x8_t* v1, poly16x8_t* v2) { *r = vbslq_p16(*v0, *v1, *v2); }
void VbslqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1, uint8x16_t* v2) { *r = vbslq_u8(*v0, *v1, *v2); }
void VbslqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1, uint32x4_t* v2) { *r = vbslq_u32(*v0, *v1, *v2); }
void VbslqU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1, uint64x2_t* v2) { *r = vbslq_u64(*v0, *v1, *v2); }
void VbslqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1, uint16x8_t* v2) { *r = vbslq_u16(*v0, *v1, *v2); }
void VbslqS8(int8x16_t* r, uint8x16_t* v0, int8x16_t* v1, int8x16_t* v2) { *r = vbslq_s8(*v0, *v1, *v2); }
void VbslqF32(float32x4_t* r, uint32x4_t* v0, float32x4_t* v1, float32x4_t* v2) { *r = vbslq_f32(*v0, *v1, *v2); }
void VbslqS32(int32x4_t* r, uint32x4_t* v0, int32x4_t* v1, int32x4_t* v2) { *r = vbslq_s32(*v0, *v1, *v2); }
void VbslqS64(int64x2_t* r, uint64x2_t* v0, int64x2_t* v1, int64x2_t* v2) { *r = vbslq_s64(*v0, *v1, *v2); }
void VbslqS16(int16x8_t* r, uint16x8_t* v0, int16x8_t* v1, int16x8_t* v2) { *r = vbslq_s16(*v0, *v1, *v2); }
void VbslU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1, uint8x8_t* v2) { *r = vbsl_u8(*v0, *v1, *v2); }
void VbslU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1, uint32x2_t* v2) { *r = vbsl_u32(*v0, *v1, *v2); }
void VbslU64(uint64x1_t* r, uint64x1_t* v0, uint64x1_t* v1, uint64x1_t* v2) { *r = vbsl_u64(*v0, *v1, *v2); }
void VbslU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1, uint16x4_t* v2) { *r = vbsl_u16(*v0, *v1, *v2); }
void VbslS8(int8x8_t* r, uint8x8_t* v0, int8x8_t* v1, int8x8_t* v2) { *r = vbsl_s8(*v0, *v1, *v2); }
void VbslF32(float32x2_t* r, uint32x2_t* v0, float32x2_t* v1, float32x2_t* v2) { *r = vbsl_f32(*v0, *v1, *v2); }
void VbslS32(int32x2_t* r, uint32x2_t* v0, int32x2_t* v1, int32x2_t* v2) { *r = vbsl_s32(*v0, *v1, *v2); }
void VbslS64(int64x1_t* r, uint64x1_t* v0, int64x1_t* v1, int64x1_t* v2) { *r = vbsl_s64(*v0, *v1, *v2); }
void VbslS16(int16x4_t* r, uint16x4_t* v0, int16x4_t* v1, int16x4_t* v2) { *r = vbsl_s16(*v0, *v1, *v2); }
void VcageqF32(uint32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vcageq_f32(*v0, *v1); }
void VcageF32(uint32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vcage_f32(*v0, *v1); }
void VcagtqF32(uint32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vcagtq_f32(*v0, *v1); }
void VcagtF32(uint32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vcagt_f32(*v0, *v1); }
void VcaleqF32(uint32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vcaleq_f32(*v0, *v1); }
void VcaleF32(uint32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vcale_f32(*v0, *v1); }
void VcaltqF32(uint32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vcaltq_f32(*v0, *v1); }
void VcaltF32(uint32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vcalt_f32(*v0, *v1); }
void VceqP8(uint8x8_t* r, poly8x8_t* v0, poly8x8_t* v1) { *r = vceq_p8(*v0, *v1); }
void VceqqP8(uint8x16_t* r, poly8x16_t* v0, poly8x16_t* v1) { *r = vceqq_p8(*v0, *v1); }
void VceqqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vceqq_u8(*v0, *v1); }
void VceqqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vceqq_u32(*v0, *v1); }
void VceqqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vceqq_u16(*v0, *v1); }
void VceqqS8(uint8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vceqq_s8(*v0, *v1); }
void VceqqF32(uint32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vceqq_f32(*v0, *v1); }
void VceqqS32(uint32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vceqq_s32(*v0, *v1); }
void VceqqS16(uint16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vceqq_s16(*v0, *v1); }
void VceqU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vceq_u8(*v0, *v1); }
void VceqU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vceq_u32(*v0, *v1); }
void VceqU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vceq_u16(*v0, *v1); }
void VceqS8(uint8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vceq_s8(*v0, *v1); }
void VceqF32(uint32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vceq_f32(*v0, *v1); }
void VceqS32(uint32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vceq_s32(*v0, *v1); }
void VceqS16(uint16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vceq_s16(*v0, *v1); }
void VcgeqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vcgeq_u8(*v0, *v1); }
void VcgeqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vcgeq_u32(*v0, *v1); }
void VcgeqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vcgeq_u16(*v0, *v1); }
void VcgeqS8(uint8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vcgeq_s8(*v0, *v1); }
void VcgeqF32(uint32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vcgeq_f32(*v0, *v1); }
void VcgeqS32(uint32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vcgeq_s32(*v0, *v1); }
void VcgeqS16(uint16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vcgeq_s16(*v0, *v1); }
void VcgeU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vcge_u8(*v0, *v1); }
void VcgeU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vcge_u32(*v0, *v1); }
void VcgeU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vcge_u16(*v0, *v1); }
void VcgeS8(uint8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vcge_s8(*v0, *v1); }
void VcgeF32(uint32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vcge_f32(*v0, *v1); }
void VcgeS32(uint32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vcge_s32(*v0, *v1); }
void VcgeS16(uint16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vcge_s16(*v0, *v1); }
void VcgtqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vcgtq_u8(*v0, *v1); }
void VcgtqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vcgtq_u32(*v0, *v1); }
void VcgtqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vcgtq_u16(*v0, *v1); }
void VcgtqS8(uint8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vcgtq_s8(*v0, *v1); }
void VcgtqF32(uint32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vcgtq_f32(*v0, *v1); }
void VcgtqS32(uint32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vcgtq_s32(*v0, *v1); }
void VcgtqS16(uint16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vcgtq_s16(*v0, *v1); }
void VcgtU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vcgt_u8(*v0, *v1); }
void VcgtU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vcgt_u32(*v0, *v1); }
void VcgtU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vcgt_u16(*v0, *v1); }
void VcgtS8(uint8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vcgt_s8(*v0, *v1); }
void VcgtF32(uint32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vcgt_f32(*v0, *v1); }
void VcgtS32(uint32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vcgt_s32(*v0, *v1); }
void VcgtS16(uint16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vcgt_s16(*v0, *v1); }
void VcleqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vcleq_u8(*v0, *v1); }
void VcleqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vcleq_u32(*v0, *v1); }
void VcleqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vcleq_u16(*v0, *v1); }
void VcleqS8(uint8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vcleq_s8(*v0, *v1); }
void VcleqF32(uint32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vcleq_f32(*v0, *v1); }
void VcleqS32(uint32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vcleq_s32(*v0, *v1); }
void VcleqS16(uint16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vcleq_s16(*v0, *v1); }
void VcleU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vcle_u8(*v0, *v1); }
void VcleU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vcle_u32(*v0, *v1); }
void VcleU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vcle_u16(*v0, *v1); }
void VcleS8(uint8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vcle_s8(*v0, *v1); }
void VcleF32(uint32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vcle_f32(*v0, *v1); }
void VcleS32(uint32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vcle_s32(*v0, *v1); }
void VcleS16(uint16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vcle_s16(*v0, *v1); }
void VclsqU8(int8x16_t* r, uint8x16_t* v0) { *r = vclsq_u8(*v0); }
void VclsqU32(int32x4_t* r, uint32x4_t* v0) { *r = vclsq_u32(*v0); }
void VclsqU16(int16x8_t* r, uint16x8_t* v0) { *r = vclsq_u16(*v0); }
void VclsqS8(int8x16_t* r, int8x16_t* v0) { *r = vclsq_s8(*v0); }
void VclsqS32(int32x4_t* r, int32x4_t* v0) { *r = vclsq_s32(*v0); }
void VclsqS16(int16x8_t* r, int16x8_t* v0) { *r = vclsq_s16(*v0); }
void VclsU8(int8x8_t* r, uint8x8_t* v0) { *r = vcls_u8(*v0); }
void VclsU32(int32x2_t* r, uint32x2_t* v0) { *r = vcls_u32(*v0); }
void VclsU16(int16x4_t* r, uint16x4_t* v0) { *r = vcls_u16(*v0); }
void VclsS8(int8x8_t* r, int8x8_t* v0) { *r = vcls_s8(*v0); }
void VclsS32(int32x2_t* r, int32x2_t* v0) { *r = vcls_s32(*v0); }
void VclsS16(int16x4_t* r, int16x4_t* v0) { *r = vcls_s16(*v0); }
void VcltqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vcltq_u8(*v0, *v1); }
void VcltqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vcltq_u32(*v0, *v1); }
void VcltqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vcltq_u16(*v0, *v1); }
void VcltqS8(uint8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vcltq_s8(*v0, *v1); }
void VcltqF32(uint32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vcltq_f32(*v0, *v1); }
void VcltqS32(uint32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vcltq_s32(*v0, *v1); }
void VcltqS16(uint16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vcltq_s16(*v0, *v1); }
void VcltU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vclt_u8(*v0, *v1); }
void VcltU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vclt_u32(*v0, *v1); }
void VcltU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vclt_u16(*v0, *v1); }
void VcltS8(uint8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vclt_s8(*v0, *v1); }
void VcltF32(uint32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vclt_f32(*v0, *v1); }
void VcltS32(uint32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vclt_s32(*v0, *v1); }
void VcltS16(uint16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vclt_s16(*v0, *v1); }
void VclzqU8(uint8x16_t* r, uint8x16_t* v0) { *r = vclzq_u8(*v0); }
void VclzqU32(uint32x4_t* r, uint32x4_t* v0) { *r = vclzq_u32(*v0); }
void VclzqU16(uint16x8_t* r, uint16x8_t* v0) { *r = vclzq_u16(*v0); }
void VclzqS8(int8x16_t* r, int8x16_t* v0) { *r = vclzq_s8(*v0); }
void VclzqS32(int32x4_t* r, int32x4_t* v0) { *r = vclzq_s32(*v0); }
void VclzqS16(int16x8_t* r, int16x8_t* v0) { *r = vclzq_s16(*v0); }
void VclzU8(uint8x8_t* r, uint8x8_t* v0) { *r = vclz_u8(*v0); }
void VclzU32(uint32x2_t* r, uint32x2_t* v0) { *r = vclz_u32(*v0); }
void VclzU16(uint16x4_t* r, uint16x4_t* v0) { *r = vclz_u16(*v0); }
void VclzS8(int8x8_t* r, int8x8_t* v0) { *r = vclz_s8(*v0); }
void VclzS32(int32x2_t* r, int32x2_t* v0) { *r = vclz_s32(*v0); }
void VclzS16(int16x4_t* r, int16x4_t* v0) { *r = vclz_s16(*v0); }
void VcntP8(poly8x8_t* r, poly8x8_t* v0) { *r = vcnt_p8(*v0); }
void VcntqP8(poly8x16_t* r, poly8x16_t* v0) { *r = vcntq_p8(*v0); }
void VcntqU8(uint8x16_t* r, uint8x16_t* v0) { *r = vcntq_u8(*v0); }
void VcntqS8(int8x16_t* r, int8x16_t* v0) { *r = vcntq_s8(*v0); }
void VcntU8(uint8x8_t* r, uint8x8_t* v0) { *r = vcnt_u8(*v0); }
void VcntS8(int8x8_t* r, int8x8_t* v0) { *r = vcnt_s8(*v0); }
void VcombineP8(poly8x16_t* r, poly8x8_t* v0, poly8x8_t* v1) { *r = vcombine_p8(*v0, *v1); }
void VcombineP16(poly16x8_t* r, poly16x4_t* v0, poly16x4_t* v1) { *r = vcombine_p16(*v0, *v1); }
void VcombineU8(uint8x16_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vcombine_u8(*v0, *v1); }
void VcombineU32(uint32x4_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vcombine_u32(*v0, *v1); }
void VcombineU64(uint64x2_t* r, uint64x1_t* v0, uint64x1_t* v1) { *r = vcombine_u64(*v0, *v1); }
void VcombineU16(uint16x8_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vcombine_u16(*v0, *v1); }
void VcombineS8(int8x16_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vcombine_s8(*v0, *v1); }
void VcombineF32(float32x4_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vcombine_f32(*v0, *v1); }
void VcombineS32(int32x4_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vcombine_s32(*v0, *v1); }
void VcombineS64(int64x2_t* r, int64x1_t* v0, int64x1_t* v1) { *r = vcombine_s64(*v0, *v1); }
void VcombineS16(int16x8_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vcombine_s16(*v0, *v1); }
void VcvtqF32U32(float32x4_t* r, uint32x4_t* v0) { *r = vcvtq_f32_u32(*v0); }
void VcvtqF32S32(float32x4_t* r, int32x4_t* v0) { *r = vcvtq_f32_s32(*v0); }
void VcvtF32U32(float32x2_t* r, uint32x2_t* v0) { *r = vcvt_f32_u32(*v0); }
void VcvtF32S32(float32x2_t* r, int32x2_t* v0) { *r = vcvt_f32_s32(*v0); }
void VcvtqS32F32(int32x4_t* r, float32x4_t* v0) { *r = vcvtq_s32_f32(*v0); }
void VcvtS32F32(int32x2_t* r, float32x2_t* v0) { *r = vcvt_s32_f32(*v0); }
void VcvtqU32F32(uint32x4_t* r, float32x4_t* v0) { *r = vcvtq_u32_f32(*v0); }
void VcvtU32F32(uint32x2_t* r, float32x2_t* v0) { *r = vcvt_u32_f32(*v0); }
void VdupNP8(poly8x8_t* r, poly8_t* v0) { *r = vdup_n_p8(*v0); }
void VdupNP16(poly16x4_t* r, poly16_t* v0) { *r = vdup_n_p16(*v0); }
void VdupqNP8(poly8x16_t* r, poly8_t* v0) { *r = vdupq_n_p8(*v0); }
void VdupqNP16(poly16x8_t* r, poly16_t* v0) { *r = vdupq_n_p16(*v0); }
void VdupqNU8(uint8x16_t* r, uint8_t* v0) { *r = vdupq_n_u8(*v0); }
void VdupqNU32(uint32x4_t* r, uint32_t* v0) { *r = vdupq_n_u32(*v0); }
void VdupqNU64(uint64x2_t* r, uint64_t* v0) { *r = vdupq_n_u64(*v0); }
void VdupqNU16(uint16x8_t* r, uint16_t* v0) { *r = vdupq_n_u16(*v0); }
void VdupqNS8(int8x16_t* r, int8_t* v0) { *r = vdupq_n_s8(*v0); }
void VdupqNF32(float32x4_t* r, float32_t* v0) { *r = vdupq_n_f32(*v0); }
void VdupqNS32(int32x4_t* r, int32_t* v0) { *r = vdupq_n_s32(*v0); }
void VdupqNS64(int64x2_t* r, int64_t* v0) { *r = vdupq_n_s64(*v0); }
void VdupqNS16(int16x8_t* r, int16_t* v0) { *r = vdupq_n_s16(*v0); }
void VdupNU8(uint8x8_t* r, uint8_t* v0) { *r = vdup_n_u8(*v0); }
void VdupNU32(uint32x2_t* r, uint32_t* v0) { *r = vdup_n_u32(*v0); }
void VdupNU64(uint64x1_t* r, uint64_t* v0) { *r = vdup_n_u64(*v0); }
void VdupNU16(uint16x4_t* r, uint16_t* v0) { *r = vdup_n_u16(*v0); }
void VdupNS8(int8x8_t* r, int8_t* v0) { *r = vdup_n_s8(*v0); }
void VdupNF32(float32x2_t* r, float32_t* v0) { *r = vdup_n_f32(*v0); }
void VdupNS32(int32x2_t* r, int32_t* v0) { *r = vdup_n_s32(*v0); }
void VdupNS64(int64x1_t* r, int64_t* v0) { *r = vdup_n_s64(*v0); }
void VdupNS16(int16x4_t* r, int16_t* v0) { *r = vdup_n_s16(*v0); }
void VeorqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = veorq_u8(*v0, *v1); }
void VeorqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = veorq_u32(*v0, *v1); }
void VeorqU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = veorq_u64(*v0, *v1); }
void VeorqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = veorq_u16(*v0, *v1); }
void VeorqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = veorq_s8(*v0, *v1); }
void VeorqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = veorq_s32(*v0, *v1); }
void VeorqS64(int64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = veorq_s64(*v0, *v1); }
void VeorqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = veorq_s16(*v0, *v1); }
void VeorU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = veor_u8(*v0, *v1); }
void VeorU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = veor_u32(*v0, *v1); }
void VeorU64(uint64x1_t* r, uint64x1_t* v0, uint64x1_t* v1) { *r = veor_u64(*v0, *v1); }
void VeorU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = veor_u16(*v0, *v1); }
void VeorS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = veor_s8(*v0, *v1); }
void VeorS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = veor_s32(*v0, *v1); }
void VeorS64(int64x1_t* r, int64x1_t* v0, int64x1_t* v1) { *r = veor_s64(*v0, *v1); }
void VeorS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = veor_s16(*v0, *v1); }
void VgetHighP8(poly8x8_t* r, poly8x16_t* v0) { *r = vget_high_p8(*v0); }
void VgetHighP16(poly16x4_t* r, poly16x8_t* v0) { *r = vget_high_p16(*v0); }
void VgetHighU8(uint8x8_t* r, uint8x16_t* v0) { *r = vget_high_u8(*v0); }
void VgetHighU32(uint32x2_t* r, uint32x4_t* v0) { *r = vget_high_u32(*v0); }
void VgetHighU64(uint64x1_t* r, uint64x2_t* v0) { *r = vget_high_u64(*v0); }
void VgetHighU16(uint16x4_t* r, uint16x8_t* v0) { *r = vget_high_u16(*v0); }
void VgetHighS8(int8x8_t* r, int8x16_t* v0) { *r = vget_high_s8(*v0); }
void VgetHighF32(float32x2_t* r, float32x4_t* v0) { *r = vget_high_f32(*v0); }
void VgetHighS32(int32x2_t* r, int32x4_t* v0) { *r = vget_high_s32(*v0); }
void VgetHighS64(int64x1_t* r, int64x2_t* v0) { *r = vget_high_s64(*v0); }
void VgetHighS16(int16x4_t* r, int16x8_t* v0) { *r = vget_high_s16(*v0); }
void VgetLowP8(poly8x8_t* r, poly8x16_t* v0) { *r = vget_low_p8(*v0); }
void VgetLowP16(poly16x4_t* r, poly16x8_t* v0) { *r = vget_low_p16(*v0); }
void VgetLowU8(uint8x8_t* r, uint8x16_t* v0) { *r = vget_low_u8(*v0); }
void VgetLowU32(uint32x2_t* r, uint32x4_t* v0) { *r = vget_low_u32(*v0); }
void VgetLowU64(uint64x1_t* r, uint64x2_t* v0) { *r = vget_low_u64(*v0); }
void VgetLowU16(uint16x4_t* r, uint16x8_t* v0) { *r = vget_low_u16(*v0); }
void VgetLowS8(int8x8_t* r, int8x16_t* v0) { *r = vget_low_s8(*v0); }
void VgetLowF32(float32x2_t* r, float32x4_t* v0) { *r = vget_low_f32(*v0); }
void VgetLowS32(int32x2_t* r, int32x4_t* v0) { *r = vget_low_s32(*v0); }
void VgetLowS64(int64x1_t* r, int64x2_t* v0) { *r = vget_low_s64(*v0); }
void VgetLowS16(int16x4_t* r, int16x8_t* v0) { *r = vget_low_s16(*v0); }
void VhaddqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vhaddq_u8(*v0, *v1); }
void VhaddqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vhaddq_u32(*v0, *v1); }
void VhaddqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vhaddq_u16(*v0, *v1); }
void VhaddqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vhaddq_s8(*v0, *v1); }
void VhaddqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vhaddq_s32(*v0, *v1); }
void VhaddqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vhaddq_s16(*v0, *v1); }
void VhaddU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vhadd_u8(*v0, *v1); }
void VhaddU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vhadd_u32(*v0, *v1); }
void VhaddU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vhadd_u16(*v0, *v1); }
void VhaddS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vhadd_s8(*v0, *v1); }
void VhaddS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vhadd_s32(*v0, *v1); }
void VhaddS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vhadd_s16(*v0, *v1); }
void VhsubqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vhsubq_u8(*v0, *v1); }
void VhsubqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vhsubq_u32(*v0, *v1); }
void VhsubqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vhsubq_u16(*v0, *v1); }
void VhsubqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vhsubq_s8(*v0, *v1); }
void VhsubqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vhsubq_s32(*v0, *v1); }
void VhsubqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vhsubq_s16(*v0, *v1); }
void VhsubU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vhsub_u8(*v0, *v1); }
void VhsubU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vhsub_u32(*v0, *v1); }
void VhsubU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vhsub_u16(*v0, *v1); }
void VhsubS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vhsub_s8(*v0, *v1); }
void VhsubS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vhsub_s32(*v0, *v1); }
void VhsubS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vhsub_s16(*v0, *v1); }
void VmaxqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vmaxq_u8(*v0, *v1); }
void VmaxqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vmaxq_u32(*v0, *v1); }
void VmaxqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vmaxq_u16(*v0, *v1); }
void VmaxqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vmaxq_s8(*v0, *v1); }
void VmaxqF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vmaxq_f32(*v0, *v1); }
void VmaxqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vmaxq_s32(*v0, *v1); }
void VmaxqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vmaxq_s16(*v0, *v1); }
void VmaxU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vmax_u8(*v0, *v1); }
void VmaxU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vmax_u32(*v0, *v1); }
void VmaxU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vmax_u16(*v0, *v1); }
void VmaxS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vmax_s8(*v0, *v1); }
void VmaxF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vmax_f32(*v0, *v1); }
void VmaxS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vmax_s32(*v0, *v1); }
void VmaxS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vmax_s16(*v0, *v1); }
void VminqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vminq_u8(*v0, *v1); }
void VminqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vminq_u32(*v0, *v1); }
void VminqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vminq_u16(*v0, *v1); }
void VminqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vminq_s8(*v0, *v1); }
void VminqF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vminq_f32(*v0, *v1); }
void VminqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vminq_s32(*v0, *v1); }
void VminqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vminq_s16(*v0, *v1); }
void VminU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vmin_u8(*v0, *v1); }
void VminU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vmin_u32(*v0, *v1); }
void VminU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vmin_u16(*v0, *v1); }
void VminS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vmin_s8(*v0, *v1); }
void VminF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vmin_f32(*v0, *v1); }
void VminS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vmin_s32(*v0, *v1); }
void VminS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vmin_s16(*v0, *v1); }
void VmlaqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1, uint8x16_t* v2) { *r = vmlaq_u8(*v0, *v1, *v2); }
void VmlaqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1, uint32x4_t* v2) { *r = vmlaq_u32(*v0, *v1, *v2); }
void VmlaqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1, uint16x8_t* v2) { *r = vmlaq_u16(*v0, *v1, *v2); }
void VmlaqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1, int8x16_t* v2) { *r = vmlaq_s8(*v0, *v1, *v2); }
void VmlaqF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1, float32x4_t* v2) { *r = vmlaq_f32(*v0, *v1, *v2); }
void VmlaqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1, int32x4_t* v2) { *r = vmlaq_s32(*v0, *v1, *v2); }
void VmlaqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1, int16x8_t* v2) { *r = vmlaq_s16(*v0, *v1, *v2); }
void VmlaU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1, uint8x8_t* v2) { *r = vmla_u8(*v0, *v1, *v2); }
void VmlaU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1, uint32x2_t* v2) { *r = vmla_u32(*v0, *v1, *v2); }
void VmlaU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1, uint16x4_t* v2) { *r = vmla_u16(*v0, *v1, *v2); }
void VmlaS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1, int8x8_t* v2) { *r = vmla_s8(*v0, *v1, *v2); }
void VmlaF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1, float32x2_t* v2) { *r = vmla_f32(*v0, *v1, *v2); }
void VmlaS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1, int32x2_t* v2) { *r = vmla_s32(*v0, *v1, *v2); }
void VmlaS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1, int16x4_t* v2) { *r = vmla_s16(*v0, *v1, *v2); }
void VmlaqNU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1, uint32_t* v2) { *r = vmlaq_n_u32(*v0, *v1, *v2); }
void VmlaqNU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1, uint16_t* v2) { *r = vmlaq_n_u16(*v0, *v1, *v2); }
void VmlaqNF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1, float32_t* v2) { *r = vmlaq_n_f32(*v0, *v1, *v2); }
void VmlaqNS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1, int32_t* v2) { *r = vmlaq_n_s32(*v0, *v1, *v2); }
void VmlaqNS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1, int16_t* v2) { *r = vmlaq_n_s16(*v0, *v1, *v2); }
void VmlaNU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1, uint32_t* v2) { *r = vmla_n_u32(*v0, *v1, *v2); }
void VmlaNU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1, uint16_t* v2) { *r = vmla_n_u16(*v0, *v1, *v2); }
void VmlaNF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1, float32_t* v2) { *r = vmla_n_f32(*v0, *v1, *v2); }
void VmlaNS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1, int32_t* v2) { *r = vmla_n_s32(*v0, *v1, *v2); }
void VmlaNS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1, int16_t* v2) { *r = vmla_n_s16(*v0, *v1, *v2); }
void VmlsqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1, uint8x16_t* v2) { *r = vmlsq_u8(*v0, *v1, *v2); }
void VmlsqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1, uint32x4_t* v2) { *r = vmlsq_u32(*v0, *v1, *v2); }
void VmlsqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1, uint16x8_t* v2) { *r = vmlsq_u16(*v0, *v1, *v2); }
void VmlsqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1, int8x16_t* v2) { *r = vmlsq_s8(*v0, *v1, *v2); }
void VmlsqF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1, float32x4_t* v2) { *r = vmlsq_f32(*v0, *v1, *v2); }
void VmlsqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1, int32x4_t* v2) { *r = vmlsq_s32(*v0, *v1, *v2); }
void VmlsqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1, int16x8_t* v2) { *r = vmlsq_s16(*v0, *v1, *v2); }
void VmlsU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1, uint8x8_t* v2) { *r = vmls_u8(*v0, *v1, *v2); }
void VmlsU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1, uint32x2_t* v2) { *r = vmls_u32(*v0, *v1, *v2); }
void VmlsU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1, uint16x4_t* v2) { *r = vmls_u16(*v0, *v1, *v2); }
void VmlsS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1, int8x8_t* v2) { *r = vmls_s8(*v0, *v1, *v2); }
void VmlsF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1, float32x2_t* v2) { *r = vmls_f32(*v0, *v1, *v2); }
void VmlsS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1, int32x2_t* v2) { *r = vmls_s32(*v0, *v1, *v2); }
void VmlsS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1, int16x4_t* v2) { *r = vmls_s16(*v0, *v1, *v2); }
void VmlsqNU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1, uint32_t* v2) { *r = vmlsq_n_u32(*v0, *v1, *v2); }
void VmlsqNU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1, uint16_t* v2) { *r = vmlsq_n_u16(*v0, *v1, *v2); }
void VmlsqNF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1, float32_t* v2) { *r = vmlsq_n_f32(*v0, *v1, *v2); }
void VmlsqNS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1, int32_t* v2) { *r = vmlsq_n_s32(*v0, *v1, *v2); }
void VmlsqNS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1, int16_t* v2) { *r = vmlsq_n_s16(*v0, *v1, *v2); }
void VmlsNU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1, uint32_t* v2) { *r = vmls_n_u32(*v0, *v1, *v2); }
void VmlsNU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1, uint16_t* v2) { *r = vmls_n_u16(*v0, *v1, *v2); }
void VmlsNF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1, float32_t* v2) { *r = vmls_n_f32(*v0, *v1, *v2); }
void VmlsNS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1, int32_t* v2) { *r = vmls_n_s32(*v0, *v1, *v2); }
void VmlsNS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1, int16_t* v2) { *r = vmls_n_s16(*v0, *v1, *v2); }
void VmovNP8(poly8x8_t* r, poly8_t* v0) { *r = vmov_n_p8(*v0); }
void VmovNP16(poly16x4_t* r, poly16_t* v0) { *r = vmov_n_p16(*v0); }
void VmovqNP8(poly8x16_t* r, poly8_t* v0) { *r = vmovq_n_p8(*v0); }
void VmovqNP16(poly16x8_t* r, poly16_t* v0) { *r = vmovq_n_p16(*v0); }
void VmovqNU8(uint8x16_t* r, uint8_t* v0) { *r = vmovq_n_u8(*v0); }
void VmovqNU32(uint32x4_t* r, uint32_t* v0) { *r = vmovq_n_u32(*v0); }
void VmovqNU64(uint64x2_t* r, uint64_t* v0) { *r = vmovq_n_u64(*v0); }
void VmovqNU16(uint16x8_t* r, uint16_t* v0) { *r = vmovq_n_u16(*v0); }
void VmovqNS8(int8x16_t* r, int8_t* v0) { *r = vmovq_n_s8(*v0); }
void VmovqNF32(float32x4_t* r, float32_t* v0) { *r = vmovq_n_f32(*v0); }
void VmovqNS32(int32x4_t* r, int32_t* v0) { *r = vmovq_n_s32(*v0); }
void VmovqNS64(int64x2_t* r, int64_t* v0) { *r = vmovq_n_s64(*v0); }
void VmovqNS16(int16x8_t* r, int16_t* v0) { *r = vmovq_n_s16(*v0); }
void VmovNU8(uint8x8_t* r, uint8_t* v0) { *r = vmov_n_u8(*v0); }
void VmovNU32(uint32x2_t* r, uint32_t* v0) { *r = vmov_n_u32(*v0); }
void VmovNU64(uint64x1_t* r, uint64_t* v0) { *r = vmov_n_u64(*v0); }
void VmovNU16(uint16x4_t* r, uint16_t* v0) { *r = vmov_n_u16(*v0); }
void VmovNS8(int8x8_t* r, int8_t* v0) { *r = vmov_n_s8(*v0); }
void VmovNF32(float32x2_t* r, float32_t* v0) { *r = vmov_n_f32(*v0); }
void VmovNS32(int32x2_t* r, int32_t* v0) { *r = vmov_n_s32(*v0); }
void VmovNS64(int64x1_t* r, int64_t* v0) { *r = vmov_n_s64(*v0); }
void VmovNS16(int16x4_t* r, int16_t* v0) { *r = vmov_n_s16(*v0); }
void VmovlU8(uint16x8_t* r, uint8x8_t* v0) { *r = vmovl_u8(*v0); }
void VmovlU32(uint64x2_t* r, uint32x2_t* v0) { *r = vmovl_u32(*v0); }
void VmovlU16(uint32x4_t* r, uint16x4_t* v0) { *r = vmovl_u16(*v0); }
void VmovlS8(int16x8_t* r, int8x8_t* v0) { *r = vmovl_s8(*v0); }
void VmovlS32(int64x2_t* r, int32x2_t* v0) { *r = vmovl_s32(*v0); }
void VmovlS16(int32x4_t* r, int16x4_t* v0) { *r = vmovl_s16(*v0); }
void VmovnU32(uint16x4_t* r, uint32x4_t* v0) { *r = vmovn_u32(*v0); }
void VmovnU64(uint32x2_t* r, uint64x2_t* v0) { *r = vmovn_u64(*v0); }
void VmovnU16(uint8x8_t* r, uint16x8_t* v0) { *r = vmovn_u16(*v0); }
void VmovnS32(int16x4_t* r, int32x4_t* v0) { *r = vmovn_s32(*v0); }
void VmovnS64(int32x2_t* r, int64x2_t* v0) { *r = vmovn_s64(*v0); }
void VmovnS16(int8x8_t* r, int16x8_t* v0) { *r = vmovn_s16(*v0); }
void VmulqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vmulq_u8(*v0, *v1); }
void VmulqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vmulq_u32(*v0, *v1); }
void VmulqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vmulq_u16(*v0, *v1); }
void VmulqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vmulq_s8(*v0, *v1); }
void VmulqF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vmulq_f32(*v0, *v1); }
void VmulqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vmulq_s32(*v0, *v1); }
void VmulqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vmulq_s16(*v0, *v1); }
void VmulU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vmul_u8(*v0, *v1); }
void VmulU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vmul_u32(*v0, *v1); }
void VmulU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vmul_u16(*v0, *v1); }
void VmulS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vmul_s8(*v0, *v1); }
void VmulF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vmul_f32(*v0, *v1); }
void VmulS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vmul_s32(*v0, *v1); }
void VmulS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vmul_s16(*v0, *v1); }
void VmulP8(poly8x8_t* r, poly8x8_t* v0, poly8x8_t* v1) { *r = vmul_p8(*v0, *v1); }
void VmulqP8(poly8x16_t* r, poly8x16_t* v0, poly8x16_t* v1) { *r = vmulq_p8(*v0, *v1); }
void VmulqNU32(uint32x4_t* r, uint32x4_t* v0, uint32_t* v1) { *r = vmulq_n_u32(*v0, *v1); }
void VmulqNU16(uint16x8_t* r, uint16x8_t* v0, uint16_t* v1) { *r = vmulq_n_u16(*v0, *v1); }
void VmulqNF32(float32x4_t* r, float32x4_t* v0, float32_t* v1) { *r = vmulq_n_f32(*v0, *v1); }
void VmulqNS32(int32x4_t* r, int32x4_t* v0, int32_t* v1) { *r = vmulq_n_s32(*v0, *v1); }
void VmulqNS16(int16x8_t* r, int16x8_t* v0, int16_t* v1) { *r = vmulq_n_s16(*v0, *v1); }
void VmulNU32(uint32x2_t* r, uint32x2_t* v0, uint32_t* v1) { *r = vmul_n_u32(*v0, *v1); }
void VmulNU16(uint16x4_t* r, uint16x4_t* v0, uint16_t* v1) { *r = vmul_n_u16(*v0, *v1); }
void VmulNF32(float32x2_t* r, float32x2_t* v0, float32_t* v1) { *r = vmul_n_f32(*v0, *v1); }
void VmulNS32(int32x2_t* r, int32x2_t* v0, int32_t* v1) { *r = vmul_n_s32(*v0, *v1); }
void VmulNS16(int16x4_t* r, int16x4_t* v0, int16_t* v1) { *r = vmul_n_s16(*v0, *v1); }
void VmullP8(poly16x8_t* r, poly8x8_t* v0, poly8x8_t* v1) { *r = vmull_p8(*v0, *v1); }
void VmullU8(uint16x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vmull_u8(*v0, *v1); }
void VmullU32(uint64x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vmull_u32(*v0, *v1); }
void VmullU16(uint32x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vmull_u16(*v0, *v1); }
void VmullS8(int16x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vmull_s8(*v0, *v1); }
void VmullS32(int64x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vmull_s32(*v0, *v1); }
void VmullS16(int32x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vmull_s16(*v0, *v1); }
void VmullNU32(uint64x2_t* r, uint32x2_t* v0, uint32_t* v1) { *r = vmull_n_u32(*v0, *v1); }
void VmullNU16(uint32x4_t* r, uint16x4_t* v0, uint16_t* v1) { *r = vmull_n_u16(*v0, *v1); }
void VmullNS32(int64x2_t* r, int32x2_t* v0, int32_t* v1) { *r = vmull_n_s32(*v0, *v1); }
void VmullNS16(int32x4_t* r, int16x4_t* v0, int16_t* v1) { *r = vmull_n_s16(*v0, *v1); }
void VmvnP8(poly8x8_t* r, poly8x8_t* v0) { *r = vmvn_p8(*v0); }
void VmvnqP8(poly8x16_t* r, poly8x16_t* v0) { *r = vmvnq_p8(*v0); }
void VmvnqU8(uint8x16_t* r, uint8x16_t* v0) { *r = vmvnq_u8(*v0); }
void VmvnqU32(uint32x4_t* r, uint32x4_t* v0) { *r = vmvnq_u32(*v0); }
void VmvnqU16(uint16x8_t* r, uint16x8_t* v0) { *r = vmvnq_u16(*v0); }
void VmvnqS8(int8x16_t* r, int8x16_t* v0) { *r = vmvnq_s8(*v0); }
void VmvnqS32(int32x4_t* r, int32x4_t* v0) { *r = vmvnq_s32(*v0); }
void VmvnqS16(int16x8_t* r, int16x8_t* v0) { *r = vmvnq_s16(*v0); }
void VmvnU8(uint8x8_t* r, uint8x8_t* v0) { *r = vmvn_u8(*v0); }
void VmvnU32(uint32x2_t* r, uint32x2_t* v0) { *r = vmvn_u32(*v0); }
void VmvnU16(uint16x4_t* r, uint16x4_t* v0) { *r = vmvn_u16(*v0); }
void VmvnS8(int8x8_t* r, int8x8_t* v0) { *r = vmvn_s8(*v0); }
void VmvnS32(int32x2_t* r, int32x2_t* v0) { *r = vmvn_s32(*v0); }
void VmvnS16(int16x4_t* r, int16x4_t* v0) { *r = vmvn_s16(*v0); }
void VnegqS8(int8x16_t* r, int8x16_t* v0) { *r = vnegq_s8(*v0); }
void VnegqF32(float32x4_t* r, float32x4_t* v0) { *r = vnegq_f32(*v0); }
void VnegqS32(int32x4_t* r, int32x4_t* v0) { *r = vnegq_s32(*v0); }
void VnegqS16(int16x8_t* r, int16x8_t* v0) { *r = vnegq_s16(*v0); }
void VnegS8(int8x8_t* r, int8x8_t* v0) { *r = vneg_s8(*v0); }
void VnegF32(float32x2_t* r, float32x2_t* v0) { *r = vneg_f32(*v0); }
void VnegS32(int32x2_t* r, int32x2_t* v0) { *r = vneg_s32(*v0); }
void VnegS16(int16x4_t* r, int16x4_t* v0) { *r = vneg_s16(*v0); }
void VornqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vornq_u8(*v0, *v1); }
void VornqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vornq_u32(*v0, *v1); }
void VornqU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vornq_u64(*v0, *v1); }
void VornqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vornq_u16(*v0, *v1); }
void VornqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vornq_s8(*v0, *v1); }
void VornqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vornq_s32(*v0, *v1); }
void VornqS64(int64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vornq_s64(*v0, *v1); }
void VornqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vornq_s16(*v0, *v1); }
void VornU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vorn_u8(*v0, *v1); }
void VornU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vorn_u32(*v0, *v1); }
void VornU64(uint64x1_t* r, uint64x1_t* v0, uint64x1_t* v1) { *r = vorn_u64(*v0, *v1); }
void VornU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vorn_u16(*v0, *v1); }
void VornS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vorn_s8(*v0, *v1); }
void VornS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vorn_s32(*v0, *v1); }
void VornS64(int64x1_t* r, int64x1_t* v0, int64x1_t* v1) { *r = vorn_s64(*v0, *v1); }
void VornS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vorn_s16(*v0, *v1); }
void VorrqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vorrq_u8(*v0, *v1); }
void VorrqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vorrq_u32(*v0, *v1); }
void VorrqU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vorrq_u64(*v0, *v1); }
void VorrqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vorrq_u16(*v0, *v1); }
void VorrqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vorrq_s8(*v0, *v1); }
void VorrqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vorrq_s32(*v0, *v1); }
void VorrqS64(int64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vorrq_s64(*v0, *v1); }
void VorrqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vorrq_s16(*v0, *v1); }
void VorrU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vorr_u8(*v0, *v1); }
void VorrU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vorr_u32(*v0, *v1); }
void VorrU64(uint64x1_t* r, uint64x1_t* v0, uint64x1_t* v1) { *r = vorr_u64(*v0, *v1); }
void VorrU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vorr_u16(*v0, *v1); }
void VorrS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vorr_s8(*v0, *v1); }
void VorrS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vorr_s32(*v0, *v1); }
void VorrS64(int64x1_t* r, int64x1_t* v0, int64x1_t* v1) { *r = vorr_s64(*v0, *v1); }
void VorrS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vorr_s16(*v0, *v1); }
void VpadalqU8(uint16x8_t* r, uint16x8_t* v0, uint8x16_t* v1) { *r = vpadalq_u8(*v0, *v1); }
void VpadalqU32(uint64x2_t* r, uint64x2_t* v0, uint32x4_t* v1) { *r = vpadalq_u32(*v0, *v1); }
void VpadalqU16(uint32x4_t* r, uint32x4_t* v0, uint16x8_t* v1) { *r = vpadalq_u16(*v0, *v1); }
void VpadalqS8(int16x8_t* r, int16x8_t* v0, int8x16_t* v1) { *r = vpadalq_s8(*v0, *v1); }
void VpadalqS32(int64x2_t* r, int64x2_t* v0, int32x4_t* v1) { *r = vpadalq_s32(*v0, *v1); }
void VpadalqS16(int32x4_t* r, int32x4_t* v0, int16x8_t* v1) { *r = vpadalq_s16(*v0, *v1); }
void VpadalU8(uint16x4_t* r, uint16x4_t* v0, uint8x8_t* v1) { *r = vpadal_u8(*v0, *v1); }
void VpadalU32(uint64x1_t* r, uint64x1_t* v0, uint32x2_t* v1) { *r = vpadal_u32(*v0, *v1); }
void VpadalU16(uint32x2_t* r, uint32x2_t* v0, uint16x4_t* v1) { *r = vpadal_u16(*v0, *v1); }
void VpadalS8(int16x4_t* r, int16x4_t* v0, int8x8_t* v1) { *r = vpadal_s8(*v0, *v1); }
void VpadalS32(int64x1_t* r, int64x1_t* v0, int32x2_t* v1) { *r = vpadal_s32(*v0, *v1); }
void VpadalS16(int32x2_t* r, int32x2_t* v0, int16x4_t* v1) { *r = vpadal_s16(*v0, *v1); }
void VpaddU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vpadd_u8(*v0, *v1); }
void VpaddU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vpadd_u32(*v0, *v1); }
void VpaddU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vpadd_u16(*v0, *v1); }
void VpaddS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vpadd_s8(*v0, *v1); }
void VpaddF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vpadd_f32(*v0, *v1); }
void VpaddS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vpadd_s32(*v0, *v1); }
void VpaddS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vpadd_s16(*v0, *v1); }
void VpaddlqU8(uint16x8_t* r, uint8x16_t* v0) { *r = vpaddlq_u8(*v0); }
void VpaddlqU32(uint64x2_t* r, uint32x4_t* v0) { *r = vpaddlq_u32(*v0); }
void VpaddlqU16(uint32x4_t* r, uint16x8_t* v0) { *r = vpaddlq_u16(*v0); }
void VpaddlqS8(int16x8_t* r, int8x16_t* v0) { *r = vpaddlq_s8(*v0); }
void VpaddlqS32(int64x2_t* r, int32x4_t* v0) { *r = vpaddlq_s32(*v0); }
void VpaddlqS16(int32x4_t* r, int16x8_t* v0) { *r = vpaddlq_s16(*v0); }
void VpaddlU8(uint16x4_t* r, uint8x8_t* v0) { *r = vpaddl_u8(*v0); }
void VpaddlU32(uint64x1_t* r, uint32x2_t* v0) { *r = vpaddl_u32(*v0); }
void VpaddlU16(uint32x2_t* r, uint16x4_t* v0) { *r = vpaddl_u16(*v0); }
void VpaddlS8(int16x4_t* r, int8x8_t* v0) { *r = vpaddl_s8(*v0); }
void VpaddlS32(int64x1_t* r, int32x2_t* v0) { *r = vpaddl_s32(*v0); }
void VpaddlS16(int32x2_t* r, int16x4_t* v0) { *r = vpaddl_s16(*v0); }
void VpmaxU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vpmax_u8(*v0, *v1); }
void VpmaxU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vpmax_u32(*v0, *v1); }
void VpmaxU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vpmax_u16(*v0, *v1); }
void VpmaxS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vpmax_s8(*v0, *v1); }
void VpmaxF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vpmax_f32(*v0, *v1); }
void VpmaxS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vpmax_s32(*v0, *v1); }
void VpmaxS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vpmax_s16(*v0, *v1); }
void VpminU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vpmin_u8(*v0, *v1); }
void VpminU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vpmin_u32(*v0, *v1); }
void VpminU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vpmin_u16(*v0, *v1); }
void VpminS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vpmin_s8(*v0, *v1); }
void VpminF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vpmin_f32(*v0, *v1); }
void VpminS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vpmin_s32(*v0, *v1); }
void VpminS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vpmin_s16(*v0, *v1); }
void VqabsqS8(int8x16_t* r, int8x16_t* v0) { *r = vqabsq_s8(*v0); }
void VqabsqS32(int32x4_t* r, int32x4_t* v0) { *r = vqabsq_s32(*v0); }
void VqabsqS16(int16x8_t* r, int16x8_t* v0) { *r = vqabsq_s16(*v0); }
void VqabsS8(int8x8_t* r, int8x8_t* v0) { *r = vqabs_s8(*v0); }
void VqabsS32(int32x2_t* r, int32x2_t* v0) { *r = vqabs_s32(*v0); }
void VqabsS16(int16x4_t* r, int16x4_t* v0) { *r = vqabs_s16(*v0); }
void VqaddqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vqaddq_u8(*v0, *v1); }
void VqaddqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vqaddq_u32(*v0, *v1); }
void VqaddqU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vqaddq_u64(*v0, *v1); }
void VqaddqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vqaddq_u16(*v0, *v1); }
void VqaddqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vqaddq_s8(*v0, *v1); }
void VqaddqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vqaddq_s32(*v0, *v1); }
void VqaddqS64(int64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vqaddq_s64(*v0, *v1); }
void VqaddqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vqaddq_s16(*v0, *v1); }
void VqaddU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vqadd_u8(*v0, *v1); }
void VqaddU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vqadd_u32(*v0, *v1); }
void VqaddU64(uint64x1_t* r, uint64x1_t* v0, uint64x1_t* v1) { *r = vqadd_u64(*v0, *v1); }
void VqaddU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vqadd_u16(*v0, *v1); }
void VqaddS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vqadd_s8(*v0, *v1); }
void VqaddS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vqadd_s32(*v0, *v1); }
void VqaddS64(int64x1_t* r, int64x1_t* v0, int64x1_t* v1) { *r = vqadd_s64(*v0, *v1); }
void VqaddS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vqadd_s16(*v0, *v1); }
void VqdmlalS32(int64x2_t* r, int64x2_t* v0, int32x2_t* v1, int32x2_t* v2) { *r = vqdmlal_s32(*v0, *v1, *v2); }
void VqdmlalS16(int32x4_t* r, int32x4_t* v0, int16x4_t* v1, int16x4_t* v2) { *r = vqdmlal_s16(*v0, *v1, *v2); }
void VqdmlalNS32(int64x2_t* r, int64x2_t* v0, int32x2_t* v1, int32_t* v2) { *r = vqdmlal_n_s32(*v0, *v1, *v2); }
void VqdmlalNS16(int32x4_t* r, int32x4_t* v0, int16x4_t* v1, int16_t* v2) { *r = vqdmlal_n_s16(*v0, *v1, *v2); }
void VqdmlslS32(int64x2_t* r, int64x2_t* v0, int32x2_t* v1, int32x2_t* v2) { *r = vqdmlsl_s32(*v0, *v1, *v2); }
void VqdmlslS16(int32x4_t* r, int32x4_t* v0, int16x4_t* v1, int16x4_t* v2) { *r = vqdmlsl_s16(*v0, *v1, *v2); }
void VqdmlslNS32(int64x2_t* r, int64x2_t* v0, int32x2_t* v1, int32_t* v2) { *r = vqdmlsl_n_s32(*v0, *v1, *v2); }
void VqdmlslNS16(int32x4_t* r, int32x4_t* v0, int16x4_t* v1, int16_t* v2) { *r = vqdmlsl_n_s16(*v0, *v1, *v2); }
void VqdmulhqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vqdmulhq_s32(*v0, *v1); }
void VqdmulhqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vqdmulhq_s16(*v0, *v1); }
void VqdmulhS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vqdmulh_s32(*v0, *v1); }
void VqdmulhS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vqdmulh_s16(*v0, *v1); }
void VqdmulhqNS32(int32x4_t* r, int32x4_t* v0, int32_t* v1) { *r = vqdmulhq_n_s32(*v0, *v1); }
void VqdmulhqNS16(int16x8_t* r, int16x8_t* v0, int16_t* v1) { *r = vqdmulhq_n_s16(*v0, *v1); }
void VqdmulhNS32(int32x2_t* r, int32x2_t* v0, int32_t* v1) { *r = vqdmulh_n_s32(*v0, *v1); }
void VqdmulhNS16(int16x4_t* r, int16x4_t* v0, int16_t* v1) { *r = vqdmulh_n_s16(*v0, *v1); }
void VqdmullS32(int64x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vqdmull_s32(*v0, *v1); }
void VqdmullS16(int32x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vqdmull_s16(*v0, *v1); }
void VqdmullNS32(int64x2_t* r, int32x2_t* v0, int32_t* v1) { *r = vqdmull_n_s32(*v0, *v1); }
void VqdmullNS16(int32x4_t* r, int16x4_t* v0, int16_t* v1) { *r = vqdmull_n_s16(*v0, *v1); }
void VqmovnU32(uint16x4_t* r, uint32x4_t* v0) { *r = vqmovn_u32(*v0); }
void VqmovnU64(uint32x2_t* r, uint64x2_t* v0) { *r = vqmovn_u64(*v0); }
void VqmovnU16(uint8x8_t* r, uint16x8_t* v0) { *r = vqmovn_u16(*v0); }
void VqmovnS32(int16x4_t* r, int32x4_t* v0) { *r = vqmovn_s32(*v0); }
void VqmovnS64(int32x2_t* r, int64x2_t* v0) { *r = vqmovn_s64(*v0); }
void VqmovnS16(int8x8_t* r, int16x8_t* v0) { *r = vqmovn_s16(*v0); }
void VqmovunS32(uint16x4_t* r, int32x4_t* v0) { *r = vqmovun_s32(*v0); }
void VqmovunS64(uint32x2_t* r, int64x2_t* v0) { *r = vqmovun_s64(*v0); }
void VqmovunS16(uint8x8_t* r, int16x8_t* v0) { *r = vqmovun_s16(*v0); }
void VqnegqS8(int8x16_t* r, int8x16_t* v0) { *r = vqnegq_s8(*v0); }
void VqnegqS32(int32x4_t* r, int32x4_t* v0) { *r = vqnegq_s32(*v0); }
void VqnegqS16(int16x8_t* r, int16x8_t* v0) { *r = vqnegq_s16(*v0); }
void VqnegS8(int8x8_t* r, int8x8_t* v0) { *r = vqneg_s8(*v0); }
void VqnegS32(int32x2_t* r, int32x2_t* v0) { *r = vqneg_s32(*v0); }
void VqnegS16(int16x4_t* r, int16x4_t* v0) { *r = vqneg_s16(*v0); }
void VqrdmulhqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vqrdmulhq_s32(*v0, *v1); }
void VqrdmulhqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vqrdmulhq_s16(*v0, *v1); }
void VqrdmulhS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vqrdmulh_s32(*v0, *v1); }
void VqrdmulhS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vqrdmulh_s16(*v0, *v1); }
void VqrdmulhqNS32(int32x4_t* r, int32x4_t* v0, int32_t* v1) { *r = vqrdmulhq_n_s32(*v0, *v1); }
void VqrdmulhqNS16(int16x8_t* r, int16x8_t* v0, int16_t* v1) { *r = vqrdmulhq_n_s16(*v0, *v1); }
void VqrdmulhNS32(int32x2_t* r, int32x2_t* v0, int32_t* v1) { *r = vqrdmulh_n_s32(*v0, *v1); }
void VqrdmulhNS16(int16x4_t* r, int16x4_t* v0, int16_t* v1) { *r = vqrdmulh_n_s16(*v0, *v1); }
void VqrshlqU8(uint8x16_t* r, uint8x16_t* v0, int8x16_t* v1) { *r = vqrshlq_u8(*v0, *v1); }
void VqrshlqU32(uint32x4_t* r, uint32x4_t* v0, int32x4_t* v1) { *r = vqrshlq_u32(*v0, *v1); }
void VqrshlqU64(uint64x2_t* r, uint64x2_t* v0, int64x2_t* v1) { *r = vqrshlq_u64(*v0, *v1); }
void VqrshlqU16(uint16x8_t* r, uint16x8_t* v0, int16x8_t* v1) { *r = vqrshlq_u16(*v0, *v1); }
void VqrshlqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vqrshlq_s8(*v0, *v1); }
void VqrshlqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vqrshlq_s32(*v0, *v1); }
void VqrshlqS64(int64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vqrshlq_s64(*v0, *v1); }
void VqrshlqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vqrshlq_s16(*v0, *v1); }
void VqrshlU8(uint8x8_t* r, uint8x8_t* v0, int8x8_t* v1) { *r = vqrshl_u8(*v0, *v1); }
void VqrshlU32(uint32x2_t* r, uint32x2_t* v0, int32x2_t* v1) { *r = vqrshl_u32(*v0, *v1); }
void VqrshlU64(uint64x1_t* r, uint64x1_t* v0, int64x1_t* v1) { *r = vqrshl_u64(*v0, *v1); }
void VqrshlU16(uint16x4_t* r, uint16x4_t* v0, int16x4_t* v1) { *r = vqrshl_u16(*v0, *v1); }
void VqrshlS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vqrshl_s8(*v0, *v1); }
void VqrshlS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vqrshl_s32(*v0, *v1); }
void VqrshlS64(int64x1_t* r, int64x1_t* v0, int64x1_t* v1) { *r = vqrshl_s64(*v0, *v1); }
void VqrshlS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vqrshl_s16(*v0, *v1); }
void VqshlqU8(uint8x16_t* r, uint8x16_t* v0, int8x16_t* v1) { *r = vqshlq_u8(*v0, *v1); }
void VqshlqU32(uint32x4_t* r, uint32x4_t* v0, int32x4_t* v1) { *r = vqshlq_u32(*v0, *v1); }
void VqshlqU64(uint64x2_t* r, uint64x2_t* v0, int64x2_t* v1) { *r = vqshlq_u64(*v0, *v1); }
void VqshlqU16(uint16x8_t* r, uint16x8_t* v0, int16x8_t* v1) { *r = vqshlq_u16(*v0, *v1); }
void VqshlqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vqshlq_s8(*v0, *v1); }
void VqshlqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vqshlq_s32(*v0, *v1); }
void VqshlqS64(int64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vqshlq_s64(*v0, *v1); }
void VqshlqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vqshlq_s16(*v0, *v1); }
void VqshlU8(uint8x8_t* r, uint8x8_t* v0, int8x8_t* v1) { *r = vqshl_u8(*v0, *v1); }
void VqshlU32(uint32x2_t* r, uint32x2_t* v0, int32x2_t* v1) { *r = vqshl_u32(*v0, *v1); }
void VqshlU64(uint64x1_t* r, uint64x1_t* v0, int64x1_t* v1) { *r = vqshl_u64(*v0, *v1); }
void VqshlU16(uint16x4_t* r, uint16x4_t* v0, int16x4_t* v1) { *r = vqshl_u16(*v0, *v1); }
void VqshlS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vqshl_s8(*v0, *v1); }
void VqshlS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vqshl_s32(*v0, *v1); }
void VqshlS64(int64x1_t* r, int64x1_t* v0, int64x1_t* v1) { *r = vqshl_s64(*v0, *v1); }
void VqshlS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vqshl_s16(*v0, *v1); }
void VqsubqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vqsubq_u8(*v0, *v1); }
void VqsubqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vqsubq_u32(*v0, *v1); }
void VqsubqU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vqsubq_u64(*v0, *v1); }
void VqsubqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vqsubq_u16(*v0, *v1); }
void VqsubqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vqsubq_s8(*v0, *v1); }
void VqsubqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vqsubq_s32(*v0, *v1); }
void VqsubqS64(int64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vqsubq_s64(*v0, *v1); }
void VqsubqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vqsubq_s16(*v0, *v1); }
void VqsubU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vqsub_u8(*v0, *v1); }
void VqsubU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vqsub_u32(*v0, *v1); }
void VqsubU64(uint64x1_t* r, uint64x1_t* v0, uint64x1_t* v1) { *r = vqsub_u64(*v0, *v1); }
void VqsubU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vqsub_u16(*v0, *v1); }
void VqsubS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vqsub_s8(*v0, *v1); }
void VqsubS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vqsub_s32(*v0, *v1); }
void VqsubS64(int64x1_t* r, int64x1_t* v0, int64x1_t* v1) { *r = vqsub_s64(*v0, *v1); }
void VqsubS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vqsub_s16(*v0, *v1); }
void VraddhnU32(uint16x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vraddhn_u32(*v0, *v1); }
void VraddhnU64(uint32x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vraddhn_u64(*v0, *v1); }
void VraddhnU16(uint8x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vraddhn_u16(*v0, *v1); }
void VraddhnS32(int16x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vraddhn_s32(*v0, *v1); }
void VraddhnS64(int32x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vraddhn_s64(*v0, *v1); }
void VraddhnS16(int8x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vraddhn_s16(*v0, *v1); }
void VrecpeqU32(uint32x4_t* r, uint32x4_t* v0) { *r = vrecpeq_u32(*v0); }
void VrecpeqF32(float32x4_t* r, float32x4_t* v0) { *r = vrecpeq_f32(*v0); }
void VrecpeU32(uint32x2_t* r, uint32x2_t* v0) { *r = vrecpe_u32(*v0); }
void VrecpeF32(float32x2_t* r, float32x2_t* v0) { *r = vrecpe_f32(*v0); }
void VrecpsqF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vrecpsq_f32(*v0, *v1); }
void VrecpsF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vrecps_f32(*v0, *v1); }
void Vrev16P8(poly8x8_t* r, poly8x8_t* v0) { *r = vrev16_p8(*v0); }
void Vrev16QP8(poly8x16_t* r, poly8x16_t* v0) { *r = vrev16q_p8(*v0); }
void Vrev16QU8(uint8x16_t* r, uint8x16_t* v0) { *r = vrev16q_u8(*v0); }
void Vrev16QS8(int8x16_t* r, int8x16_t* v0) { *r = vrev16q_s8(*v0); }
void Vrev16U8(uint8x8_t* r, uint8x8_t* v0) { *r = vrev16_u8(*v0); }
void Vrev16S8(int8x8_t* r, int8x8_t* v0) { *r = vrev16_s8(*v0); }
void Vrev32P8(poly8x8_t* r, poly8x8_t* v0) { *r = vrev32_p8(*v0); }
void Vrev32P16(poly16x4_t* r, poly16x4_t* v0) { *r = vrev32_p16(*v0); }
void Vrev32QP8(poly8x16_t* r, poly8x16_t* v0) { *r = vrev32q_p8(*v0); }
void Vrev32QP16(poly16x8_t* r, poly16x8_t* v0) { *r = vrev32q_p16(*v0); }
void Vrev32QU8(uint8x16_t* r, uint8x16_t* v0) { *r = vrev32q_u8(*v0); }
void Vrev32QU16(uint16x8_t* r, uint16x8_t* v0) { *r = vrev32q_u16(*v0); }
void Vrev32QS8(int8x16_t* r, int8x16_t* v0) { *r = vrev32q_s8(*v0); }
void Vrev32QS16(int16x8_t* r, int16x8_t* v0) { *r = vrev32q_s16(*v0); }
void Vrev32U8(uint8x8_t* r, uint8x8_t* v0) { *r = vrev32_u8(*v0); }
void Vrev32U16(uint16x4_t* r, uint16x4_t* v0) { *r = vrev32_u16(*v0); }
void Vrev32S8(int8x8_t* r, int8x8_t* v0) { *r = vrev32_s8(*v0); }
void Vrev32S16(int16x4_t* r, int16x4_t* v0) { *r = vrev32_s16(*v0); }
void Vrev64P8(poly8x8_t* r, poly8x8_t* v0) { *r = vrev64_p8(*v0); }
void Vrev64P16(poly16x4_t* r, poly16x4_t* v0) { *r = vrev64_p16(*v0); }
void Vrev64QP8(poly8x16_t* r, poly8x16_t* v0) { *r = vrev64q_p8(*v0); }
void Vrev64QP16(poly16x8_t* r, poly16x8_t* v0) { *r = vrev64q_p16(*v0); }
void Vrev64QU8(uint8x16_t* r, uint8x16_t* v0) { *r = vrev64q_u8(*v0); }
void Vrev64QU32(uint32x4_t* r, uint32x4_t* v0) { *r = vrev64q_u32(*v0); }
void Vrev64QU16(uint16x8_t* r, uint16x8_t* v0) { *r = vrev64q_u16(*v0); }
void Vrev64QS8(int8x16_t* r, int8x16_t* v0) { *r = vrev64q_s8(*v0); }
void Vrev64QF32(float32x4_t* r, float32x4_t* v0) { *r = vrev64q_f32(*v0); }
void Vrev64QS32(int32x4_t* r, int32x4_t* v0) { *r = vrev64q_s32(*v0); }
void Vrev64QS16(int16x8_t* r, int16x8_t* v0) { *r = vrev64q_s16(*v0); }
void Vrev64U8(uint8x8_t* r, uint8x8_t* v0) { *r = vrev64_u8(*v0); }
void Vrev64U32(uint32x2_t* r, uint32x2_t* v0) { *r = vrev64_u32(*v0); }
void Vrev64U16(uint16x4_t* r, uint16x4_t* v0) { *r = vrev64_u16(*v0); }
void Vrev64S8(int8x8_t* r, int8x8_t* v0) { *r = vrev64_s8(*v0); }
void Vrev64F32(float32x2_t* r, float32x2_t* v0) { *r = vrev64_f32(*v0); }
void Vrev64S32(int32x2_t* r, int32x2_t* v0) { *r = vrev64_s32(*v0); }
void Vrev64S16(int16x4_t* r, int16x4_t* v0) { *r = vrev64_s16(*v0); }
void VrhaddqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vrhaddq_u8(*v0, *v1); }
void VrhaddqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vrhaddq_u32(*v0, *v1); }
void VrhaddqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vrhaddq_u16(*v0, *v1); }
void VrhaddqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vrhaddq_s8(*v0, *v1); }
void VrhaddqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vrhaddq_s32(*v0, *v1); }
void VrhaddqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vrhaddq_s16(*v0, *v1); }
void VrhaddU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vrhadd_u8(*v0, *v1); }
void VrhaddU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vrhadd_u32(*v0, *v1); }
void VrhaddU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vrhadd_u16(*v0, *v1); }
void VrhaddS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vrhadd_s8(*v0, *v1); }
void VrhaddS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vrhadd_s32(*v0, *v1); }
void VrhaddS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vrhadd_s16(*v0, *v1); }
void VrshlqU8(uint8x16_t* r, uint8x16_t* v0, int8x16_t* v1) { *r = vrshlq_u8(*v0, *v1); }
void VrshlqU32(uint32x4_t* r, uint32x4_t* v0, int32x4_t* v1) { *r = vrshlq_u32(*v0, *v1); }
void VrshlqU64(uint64x2_t* r, uint64x2_t* v0, int64x2_t* v1) { *r = vrshlq_u64(*v0, *v1); }
void VrshlqU16(uint16x8_t* r, uint16x8_t* v0, int16x8_t* v1) { *r = vrshlq_u16(*v0, *v1); }
void VrshlqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vrshlq_s8(*v0, *v1); }
void VrshlqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vrshlq_s32(*v0, *v1); }
void VrshlqS64(int64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vrshlq_s64(*v0, *v1); }
void VrshlqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vrshlq_s16(*v0, *v1); }
void VrshlU8(uint8x8_t* r, uint8x8_t* v0, int8x8_t* v1) { *r = vrshl_u8(*v0, *v1); }
void VrshlU32(uint32x2_t* r, uint32x2_t* v0, int32x2_t* v1) { *r = vrshl_u32(*v0, *v1); }
void VrshlU64(uint64x1_t* r, uint64x1_t* v0, int64x1_t* v1) { *r = vrshl_u64(*v0, *v1); }
void VrshlU16(uint16x4_t* r, uint16x4_t* v0, int16x4_t* v1) { *r = vrshl_u16(*v0, *v1); }
void VrshlS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vrshl_s8(*v0, *v1); }
void VrshlS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vrshl_s32(*v0, *v1); }
void VrshlS64(int64x1_t* r, int64x1_t* v0, int64x1_t* v1) { *r = vrshl_s64(*v0, *v1); }
void VrshlS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vrshl_s16(*v0, *v1); }
void VrsqrteqU32(uint32x4_t* r, uint32x4_t* v0) { *r = vrsqrteq_u32(*v0); }
void VrsqrteqF32(float32x4_t* r, float32x4_t* v0) { *r = vrsqrteq_f32(*v0); }
void VrsqrteU32(uint32x2_t* r, uint32x2_t* v0) { *r = vrsqrte_u32(*v0); }
void VrsqrteF32(float32x2_t* r, float32x2_t* v0) { *r = vrsqrte_f32(*v0); }
void VrsqrtsqF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vrsqrtsq_f32(*v0, *v1); }
void VrsqrtsF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vrsqrts_f32(*v0, *v1); }
void VrsubhnU32(uint16x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vrsubhn_u32(*v0, *v1); }
void VrsubhnU64(uint32x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vrsubhn_u64(*v0, *v1); }
void VrsubhnU16(uint8x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vrsubhn_u16(*v0, *v1); }
void VrsubhnS32(int16x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vrsubhn_s32(*v0, *v1); }
void VrsubhnS64(int32x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vrsubhn_s64(*v0, *v1); }
void VrsubhnS16(int8x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vrsubhn_s16(*v0, *v1); }
void VshlqU8(uint8x16_t* r, uint8x16_t* v0, int8x16_t* v1) { *r = vshlq_u8(*v0, *v1); }
void VshlqU32(uint32x4_t* r, uint32x4_t* v0, int32x4_t* v1) { *r = vshlq_u32(*v0, *v1); }
void VshlqU64(uint64x2_t* r, uint64x2_t* v0, int64x2_t* v1) { *r = vshlq_u64(*v0, *v1); }
void VshlqU16(uint16x8_t* r, uint16x8_t* v0, int16x8_t* v1) { *r = vshlq_u16(*v0, *v1); }
void VshlqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vshlq_s8(*v0, *v1); }
void VshlqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vshlq_s32(*v0, *v1); }
void VshlqS64(int64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vshlq_s64(*v0, *v1); }
void VshlqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vshlq_s16(*v0, *v1); }
void VshlU8(uint8x8_t* r, uint8x8_t* v0, int8x8_t* v1) { *r = vshl_u8(*v0, *v1); }
void VshlU32(uint32x2_t* r, uint32x2_t* v0, int32x2_t* v1) { *r = vshl_u32(*v0, *v1); }
void VshlU64(uint64x1_t* r, uint64x1_t* v0, int64x1_t* v1) { *r = vshl_u64(*v0, *v1); }
void VshlU16(uint16x4_t* r, uint16x4_t* v0, int16x4_t* v1) { *r = vshl_u16(*v0, *v1); }
void VshlS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vshl_s8(*v0, *v1); }
void VshlS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vshl_s32(*v0, *v1); }
void VshlS64(int64x1_t* r, int64x1_t* v0, int64x1_t* v1) { *r = vshl_s64(*v0, *v1); }
void VshlS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vshl_s16(*v0, *v1); }
void VsubqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vsubq_u8(*v0, *v1); }
void VsubqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vsubq_u32(*v0, *v1); }
void VsubqU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vsubq_u64(*v0, *v1); }
void VsubqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vsubq_u16(*v0, *v1); }
void VsubqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vsubq_s8(*v0, *v1); }
void VsubqF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vsubq_f32(*v0, *v1); }
void VsubqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vsubq_s32(*v0, *v1); }
void VsubqS64(int64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vsubq_s64(*v0, *v1); }
void VsubqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vsubq_s16(*v0, *v1); }
void VsubU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vsub_u8(*v0, *v1); }
void VsubU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vsub_u32(*v0, *v1); }
void VsubU64(uint64x1_t* r, uint64x1_t* v0, uint64x1_t* v1) { *r = vsub_u64(*v0, *v1); }
void VsubU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vsub_u16(*v0, *v1); }
void VsubS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vsub_s8(*v0, *v1); }
void VsubF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vsub_f32(*v0, *v1); }
void VsubS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vsub_s32(*v0, *v1); }
void VsubS64(int64x1_t* r, int64x1_t* v0, int64x1_t* v1) { *r = vsub_s64(*v0, *v1); }
void VsubS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vsub_s16(*v0, *v1); }
void VsubhnU32(uint16x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vsubhn_u32(*v0, *v1); }
void VsubhnU64(uint32x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vsubhn_u64(*v0, *v1); }
void VsubhnU16(uint8x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vsubhn_u16(*v0, *v1); }
void VsubhnS32(int16x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vsubhn_s32(*v0, *v1); }
void VsubhnS64(int32x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vsubhn_s64(*v0, *v1); }
void VsubhnS16(int8x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vsubhn_s16(*v0, *v1); }
void VsublU8(uint16x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vsubl_u8(*v0, *v1); }
void VsublU32(uint64x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vsubl_u32(*v0, *v1); }
void VsublU16(uint32x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vsubl_u16(*v0, *v1); }
void VsublS8(int16x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vsubl_s8(*v0, *v1); }
void VsublS32(int64x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vsubl_s32(*v0, *v1); }
void VsublS16(int32x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vsubl_s16(*v0, *v1); }
void VsubwU8(uint16x8_t* r, uint16x8_t* v0, uint8x8_t* v1) { *r = vsubw_u8(*v0, *v1); }
void VsubwU32(uint64x2_t* r, uint64x2_t* v0, uint32x2_t* v1) { *r = vsubw_u32(*v0, *v1); }
void VsubwU16(uint32x4_t* r, uint32x4_t* v0, uint16x4_t* v1) { *r = vsubw_u16(*v0, *v1); }
void VsubwS8(int16x8_t* r, int16x8_t* v0, int8x8_t* v1) { *r = vsubw_s8(*v0, *v1); }
void VsubwS32(int64x2_t* r, int64x2_t* v0, int32x2_t* v1) { *r = vsubw_s32(*v0, *v1); }
void VsubwS16(int32x4_t* r, int32x4_t* v0, int16x4_t* v1) { *r = vsubw_s16(*v0, *v1); }
void Vtbl1P8(poly8x8_t* r, poly8x8_t* v0, uint8x8_t* v1) { *r = vtbl1_p8(*v0, *v1); }
void Vtbl1U8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vtbl1_u8(*v0, *v1); }
void Vtbl1S8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vtbl1_s8(*v0, *v1); }
void Vtbl2P8(poly8x8_t* r, poly8x8x2_t* v0, uint8x8_t* v1) { *r = vtbl2_p8(*v0, *v1); }
void Vtbl2U8(uint8x8_t* r, uint8x8x2_t* v0, uint8x8_t* v1) { *r = vtbl2_u8(*v0, *v1); }
void Vtbl2S8(int8x8_t* r, int8x8x2_t* v0, int8x8_t* v1) { *r = vtbl2_s8(*v0, *v1); }
void Vtbl3P8(poly8x8_t* r, poly8x8x3_t* v0, uint8x8_t* v1) { *r = vtbl3_p8(*v0, *v1); }
void Vtbl3U8(uint8x8_t* r, uint8x8x3_t* v0, uint8x8_t* v1) { *r = vtbl3_u8(*v0, *v1); }
void Vtbl3S8(int8x8_t* r, int8x8x3_t* v0, int8x8_t* v1) { *r = vtbl3_s8(*v0, *v1); }
void Vtbl4P8(poly8x8_t* r, poly8x8x4_t* v0, uint8x8_t* v1) { *r = vtbl4_p8(*v0, *v1); }
void Vtbl4U8(uint8x8_t* r, uint8x8x4_t* v0, uint8x8_t* v1) { *r = vtbl4_u8(*v0, *v1); }
void Vtbl4S8(int8x8_t* r, int8x8x4_t* v0, int8x8_t* v1) { *r = vtbl4_s8(*v0, *v1); }
void Vtbx1P8(poly8x8_t* r, poly8x8_t* v0, poly8x8_t* v1, uint8x8_t* v2) { *r = vtbx1_p8(*v0, *v1, *v2); }
void Vtbx1U8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1, uint8x8_t* v2) { *r = vtbx1_u8(*v0, *v1, *v2); }
void Vtbx1S8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1, int8x8_t* v2) { *r = vtbx1_s8(*v0, *v1, *v2); }
void Vtbx2P8(poly8x8_t* r, poly8x8_t* v0, poly8x8x2_t* v1, uint8x8_t* v2) { *r = vtbx2_p8(*v0, *v1, *v2); }
void Vtbx2U8(uint8x8_t* r, uint8x8_t* v0, uint8x8x2_t* v1, uint8x8_t* v2) { *r = vtbx2_u8(*v0, *v1, *v2); }
void Vtbx2S8(int8x8_t* r, int8x8_t* v0, int8x8x2_t* v1, int8x8_t* v2) { *r = vtbx2_s8(*v0, *v1, *v2); }
void Vtbx3P8(poly8x8_t* r, poly8x8_t* v0, poly8x8x3_t* v1, uint8x8_t* v2) { *r = vtbx3_p8(*v0, *v1, *v2); }
void Vtbx3U8(uint8x8_t* r, uint8x8_t* v0, uint8x8x3_t* v1, uint8x8_t* v2) { *r = vtbx3_u8(*v0, *v1, *v2); }
void Vtbx3S8(int8x8_t* r, int8x8_t* v0, int8x8x3_t* v1, int8x8_t* v2) { *r = vtbx3_s8(*v0, *v1, *v2); }
void Vtbx4P8(poly8x8_t* r, poly8x8_t* v0, poly8x8x4_t* v1, uint8x8_t* v2) { *r = vtbx4_p8(*v0, *v1, *v2); }
void Vtbx4U8(uint8x8_t* r, uint8x8_t* v0, uint8x8x4_t* v1, uint8x8_t* v2) { *r = vtbx4_u8(*v0, *v1, *v2); }
void Vtbx4S8(int8x8_t* r, int8x8_t* v0, int8x8x4_t* v1, int8x8_t* v2) { *r = vtbx4_s8(*v0, *v1, *v2); }
void VtrnP8(poly8x8x2_t* r, poly8x8_t* v0, poly8x8_t* v1) { *r = vtrn_p8(*v0, *v1); }
void VtrnP16(poly16x4x2_t* r, poly16x4_t* v0, poly16x4_t* v1) { *r = vtrn_p16(*v0, *v1); }
void VtrnqP8(poly8x16x2_t* r, poly8x16_t* v0, poly8x16_t* v1) { *r = vtrnq_p8(*v0, *v1); }
void VtrnqP16(poly16x8x2_t* r, poly16x8_t* v0, poly16x8_t* v1) { *r = vtrnq_p16(*v0, *v1); }
void VtrnqU8(uint8x16x2_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vtrnq_u8(*v0, *v1); }
void VtrnqU32(uint32x4x2_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vtrnq_u32(*v0, *v1); }
void VtrnqU16(uint16x8x2_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vtrnq_u16(*v0, *v1); }
void VtrnqS8(int8x16x2_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vtrnq_s8(*v0, *v1); }
void VtrnqF32(float32x4x2_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vtrnq_f32(*v0, *v1); }
void VtrnqS32(int32x4x2_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vtrnq_s32(*v0, *v1); }
void VtrnqS16(int16x8x2_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vtrnq_s16(*v0, *v1); }
void VtrnU8(uint8x8x2_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vtrn_u8(*v0, *v1); }
void VtrnU32(uint32x2x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vtrn_u32(*v0, *v1); }
void VtrnU16(uint16x4x2_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vtrn_u16(*v0, *v1); }
void VtrnS8(int8x8x2_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vtrn_s8(*v0, *v1); }
void VtrnF32(float32x2x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vtrn_f32(*v0, *v1); }
void VtrnS32(int32x2x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vtrn_s32(*v0, *v1); }
void VtrnS16(int16x4x2_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vtrn_s16(*v0, *v1); }
void VtstP8(uint8x8_t* r, poly8x8_t* v0, poly8x8_t* v1) { *r = vtst_p8(*v0, *v1); }
void VtstP16(uint16x4_t* r, poly16x4_t* v0, poly16x4_t* v1) { *r = vtst_p16(*v0, *v1); }
void VtstqP8(uint8x16_t* r, poly8x16_t* v0, poly8x16_t* v1) { *r = vtstq_p8(*v0, *v1); }
void VtstqP16(uint16x8_t* r, poly16x8_t* v0, poly16x8_t* v1) { *r = vtstq_p16(*v0, *v1); }
void VtstqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vtstq_u8(*v0, *v1); }
void VtstqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vtstq_u32(*v0, *v1); }
void VtstqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vtstq_u16(*v0, *v1); }
void VtstqS8(uint8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vtstq_s8(*v0, *v1); }
void VtstqS32(uint32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vtstq_s32(*v0, *v1); }
void VtstqS16(uint16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vtstq_s16(*v0, *v1); }
void VtstU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vtst_u8(*v0, *v1); }
void VtstU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vtst_u32(*v0, *v1); }
void VtstU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vtst_u16(*v0, *v1); }
void VtstS8(uint8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vtst_s8(*v0, *v1); }
void VtstS32(uint32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vtst_s32(*v0, *v1); }
void VtstS16(uint16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vtst_s16(*v0, *v1); }
void VuzpP8(poly8x8x2_t* r, poly8x8_t* v0, poly8x8_t* v1) { *r = vuzp_p8(*v0, *v1); }
void VuzpP16(poly16x4x2_t* r, poly16x4_t* v0, poly16x4_t* v1) { *r = vuzp_p16(*v0, *v1); }
void VuzpqP8(poly8x16x2_t* r, poly8x16_t* v0, poly8x16_t* v1) { *r = vuzpq_p8(*v0, *v1); }
void VuzpqP16(poly16x8x2_t* r, poly16x8_t* v0, poly16x8_t* v1) { *r = vuzpq_p16(*v0, *v1); }
void VuzpqU8(uint8x16x2_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vuzpq_u8(*v0, *v1); }
void VuzpqU32(uint32x4x2_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vuzpq_u32(*v0, *v1); }
void VuzpqU16(uint16x8x2_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vuzpq_u16(*v0, *v1); }
void VuzpqS8(int8x16x2_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vuzpq_s8(*v0, *v1); }
void VuzpqF32(float32x4x2_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vuzpq_f32(*v0, *v1); }
void VuzpqS32(int32x4x2_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vuzpq_s32(*v0, *v1); }
void VuzpqS16(int16x8x2_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vuzpq_s16(*v0, *v1); }
void VuzpU8(uint8x8x2_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vuzp_u8(*v0, *v1); }
void VuzpU32(uint32x2x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vuzp_u32(*v0, *v1); }
void VuzpU16(uint16x4x2_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vuzp_u16(*v0, *v1); }
void VuzpS8(int8x8x2_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vuzp_s8(*v0, *v1); }
void VuzpF32(float32x2x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vuzp_f32(*v0, *v1); }
void VuzpS32(int32x2x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vuzp_s32(*v0, *v1); }
void VuzpS16(int16x4x2_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vuzp_s16(*v0, *v1); }
void VzipP8(poly8x8x2_t* r, poly8x8_t* v0, poly8x8_t* v1) { *r = vzip_p8(*v0, *v1); }
void VzipP16(poly16x4x2_t* r, poly16x4_t* v0, poly16x4_t* v1) { *r = vzip_p16(*v0, *v1); }
void VzipqP8(poly8x16x2_t* r, poly8x16_t* v0, poly8x16_t* v1) { *r = vzipq_p8(*v0, *v1); }
void VzipqP16(poly16x8x2_t* r, poly16x8_t* v0, poly16x8_t* v1) { *r = vzipq_p16(*v0, *v1); }
void VzipqU8(uint8x16x2_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vzipq_u8(*v0, *v1); }
void VzipqU32(uint32x4x2_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vzipq_u32(*v0, *v1); }
void VzipqU16(uint16x8x2_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vzipq_u16(*v0, *v1); }
void VzipqS8(int8x16x2_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vzipq_s8(*v0, *v1); }
void VzipqF32(float32x4x2_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vzipq_f32(*v0, *v1); }
void VzipqS32(int32x4x2_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vzipq_s32(*v0, *v1); }
void VzipqS16(int16x8x2_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vzipq_s16(*v0, *v1); }
void VzipU8(uint8x8x2_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vzip_u8(*v0, *v1); }
void VzipU32(uint32x2x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vzip_u32(*v0, *v1); }
void VzipU16(uint16x4x2_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vzip_u16(*v0, *v1); }
void VzipS8(int8x8x2_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vzip_s8(*v0, *v1); }
void VzipF32(float32x2x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vzip_f32(*v0, *v1); }
void VzipS32(int32x2x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vzip_s32(*v0, *v1); }
void VzipS16(int16x4x2_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vzip_s16(*v0, *v1); }
void VcvtaqS32F32(int32x4_t* r, float32x4_t* v0) { *r = vcvtaq_s32_f32(*v0); }
void VcvtaS32F32(int32x2_t* r, float32x2_t* v0) { *r = vcvta_s32_f32(*v0); }
void VcvtaqU32F32(uint32x4_t* r, float32x4_t* v0) { *r = vcvtaq_u32_f32(*v0); }
void VcvtaU32F32(uint32x2_t* r, float32x2_t* v0) { *r = vcvta_u32_f32(*v0); }
void VcvtmqS32F32(int32x4_t* r, float32x4_t* v0) { *r = vcvtmq_s32_f32(*v0); }
void VcvtmS32F32(int32x2_t* r, float32x2_t* v0) { *r = vcvtm_s32_f32(*v0); }
void VcvtmqU32F32(uint32x4_t* r, float32x4_t* v0) { *r = vcvtmq_u32_f32(*v0); }
void VcvtmU32F32(uint32x2_t* r, float32x2_t* v0) { *r = vcvtm_u32_f32(*v0); }
void VcvtnqS32F32(int32x4_t* r, float32x4_t* v0) { *r = vcvtnq_s32_f32(*v0); }
void VcvtnS32F32(int32x2_t* r, float32x2_t* v0) { *r = vcvtn_s32_f32(*v0); }
void VcvtnqU32F32(uint32x4_t* r, float32x4_t* v0) { *r = vcvtnq_u32_f32(*v0); }
void VcvtnU32F32(uint32x2_t* r, float32x2_t* v0) { *r = vcvtn_u32_f32(*v0); }
void VcvtpqS32F32(int32x4_t* r, float32x4_t* v0) { *r = vcvtpq_s32_f32(*v0); }
void VcvtpS32F32(int32x2_t* r, float32x2_t* v0) { *r = vcvtp_s32_f32(*v0); }
void VcvtpqU32F32(uint32x4_t* r, float32x4_t* v0) { *r = vcvtpq_u32_f32(*v0); }
void VcvtpU32F32(uint32x2_t* r, float32x2_t* v0) { *r = vcvtp_u32_f32(*v0); }
void VaesdqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vaesdq_u8(*v0, *v1); }
void VaeseqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vaeseq_u8(*v0, *v1); }
void VaesimcqU8(uint8x16_t* r, uint8x16_t* v0) { *r = vaesimcq_u8(*v0); }
void VaesmcqU8(uint8x16_t* r, uint8x16_t* v0) { *r = vaesmcq_u8(*v0); }
void VrndqF32(float32x4_t* r, float32x4_t* v0) { *r = vrndq_f32(*v0); }
void VrndF32(float32x2_t* r, float32x2_t* v0) { *r = vrnd_f32(*v0); }
void VrndaqF32(float32x4_t* r, float32x4_t* v0) { *r = vrndaq_f32(*v0); }
void VrndaF32(float32x2_t* r, float32x2_t* v0) { *r = vrnda_f32(*v0); }
void VrndiqF32(float32x4_t* r, float32x4_t* v0) { *r = vrndiq_f32(*v0); }
void VrndiF32(float32x2_t* r, float32x2_t* v0) { *r = vrndi_f32(*v0); }
void VrndmqF32(float32x4_t* r, float32x4_t* v0) { *r = vrndmq_f32(*v0); }
void VrndmF32(float32x2_t* r, float32x2_t* v0) { *r = vrndm_f32(*v0); }
void VrndnqF32(float32x4_t* r, float32x4_t* v0) { *r = vrndnq_f32(*v0); }
void VrndnF32(float32x2_t* r, float32x2_t* v0) { *r = vrndn_f32(*v0); }
void VrndnsF32(float32_t* r, float32_t* v0) { *r = vrndns_f32(*v0); }
void VrndpqF32(float32x4_t* r, float32x4_t* v0) { *r = vrndpq_f32(*v0); }
void VrndpF32(float32x2_t* r, float32x2_t* v0) { *r = vrndp_f32(*v0); }
void VrndxqF32(float32x4_t* r, float32x4_t* v0) { *r = vrndxq_f32(*v0); }
void VrndxF32(float32x2_t* r, float32x2_t* v0) { *r = vrndx_f32(*v0); }
void VmaxnmqF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vmaxnmq_f32(*v0, *v1); }
void VmaxnmF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vmaxnm_f32(*v0, *v1); }
void VminnmqF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vminnmq_f32(*v0, *v1); }
void VminnmF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vminnm_f32(*v0, *v1); }
void Vsha1CqU32(uint32x4_t* r, uint32x4_t* v0, uint32_t* v1, uint32x4_t* v2) { *r = vsha1cq_u32(*v0, *v1, *v2); }
void Vsha1HU32(uint32_t* r, uint32_t* v0) { *r = vsha1h_u32(*v0); }
void Vsha1MqU32(uint32x4_t* r, uint32x4_t* v0, uint32_t* v1, uint32x4_t* v2) { *r = vsha1mq_u32(*v0, *v1, *v2); }
void Vsha1PqU32(uint32x4_t* r, uint32x4_t* v0, uint32_t* v1, uint32x4_t* v2) { *r = vsha1pq_u32(*v0, *v1, *v2); }
void Vsha1Su0QU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1, uint32x4_t* v2) { *r = vsha1su0q_u32(*v0, *v1, *v2); }
void Vsha1Su1QU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vsha1su1q_u32(*v0, *v1); }
void Vsha256HqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1, uint32x4_t* v2) { *r = vsha256hq_u32(*v0, *v1, *v2); }
void Vsha256H2QU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1, uint32x4_t* v2) { *r = vsha256h2q_u32(*v0, *v1, *v2); }
void Vsha256Su0QU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vsha256su0q_u32(*v0, *v1); }
void Vsha256Su1QU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1, uint32x4_t* v2) { *r = vsha256su1q_u32(*v0, *v1, *v2); }
void VbcaxqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1, uint8x16_t* v2) { *r = vbcaxq_u8(*v0, *v1, *v2); }
void VbcaxqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1, uint32x4_t* v2) { *r = vbcaxq_u32(*v0, *v1, *v2); }
void VbcaxqU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1, uint64x2_t* v2) { *r = vbcaxq_u64(*v0, *v1, *v2); }
void VbcaxqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1, uint16x8_t* v2) { *r = vbcaxq_u16(*v0, *v1, *v2); }
void VbcaxqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1, int8x16_t* v2) { *r = vbcaxq_s8(*v0, *v1, *v2); }
void VbcaxqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1, int32x4_t* v2) { *r = vbcaxq_s32(*v0, *v1, *v2); }
void VbcaxqS64(int64x2_t* r, int64x2_t* v0, int64x2_t* v1, int64x2_t* v2) { *r = vbcaxq_s64(*v0, *v1, *v2); }
void VbcaxqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1, int16x8_t* v2) { *r = vbcaxq_s16(*v0, *v1, *v2); }
void Veor3QU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1, uint8x16_t* v2) { *r = veor3q_u8(*v0, *v1, *v2); }
void Veor3QU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1, uint32x4_t* v2) { *r = veor3q_u32(*v0, *v1, *v2); }
void Veor3QU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1, uint64x2_t* v2) { *r = veor3q_u64(*v0, *v1, *v2); }
void Veor3QU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1, uint16x8_t* v2) { *r = veor3q_u16(*v0, *v1, *v2); }
void Veor3QS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1, int8x16_t* v2) { *r = veor3q_s8(*v0, *v1, *v2); }
void Veor3QS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1, int32x4_t* v2) { *r = veor3q_s32(*v0, *v1, *v2); }
void Veor3QS64(int64x2_t* r, int64x2_t* v0, int64x2_t* v1, int64x2_t* v2) { *r = veor3q_s64(*v0, *v1, *v2); }
void Veor3QS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1, int16x8_t* v2) { *r = veor3q_s16(*v0, *v1, *v2); }
void Vrax1QU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vrax1q_u64(*v0, *v1); }
void Vsha512HqU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1, uint64x2_t* v2) { *r = vsha512hq_u64(*v0, *v1, *v2); }
void Vsha512H2QU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1, uint64x2_t* v2) { *r = vsha512h2q_u64(*v0, *v1, *v2); }
void Vsha512Su0QU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vsha512su0q_u64(*v0, *v1); }
void Vsha512Su1QU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1, uint64x2_t* v2) { *r = vsha512su1q_u64(*v0, *v1, *v2); }
void Vsm3Partw1QU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1, uint32x4_t* v2) { *r = vsm3partw1q_u32(*v0, *v1, *v2); }
void Vsm3Partw2QU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1, uint32x4_t* v2) { *r = vsm3partw2q_u32(*v0, *v1, *v2); }
void Vsm3Ss1QU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1, uint32x4_t* v2) { *r = vsm3ss1q_u32(*v0, *v1, *v2); }
void Vsm4EqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vsm4eq_u32(*v0, *v1); }
void Vsm4EkeyqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vsm4ekeyq_u32(*v0, *v1); }
void VcvtaqS64F64(int64x2_t* r, float64x2_t* v0) { *r = vcvtaq_s64_f64(*v0); }
void VcvtaS64F64(int64x1_t* r, float64x1_t* v0) { *r = vcvta_s64_f64(*v0); }
void VcvtaqU64F64(uint64x2_t* r, float64x2_t* v0) { *r = vcvtaq_u64_f64(*v0); }
void VcvtaU64F64(uint64x1_t* r, float64x1_t* v0) { *r = vcvta_u64_f64(*v0); }
void VcvtmqS64F64(int64x2_t* r, float64x2_t* v0) { *r = vcvtmq_s64_f64(*v0); }
void VcvtmS64F64(int64x1_t* r, float64x1_t* v0) { *r = vcvtm_s64_f64(*v0); }
void VcvtmqU64F64(uint64x2_t* r, float64x2_t* v0) { *r = vcvtmq_u64_f64(*v0); }
void VcvtmU64F64(uint64x1_t* r, float64x1_t* v0) { *r = vcvtm_u64_f64(*v0); }
void VcvtnqS64F64(int64x2_t* r, float64x2_t* v0) { *r = vcvtnq_s64_f64(*v0); }
void VcvtnS64F64(int64x1_t* r, float64x1_t* v0) { *r = vcvtn_s64_f64(*v0); }
void VcvtnqU64F64(uint64x2_t* r, float64x2_t* v0) { *r = vcvtnq_u64_f64(*v0); }
void VcvtnU64F64(uint64x1_t* r, float64x1_t* v0) { *r = vcvtn_u64_f64(*v0); }
void VcvtpqS64F64(int64x2_t* r, float64x2_t* v0) { *r = vcvtpq_s64_f64(*v0); }
void VcvtpS64F64(int64x1_t* r, float64x1_t* v0) { *r = vcvtp_s64_f64(*v0); }
void VcvtpqU64F64(uint64x2_t* r, float64x2_t* v0) { *r = vcvtpq_u64_f64(*v0); }
void VcvtpU64F64(uint64x1_t* r, float64x1_t* v0) { *r = vcvtp_u64_f64(*v0); }
void VreinterpretP8P64(poly8x8_t* r, poly64x1_t* v0) { *r = vreinterpret_p8_p64(*v0); }
void VreinterpretP8P16(poly8x8_t* r, poly16x4_t* v0) { *r = vreinterpret_p8_p16(*v0); }
void VreinterpretP8U8(poly8x8_t* r, uint8x8_t* v0) { *r = vreinterpret_p8_u8(*v0); }
void VreinterpretP8U32(poly8x8_t* r, uint32x2_t* v0) { *r = vreinterpret_p8_u32(*v0); }
void VreinterpretP8U64(poly8x8_t* r, uint64x1_t* v0) { *r = vreinterpret_p8_u64(*v0); }
void VreinterpretP8U16(poly8x8_t* r, uint16x4_t* v0) { *r = vreinterpret_p8_u16(*v0); }
void VreinterpretP8S8(poly8x8_t* r, int8x8_t* v0) { *r = vreinterpret_p8_s8(*v0); }
void VreinterpretP8F64(poly8x8_t* r, float64x1_t* v0) { *r = vreinterpret_p8_f64(*v0); }
void VreinterpretP8F32(poly8x8_t* r, float32x2_t* v0) { *r = vreinterpret_p8_f32(*v0); }
void VreinterpretP8S32(poly8x8_t* r, int32x2_t* v0) { *r = vreinterpret_p8_s32(*v0); }
void VreinterpretP8S64(poly8x8_t* r, int64x1_t* v0) { *r = vreinterpret_p8_s64(*v0); }
void VreinterpretP8S16(poly8x8_t* r, int16x4_t* v0) { *r = vreinterpret_p8_s16(*v0); }
void VreinterpretP64P8(poly64x1_t* r, poly8x8_t* v0) { *r = vreinterpret_p64_p8(*v0); }
void VreinterpretP64P16(poly64x1_t* r, poly16x4_t* v0) { *r = vreinterpret_p64_p16(*v0); }
void VreinterpretP64U8(poly64x1_t* r, uint8x8_t* v0) { *r = vreinterpret_p64_u8(*v0); }
void VreinterpretP64U32(poly64x1_t* r, uint32x2_t* v0) { *r = vreinterpret_p64_u32(*v0); }
void VreinterpretP64U64(poly64x1_t* r, uint64x1_t* v0) { *r = vreinterpret_p64_u64(*v0); }
void VreinterpretP64U16(poly64x1_t* r, uint16x4_t* v0) { *r = vreinterpret_p64_u16(*v0); }
void VreinterpretP64S8(poly64x1_t* r, int8x8_t* v0) { *r = vreinterpret_p64_s8(*v0); }
void VreinterpretP64F64(poly64x1_t* r, float64x1_t* v0) { *r = vreinterpret_p64_f64(*v0); }
void VreinterpretP64F32(poly64x1_t* r, float32x2_t* v0) { *r = vreinterpret_p64_f32(*v0); }
void VreinterpretP64S32(poly64x1_t* r, int32x2_t* v0) { *r = vreinterpret_p64_s32(*v0); }
void VreinterpretP64S64(poly64x1_t* r, int64x1_t* v0) { *r = vreinterpret_p64_s64(*v0); }
void VreinterpretP64S16(poly64x1_t* r, int16x4_t* v0) { *r = vreinterpret_p64_s16(*v0); }
void VreinterpretP16P8(poly16x4_t* r, poly8x8_t* v0) { *r = vreinterpret_p16_p8(*v0); }
void VreinterpretP16P64(poly16x4_t* r, poly64x1_t* v0) { *r = vreinterpret_p16_p64(*v0); }
void VreinterpretP16U8(poly16x4_t* r, uint8x8_t* v0) { *r = vreinterpret_p16_u8(*v0); }
void VreinterpretP16U32(poly16x4_t* r, uint32x2_t* v0) { *r = vreinterpret_p16_u32(*v0); }
void VreinterpretP16U64(poly16x4_t* r, uint64x1_t* v0) { *r = vreinterpret_p16_u64(*v0); }
void VreinterpretP16U16(poly16x4_t* r, uint16x4_t* v0) { *r = vreinterpret_p16_u16(*v0); }
void VreinterpretP16S8(poly16x4_t* r, int8x8_t* v0) { *r = vreinterpret_p16_s8(*v0); }
void VreinterpretP16F64(poly16x4_t* r, float64x1_t* v0) { *r = vreinterpret_p16_f64(*v0); }
void VreinterpretP16F32(poly16x4_t* r, float32x2_t* v0) { *r = vreinterpret_p16_f32(*v0); }
void VreinterpretP16S32(poly16x4_t* r, int32x2_t* v0) { *r = vreinterpret_p16_s32(*v0); }
void VreinterpretP16S64(poly16x4_t* r, int64x1_t* v0) { *r = vreinterpret_p16_s64(*v0); }
void VreinterpretP16S16(poly16x4_t* r, int16x4_t* v0) { *r = vreinterpret_p16_s16(*v0); }
void VreinterpretqP8P128(poly8x16_t* r, poly128_t* v0) { *r = vreinterpretq_p8_p128(*v0); }
void VreinterpretqP8P64(poly8x16_t* r, poly64x2_t* v0) { *r = vreinterpretq_p8_p64(*v0); }
void VreinterpretqP8P16(poly8x16_t* r, poly16x8_t* v0) { *r = vreinterpretq_p8_p16(*v0); }
void VreinterpretqP8U8(poly8x16_t* r, uint8x16_t* v0) { *r = vreinterpretq_p8_u8(*v0); }
void VreinterpretqP8U32(poly8x16_t* r, uint32x4_t* v0) { *r = vreinterpretq_p8_u32(*v0); }
void VreinterpretqP8U64(poly8x16_t* r, uint64x2_t* v0) { *r = vreinterpretq_p8_u64(*v0); }
void VreinterpretqP8U16(poly8x16_t* r, uint16x8_t* v0) { *r = vreinterpretq_p8_u16(*v0); }
void VreinterpretqP8S8(poly8x16_t* r, int8x16_t* v0) { *r = vreinterpretq_p8_s8(*v0); }
void VreinterpretqP8F64(poly8x16_t* r, float64x2_t* v0) { *r = vreinterpretq_p8_f64(*v0); }
void VreinterpretqP8F32(poly8x16_t* r, float32x4_t* v0) { *r = vreinterpretq_p8_f32(*v0); }
void VreinterpretqP8S32(poly8x16_t* r, int32x4_t* v0) { *r = vreinterpretq_p8_s32(*v0); }
void VreinterpretqP8S64(poly8x16_t* r, int64x2_t* v0) { *r = vreinterpretq_p8_s64(*v0); }
void VreinterpretqP8S16(poly8x16_t* r, int16x8_t* v0) { *r = vreinterpretq_p8_s16(*v0); }
void VreinterpretqP128P8(poly128_t* r, poly8x16_t* v0) { *r = vreinterpretq_p128_p8(*v0); }
void VreinterpretqP128P64(poly128_t* r, poly64x2_t* v0) { *r = vreinterpretq_p128_p64(*v0); }
void VreinterpretqP128P16(poly128_t* r, poly16x8_t* v0) { *r = vreinterpretq_p128_p16(*v0); }
void VreinterpretqP128U8(poly128_t* r, uint8x16_t* v0) { *r = vreinterpretq_p128_u8(*v0); }
void VreinterpretqP128U32(poly128_t* r, uint32x4_t* v0) { *r = vreinterpretq_p128_u32(*v0); }
void VreinterpretqP128U64(poly128_t* r, uint64x2_t* v0) { *r = vreinterpretq_p128_u64(*v0); }
void VreinterpretqP128U16(poly128_t* r, uint16x8_t* v0) { *r = vreinterpretq_p128_u16(*v0); }
void VreinterpretqP128S8(poly128_t* r, int8x16_t* v0) { *r = vreinterpretq_p128_s8(*v0); }
void VreinterpretqP128F64(poly128_t* r, float64x2_t* v0) { *r = vreinterpretq_p128_f64(*v0); }
void VreinterpretqP128F32(poly128_t* r, float32x4_t* v0) { *r = vreinterpretq_p128_f32(*v0); }
void VreinterpretqP128S32(poly128_t* r, int32x4_t* v0) { *r = vreinterpretq_p128_s32(*v0); }
void VreinterpretqP128S64(poly128_t* r, int64x2_t* v0) { *r = vreinterpretq_p128_s64(*v0); }
void VreinterpretqP128S16(poly128_t* r, int16x8_t* v0) { *r = vreinterpretq_p128_s16(*v0); }
void VreinterpretqP64P8(poly64x2_t* r, poly8x16_t* v0) { *r = vreinterpretq_p64_p8(*v0); }
void VreinterpretqP64P128(poly64x2_t* r, poly128_t* v0) { *r = vreinterpretq_p64_p128(*v0); }
void VreinterpretqP64P16(poly64x2_t* r, poly16x8_t* v0) { *r = vreinterpretq_p64_p16(*v0); }
void VreinterpretqP64U8(poly64x2_t* r, uint8x16_t* v0) { *r = vreinterpretq_p64_u8(*v0); }
void VreinterpretqP64U32(poly64x2_t* r, uint32x4_t* v0) { *r = vreinterpretq_p64_u32(*v0); }
void VreinterpretqP64U64(poly64x2_t* r, uint64x2_t* v0) { *r = vreinterpretq_p64_u64(*v0); }
void VreinterpretqP64U16(poly64x2_t* r, uint16x8_t* v0) { *r = vreinterpretq_p64_u16(*v0); }
void VreinterpretqP64S8(poly64x2_t* r, int8x16_t* v0) { *r = vreinterpretq_p64_s8(*v0); }
void VreinterpretqP64F64(poly64x2_t* r, float64x2_t* v0) { *r = vreinterpretq_p64_f64(*v0); }
void VreinterpretqP64F32(poly64x2_t* r, float32x4_t* v0) { *r = vreinterpretq_p64_f32(*v0); }
void VreinterpretqP64S32(poly64x2_t* r, int32x4_t* v0) { *r = vreinterpretq_p64_s32(*v0); }
void VreinterpretqP64S64(poly64x2_t* r, int64x2_t* v0) { *r = vreinterpretq_p64_s64(*v0); }
void VreinterpretqP64S16(poly64x2_t* r, int16x8_t* v0) { *r = vreinterpretq_p64_s16(*v0); }
void VreinterpretqP16P8(poly16x8_t* r, poly8x16_t* v0) { *r = vreinterpretq_p16_p8(*v0); }
void VreinterpretqP16P128(poly16x8_t* r, poly128_t* v0) { *r = vreinterpretq_p16_p128(*v0); }
void VreinterpretqP16P64(poly16x8_t* r, poly64x2_t* v0) { *r = vreinterpretq_p16_p64(*v0); }
void VreinterpretqP16U8(poly16x8_t* r, uint8x16_t* v0) { *r = vreinterpretq_p16_u8(*v0); }
void VreinterpretqP16U32(poly16x8_t* r, uint32x4_t* v0) { *r = vreinterpretq_p16_u32(*v0); }
void VreinterpretqP16U64(poly16x8_t* r, uint64x2_t* v0) { *r = vreinterpretq_p16_u64(*v0); }
void VreinterpretqP16U16(poly16x8_t* r, uint16x8_t* v0) { *r = vreinterpretq_p16_u16(*v0); }
void VreinterpretqP16S8(poly16x8_t* r, int8x16_t* v0) { *r = vreinterpretq_p16_s8(*v0); }
void VreinterpretqP16F64(poly16x8_t* r, float64x2_t* v0) { *r = vreinterpretq_p16_f64(*v0); }
void VreinterpretqP16F32(poly16x8_t* r, float32x4_t* v0) { *r = vreinterpretq_p16_f32(*v0); }
void VreinterpretqP16S32(poly16x8_t* r, int32x4_t* v0) { *r = vreinterpretq_p16_s32(*v0); }
void VreinterpretqP16S64(poly16x8_t* r, int64x2_t* v0) { *r = vreinterpretq_p16_s64(*v0); }
void VreinterpretqP16S16(poly16x8_t* r, int16x8_t* v0) { *r = vreinterpretq_p16_s16(*v0); }
void VreinterpretqU8P8(uint8x16_t* r, poly8x16_t* v0) { *r = vreinterpretq_u8_p8(*v0); }
void VreinterpretqU8P128(uint8x16_t* r, poly128_t* v0) { *r = vreinterpretq_u8_p128(*v0); }
void VreinterpretqU8P64(uint8x16_t* r, poly64x2_t* v0) { *r = vreinterpretq_u8_p64(*v0); }
void VreinterpretqU8P16(uint8x16_t* r, poly16x8_t* v0) { *r = vreinterpretq_u8_p16(*v0); }
void VreinterpretqU8U32(uint8x16_t* r, uint32x4_t* v0) { *r = vreinterpretq_u8_u32(*v0); }
void VreinterpretqU8U64(uint8x16_t* r, uint64x2_t* v0) { *r = vreinterpretq_u8_u64(*v0); }
void VreinterpretqU8U16(uint8x16_t* r, uint16x8_t* v0) { *r = vreinterpretq_u8_u16(*v0); }
void VreinterpretqU8S8(uint8x16_t* r, int8x16_t* v0) { *r = vreinterpretq_u8_s8(*v0); }
void VreinterpretqU8F64(uint8x16_t* r, float64x2_t* v0) { *r = vreinterpretq_u8_f64(*v0); }
void VreinterpretqU8F32(uint8x16_t* r, float32x4_t* v0) { *r = vreinterpretq_u8_f32(*v0); }
void VreinterpretqU8S32(uint8x16_t* r, int32x4_t* v0) { *r = vreinterpretq_u8_s32(*v0); }
void VreinterpretqU8S64(uint8x16_t* r, int64x2_t* v0) { *r = vreinterpretq_u8_s64(*v0); }
void VreinterpretqU8S16(uint8x16_t* r, int16x8_t* v0) { *r = vreinterpretq_u8_s16(*v0); }
void VreinterpretqU32P8(uint32x4_t* r, poly8x16_t* v0) { *r = vreinterpretq_u32_p8(*v0); }
void VreinterpretqU32P128(uint32x4_t* r, poly128_t* v0) { *r = vreinterpretq_u32_p128(*v0); }
void VreinterpretqU32P64(uint32x4_t* r, poly64x2_t* v0) { *r = vreinterpretq_u32_p64(*v0); }
void VreinterpretqU32P16(uint32x4_t* r, poly16x8_t* v0) { *r = vreinterpretq_u32_p16(*v0); }
void VreinterpretqU32U8(uint32x4_t* r, uint8x16_t* v0) { *r = vreinterpretq_u32_u8(*v0); }
void VreinterpretqU32U64(uint32x4_t* r, uint64x2_t* v0) { *r = vreinterpretq_u32_u64(*v0); }
void VreinterpretqU32U16(uint32x4_t* r, uint16x8_t* v0) { *r = vreinterpretq_u32_u16(*v0); }
void VreinterpretqU32S8(uint32x4_t* r, int8x16_t* v0) { *r = vreinterpretq_u32_s8(*v0); }
void VreinterpretqU32F64(uint32x4_t* r, float64x2_t* v0) { *r = vreinterpretq_u32_f64(*v0); }
void VreinterpretqU32F32(uint32x4_t* r, float32x4_t* v0) { *r = vreinterpretq_u32_f32(*v0); }
void VreinterpretqU32S32(uint32x4_t* r, int32x4_t* v0) { *r = vreinterpretq_u32_s32(*v0); }
void VreinterpretqU32S64(uint32x4_t* r, int64x2_t* v0) { *r = vreinterpretq_u32_s64(*v0); }
void VreinterpretqU32S16(uint32x4_t* r, int16x8_t* v0) { *r = vreinterpretq_u32_s16(*v0); }
void VreinterpretqU64P8(uint64x2_t* r, poly8x16_t* v0) { *r = vreinterpretq_u64_p8(*v0); }
void VreinterpretqU64P128(uint64x2_t* r, poly128_t* v0) { *r = vreinterpretq_u64_p128(*v0); }
void VreinterpretqU64P64(uint64x2_t* r, poly64x2_t* v0) { *r = vreinterpretq_u64_p64(*v0); }
void VreinterpretqU64P16(uint64x2_t* r, poly16x8_t* v0) { *r = vreinterpretq_u64_p16(*v0); }
void VreinterpretqU64U8(uint64x2_t* r, uint8x16_t* v0) { *r = vreinterpretq_u64_u8(*v0); }
void VreinterpretqU64U32(uint64x2_t* r, uint32x4_t* v0) { *r = vreinterpretq_u64_u32(*v0); }
void VreinterpretqU64U16(uint64x2_t* r, uint16x8_t* v0) { *r = vreinterpretq_u64_u16(*v0); }
void VreinterpretqU64S8(uint64x2_t* r, int8x16_t* v0) { *r = vreinterpretq_u64_s8(*v0); }
void VreinterpretqU64F64(uint64x2_t* r, float64x2_t* v0) { *r = vreinterpretq_u64_f64(*v0); }
void VreinterpretqU64F32(uint64x2_t* r, float32x4_t* v0) { *r = vreinterpretq_u64_f32(*v0); }
void VreinterpretqU64S32(uint64x2_t* r, int32x4_t* v0) { *r = vreinterpretq_u64_s32(*v0); }
void VreinterpretqU64S64(uint64x2_t* r, int64x2_t* v0) { *r = vreinterpretq_u64_s64(*v0); }
void VreinterpretqU64S16(uint64x2_t* r, int16x8_t* v0) { *r = vreinterpretq_u64_s16(*v0); }
void VreinterpretqU16P8(uint16x8_t* r, poly8x16_t* v0) { *r = vreinterpretq_u16_p8(*v0); }
void VreinterpretqU16P128(uint16x8_t* r, poly128_t* v0) { *r = vreinterpretq_u16_p128(*v0); }
void VreinterpretqU16P64(uint16x8_t* r, poly64x2_t* v0) { *r = vreinterpretq_u16_p64(*v0); }
void VreinterpretqU16P16(uint16x8_t* r, poly16x8_t* v0) { *r = vreinterpretq_u16_p16(*v0); }
void VreinterpretqU16U8(uint16x8_t* r, uint8x16_t* v0) { *r = vreinterpretq_u16_u8(*v0); }
void VreinterpretqU16U32(uint16x8_t* r, uint32x4_t* v0) { *r = vreinterpretq_u16_u32(*v0); }
void VreinterpretqU16U64(uint16x8_t* r, uint64x2_t* v0) { *r = vreinterpretq_u16_u64(*v0); }
void VreinterpretqU16S8(uint16x8_t* r, int8x16_t* v0) { *r = vreinterpretq_u16_s8(*v0); }
void VreinterpretqU16F64(uint16x8_t* r, float64x2_t* v0) { *r = vreinterpretq_u16_f64(*v0); }
void VreinterpretqU16F32(uint16x8_t* r, float32x4_t* v0) { *r = vreinterpretq_u16_f32(*v0); }
void VreinterpretqU16S32(uint16x8_t* r, int32x4_t* v0) { *r = vreinterpretq_u16_s32(*v0); }
void VreinterpretqU16S64(uint16x8_t* r, int64x2_t* v0) { *r = vreinterpretq_u16_s64(*v0); }
void VreinterpretqU16S16(uint16x8_t* r, int16x8_t* v0) { *r = vreinterpretq_u16_s16(*v0); }
void VreinterpretqS8P8(int8x16_t* r, poly8x16_t* v0) { *r = vreinterpretq_s8_p8(*v0); }
void VreinterpretqS8P128(int8x16_t* r, poly128_t* v0) { *r = vreinterpretq_s8_p128(*v0); }
void VreinterpretqS8P64(int8x16_t* r, poly64x2_t* v0) { *r = vreinterpretq_s8_p64(*v0); }
void VreinterpretqS8P16(int8x16_t* r, poly16x8_t* v0) { *r = vreinterpretq_s8_p16(*v0); }
void VreinterpretqS8U8(int8x16_t* r, uint8x16_t* v0) { *r = vreinterpretq_s8_u8(*v0); }
void VreinterpretqS8U32(int8x16_t* r, uint32x4_t* v0) { *r = vreinterpretq_s8_u32(*v0); }
void VreinterpretqS8U64(int8x16_t* r, uint64x2_t* v0) { *r = vreinterpretq_s8_u64(*v0); }
void VreinterpretqS8U16(int8x16_t* r, uint16x8_t* v0) { *r = vreinterpretq_s8_u16(*v0); }
void VreinterpretqS8F64(int8x16_t* r, float64x2_t* v0) { *r = vreinterpretq_s8_f64(*v0); }
void VreinterpretqS8F32(int8x16_t* r, float32x4_t* v0) { *r = vreinterpretq_s8_f32(*v0); }
void VreinterpretqS8S32(int8x16_t* r, int32x4_t* v0) { *r = vreinterpretq_s8_s32(*v0); }
void VreinterpretqS8S64(int8x16_t* r, int64x2_t* v0) { *r = vreinterpretq_s8_s64(*v0); }
void VreinterpretqS8S16(int8x16_t* r, int16x8_t* v0) { *r = vreinterpretq_s8_s16(*v0); }
void VreinterpretqF64P8(float64x2_t* r, poly8x16_t* v0) { *r = vreinterpretq_f64_p8(*v0); }
void VreinterpretqF64P128(float64x2_t* r, poly128_t* v0) { *r = vreinterpretq_f64_p128(*v0); }
void VreinterpretqF64P64(float64x2_t* r, poly64x2_t* v0) { *r = vreinterpretq_f64_p64(*v0); }
void VreinterpretqF64P16(float64x2_t* r, poly16x8_t* v0) { *r = vreinterpretq_f64_p16(*v0); }
void VreinterpretqF64U8(float64x2_t* r, uint8x16_t* v0) { *r = vreinterpretq_f64_u8(*v0); }
void VreinterpretqF64U32(float64x2_t* r, uint32x4_t* v0) { *r = vreinterpretq_f64_u32(*v0); }
void VreinterpretqF64U64(float64x2_t* r, uint64x2_t* v0) { *r = vreinterpretq_f64_u64(*v0); }
void VreinterpretqF64U16(float64x2_t* r, uint16x8_t* v0) { *r = vreinterpretq_f64_u16(*v0); }
void VreinterpretqF64S8(float64x2_t* r, int8x16_t* v0) { *r = vreinterpretq_f64_s8(*v0); }
void VreinterpretqF64F32(float64x2_t* r, float32x4_t* v0) { *r = vreinterpretq_f64_f32(*v0); }
void VreinterpretqF64S32(float64x2_t* r, int32x4_t* v0) { *r = vreinterpretq_f64_s32(*v0); }
void VreinterpretqF64S64(float64x2_t* r, int64x2_t* v0) { *r = vreinterpretq_f64_s64(*v0); }
void VreinterpretqF64S16(float64x2_t* r, int16x8_t* v0) { *r = vreinterpretq_f64_s16(*v0); }
void VreinterpretqF32P8(float32x4_t* r, poly8x16_t* v0) { *r = vreinterpretq_f32_p8(*v0); }
void VreinterpretqF32P128(float32x4_t* r, poly128_t* v0) { *r = vreinterpretq_f32_p128(*v0); }
void VreinterpretqF32P64(float32x4_t* r, poly64x2_t* v0) { *r = vreinterpretq_f32_p64(*v0); }
void VreinterpretqF32P16(float32x4_t* r, poly16x8_t* v0) { *r = vreinterpretq_f32_p16(*v0); }
void VreinterpretqF32U8(float32x4_t* r, uint8x16_t* v0) { *r = vreinterpretq_f32_u8(*v0); }
void VreinterpretqF32U32(float32x4_t* r, uint32x4_t* v0) { *r = vreinterpretq_f32_u32(*v0); }
void VreinterpretqF32U64(float32x4_t* r, uint64x2_t* v0) { *r = vreinterpretq_f32_u64(*v0); }
void VreinterpretqF32U16(float32x4_t* r, uint16x8_t* v0) { *r = vreinterpretq_f32_u16(*v0); }
void VreinterpretqF32S8(float32x4_t* r, int8x16_t* v0) { *r = vreinterpretq_f32_s8(*v0); }
void VreinterpretqF32F64(float32x4_t* r, float64x2_t* v0) { *r = vreinterpretq_f32_f64(*v0); }
void VreinterpretqF32S32(float32x4_t* r, int32x4_t* v0) { *r = vreinterpretq_f32_s32(*v0); }
void VreinterpretqF32S64(float32x4_t* r, int64x2_t* v0) { *r = vreinterpretq_f32_s64(*v0); }
void VreinterpretqF32S16(float32x4_t* r, int16x8_t* v0) { *r = vreinterpretq_f32_s16(*v0); }
void VreinterpretqS32P8(int32x4_t* r, poly8x16_t* v0) { *r = vreinterpretq_s32_p8(*v0); }
void VreinterpretqS32P128(int32x4_t* r, poly128_t* v0) { *r = vreinterpretq_s32_p128(*v0); }
void VreinterpretqS32P64(int32x4_t* r, poly64x2_t* v0) { *r = vreinterpretq_s32_p64(*v0); }
void VreinterpretqS32P16(int32x4_t* r, poly16x8_t* v0) { *r = vreinterpretq_s32_p16(*v0); }
void VreinterpretqS32U8(int32x4_t* r, uint8x16_t* v0) { *r = vreinterpretq_s32_u8(*v0); }
void VreinterpretqS32U32(int32x4_t* r, uint32x4_t* v0) { *r = vreinterpretq_s32_u32(*v0); }
void VreinterpretqS32U64(int32x4_t* r, uint64x2_t* v0) { *r = vreinterpretq_s32_u64(*v0); }
void VreinterpretqS32U16(int32x4_t* r, uint16x8_t* v0) { *r = vreinterpretq_s32_u16(*v0); }
void VreinterpretqS32S8(int32x4_t* r, int8x16_t* v0) { *r = vreinterpretq_s32_s8(*v0); }
void VreinterpretqS32F64(int32x4_t* r, float64x2_t* v0) { *r = vreinterpretq_s32_f64(*v0); }
void VreinterpretqS32F32(int32x4_t* r, float32x4_t* v0) { *r = vreinterpretq_s32_f32(*v0); }
void VreinterpretqS32S64(int32x4_t* r, int64x2_t* v0) { *r = vreinterpretq_s32_s64(*v0); }
void VreinterpretqS32S16(int32x4_t* r, int16x8_t* v0) { *r = vreinterpretq_s32_s16(*v0); }
void VreinterpretqS64P8(int64x2_t* r, poly8x16_t* v0) { *r = vreinterpretq_s64_p8(*v0); }
void VreinterpretqS64P128(int64x2_t* r, poly128_t* v0) { *r = vreinterpretq_s64_p128(*v0); }
void VreinterpretqS64P64(int64x2_t* r, poly64x2_t* v0) { *r = vreinterpretq_s64_p64(*v0); }
void VreinterpretqS64P16(int64x2_t* r, poly16x8_t* v0) { *r = vreinterpretq_s64_p16(*v0); }
void VreinterpretqS64U8(int64x2_t* r, uint8x16_t* v0) { *r = vreinterpretq_s64_u8(*v0); }
void VreinterpretqS64U32(int64x2_t* r, uint32x4_t* v0) { *r = vreinterpretq_s64_u32(*v0); }
void VreinterpretqS64U64(int64x2_t* r, uint64x2_t* v0) { *r = vreinterpretq_s64_u64(*v0); }
void VreinterpretqS64U16(int64x2_t* r, uint16x8_t* v0) { *r = vreinterpretq_s64_u16(*v0); }
void VreinterpretqS64S8(int64x2_t* r, int8x16_t* v0) { *r = vreinterpretq_s64_s8(*v0); }
void VreinterpretqS64F64(int64x2_t* r, float64x2_t* v0) { *r = vreinterpretq_s64_f64(*v0); }
void VreinterpretqS64F32(int64x2_t* r, float32x4_t* v0) { *r = vreinterpretq_s64_f32(*v0); }
void VreinterpretqS64S32(int64x2_t* r, int32x4_t* v0) { *r = vreinterpretq_s64_s32(*v0); }
void VreinterpretqS64S16(int64x2_t* r, int16x8_t* v0) { *r = vreinterpretq_s64_s16(*v0); }
void VreinterpretqS16P8(int16x8_t* r, poly8x16_t* v0) { *r = vreinterpretq_s16_p8(*v0); }
void VreinterpretqS16P128(int16x8_t* r, poly128_t* v0) { *r = vreinterpretq_s16_p128(*v0); }
void VreinterpretqS16P64(int16x8_t* r, poly64x2_t* v0) { *r = vreinterpretq_s16_p64(*v0); }
void VreinterpretqS16P16(int16x8_t* r, poly16x8_t* v0) { *r = vreinterpretq_s16_p16(*v0); }
void VreinterpretqS16U8(int16x8_t* r, uint8x16_t* v0) { *r = vreinterpretq_s16_u8(*v0); }
void VreinterpretqS16U32(int16x8_t* r, uint32x4_t* v0) { *r = vreinterpretq_s16_u32(*v0); }
void VreinterpretqS16U64(int16x8_t* r, uint64x2_t* v0) { *r = vreinterpretq_s16_u64(*v0); }
void VreinterpretqS16U16(int16x8_t* r, uint16x8_t* v0) { *r = vreinterpretq_s16_u16(*v0); }
void VreinterpretqS16S8(int16x8_t* r, int8x16_t* v0) { *r = vreinterpretq_s16_s8(*v0); }
void VreinterpretqS16F64(int16x8_t* r, float64x2_t* v0) { *r = vreinterpretq_s16_f64(*v0); }
void VreinterpretqS16F32(int16x8_t* r, float32x4_t* v0) { *r = vreinterpretq_s16_f32(*v0); }
void VreinterpretqS16S32(int16x8_t* r, int32x4_t* v0) { *r = vreinterpretq_s16_s32(*v0); }
void VreinterpretqS16S64(int16x8_t* r, int64x2_t* v0) { *r = vreinterpretq_s16_s64(*v0); }
void VreinterpretU8P8(uint8x8_t* r, poly8x8_t* v0) { *r = vreinterpret_u8_p8(*v0); }
void VreinterpretU8P64(uint8x8_t* r, poly64x1_t* v0) { *r = vreinterpret_u8_p64(*v0); }
void VreinterpretU8P16(uint8x8_t* r, poly16x4_t* v0) { *r = vreinterpret_u8_p16(*v0); }
void VreinterpretU8U32(uint8x8_t* r, uint32x2_t* v0) { *r = vreinterpret_u8_u32(*v0); }
void VreinterpretU8U64(uint8x8_t* r, uint64x1_t* v0) { *r = vreinterpret_u8_u64(*v0); }
void VreinterpretU8U16(uint8x8_t* r, uint16x4_t* v0) { *r = vreinterpret_u8_u16(*v0); }
void VreinterpretU8S8(uint8x8_t* r, int8x8_t* v0) { *r = vreinterpret_u8_s8(*v0); }
void VreinterpretU8F64(uint8x8_t* r, float64x1_t* v0) { *r = vreinterpret_u8_f64(*v0); }
void VreinterpretU8F32(uint8x8_t* r, float32x2_t* v0) { *r = vreinterpret_u8_f32(*v0); }
void VreinterpretU8S32(uint8x8_t* r, int32x2_t* v0) { *r = vreinterpret_u8_s32(*v0); }
void VreinterpretU8S64(uint8x8_t* r, int64x1_t* v0) { *r = vreinterpret_u8_s64(*v0); }
void VreinterpretU8S16(uint8x8_t* r, int16x4_t* v0) { *r = vreinterpret_u8_s16(*v0); }
void VreinterpretU32P8(uint32x2_t* r, poly8x8_t* v0) { *r = vreinterpret_u32_p8(*v0); }
void VreinterpretU32P64(uint32x2_t* r, poly64x1_t* v0) { *r = vreinterpret_u32_p64(*v0); }
void VreinterpretU32P16(uint32x2_t* r, poly16x4_t* v0) { *r = vreinterpret_u32_p16(*v0); }
void VreinterpretU32U8(uint32x2_t* r, uint8x8_t* v0) { *r = vreinterpret_u32_u8(*v0); }
void VreinterpretU32U64(uint32x2_t* r, uint64x1_t* v0) { *r = vreinterpret_u32_u64(*v0); }
void VreinterpretU32U16(uint32x2_t* r, uint16x4_t* v0) { *r = vreinterpret_u32_u16(*v0); }
void VreinterpretU32S8(uint32x2_t* r, int8x8_t* v0) { *r = vreinterpret_u32_s8(*v0); }
void VreinterpretU32F64(uint32x2_t* r, float64x1_t* v0) { *r = vreinterpret_u32_f64(*v0); }
void VreinterpretU32F32(uint32x2_t* r, float32x2_t* v0) { *r = vreinterpret_u32_f32(*v0); }
void VreinterpretU32S32(uint32x2_t* r, int32x2_t* v0) { *r = vreinterpret_u32_s32(*v0); }
void VreinterpretU32S64(uint32x2_t* r, int64x1_t* v0) { *r = vreinterpret_u32_s64(*v0); }
void VreinterpretU32S16(uint32x2_t* r, int16x4_t* v0) { *r = vreinterpret_u32_s16(*v0); }
void VreinterpretU64P8(uint64x1_t* r, poly8x8_t* v0) { *r = vreinterpret_u64_p8(*v0); }
void VreinterpretU64P64(uint64x1_t* r, poly64x1_t* v0) { *r = vreinterpret_u64_p64(*v0); }
void VreinterpretU64P16(uint64x1_t* r, poly16x4_t* v0) { *r = vreinterpret_u64_p16(*v0); }
void VreinterpretU64U8(uint64x1_t* r, uint8x8_t* v0) { *r = vreinterpret_u64_u8(*v0); }
void VreinterpretU64U32(uint64x1_t* r, uint32x2_t* v0) { *r = vreinterpret_u64_u32(*v0); }
void VreinterpretU64U16(uint64x1_t* r, uint16x4_t* v0) { *r = vreinterpret_u64_u16(*v0); }
void VreinterpretU64S8(uint64x1_t* r, int8x8_t* v0) { *r = vreinterpret_u64_s8(*v0); }
void VreinterpretU64F64(uint64x1_t* r, float64x1_t* v0) { *r = vreinterpret_u64_f64(*v0); }
void VreinterpretU64F32(uint64x1_t* r, float32x2_t* v0) { *r = vreinterpret_u64_f32(*v0); }
void VreinterpretU64S32(uint64x1_t* r, int32x2_t* v0) { *r = vreinterpret_u64_s32(*v0); }
void VreinterpretU64S64(uint64x1_t* r, int64x1_t* v0) { *r = vreinterpret_u64_s64(*v0); }
void VreinterpretU64S16(uint64x1_t* r, int16x4_t* v0) { *r = vreinterpret_u64_s16(*v0); }
void VreinterpretU16P8(uint16x4_t* r, poly8x8_t* v0) { *r = vreinterpret_u16_p8(*v0); }
void VreinterpretU16P64(uint16x4_t* r, poly64x1_t* v0) { *r = vreinterpret_u16_p64(*v0); }
void VreinterpretU16P16(uint16x4_t* r, poly16x4_t* v0) { *r = vreinterpret_u16_p16(*v0); }
void VreinterpretU16U8(uint16x4_t* r, uint8x8_t* v0) { *r = vreinterpret_u16_u8(*v0); }
void VreinterpretU16U32(uint16x4_t* r, uint32x2_t* v0) { *r = vreinterpret_u16_u32(*v0); }
void VreinterpretU16U64(uint16x4_t* r, uint64x1_t* v0) { *r = vreinterpret_u16_u64(*v0); }
void VreinterpretU16S8(uint16x4_t* r, int8x8_t* v0) { *r = vreinterpret_u16_s8(*v0); }
void VreinterpretU16F64(uint16x4_t* r, float64x1_t* v0) { *r = vreinterpret_u16_f64(*v0); }
void VreinterpretU16F32(uint16x4_t* r, float32x2_t* v0) { *r = vreinterpret_u16_f32(*v0); }
void VreinterpretU16S32(uint16x4_t* r, int32x2_t* v0) { *r = vreinterpret_u16_s32(*v0); }
void VreinterpretU16S64(uint16x4_t* r, int64x1_t* v0) { *r = vreinterpret_u16_s64(*v0); }
void VreinterpretU16S16(uint16x4_t* r, int16x4_t* v0) { *r = vreinterpret_u16_s16(*v0); }
void VreinterpretS8P8(int8x8_t* r, poly8x8_t* v0) { *r = vreinterpret_s8_p8(*v0); }
void VreinterpretS8P64(int8x8_t* r, poly64x1_t* v0) { *r = vreinterpret_s8_p64(*v0); }
void VreinterpretS8P16(int8x8_t* r, poly16x4_t* v0) { *r = vreinterpret_s8_p16(*v0); }
void VreinterpretS8U8(int8x8_t* r, uint8x8_t* v0) { *r = vreinterpret_s8_u8(*v0); }
void VreinterpretS8U32(int8x8_t* r, uint32x2_t* v0) { *r = vreinterpret_s8_u32(*v0); }
void VreinterpretS8U64(int8x8_t* r, uint64x1_t* v0) { *r = vreinterpret_s8_u64(*v0); }
void VreinterpretS8U16(int8x8_t* r, uint16x4_t* v0) { *r = vreinterpret_s8_u16(*v0); }
void VreinterpretS8F64(int8x8_t* r, float64x1_t* v0) { *r = vreinterpret_s8_f64(*v0); }
void VreinterpretS8F32(int8x8_t* r, float32x2_t* v0) { *r = vreinterpret_s8_f32(*v0); }
void VreinterpretS8S32(int8x8_t* r, int32x2_t* v0) { *r = vreinterpret_s8_s32(*v0); }
void VreinterpretS8S64(int8x8_t* r, int64x1_t* v0) { *r = vreinterpret_s8_s64(*v0); }
void VreinterpretS8S16(int8x8_t* r, int16x4_t* v0) { *r = vreinterpret_s8_s16(*v0); }
void VreinterpretF64P8(float64x1_t* r, poly8x8_t* v0) { *r = vreinterpret_f64_p8(*v0); }
void VreinterpretF64P64(float64x1_t* r, poly64x1_t* v0) { *r = vreinterpret_f64_p64(*v0); }
void VreinterpretF64P16(float64x1_t* r, poly16x4_t* v0) { *r = vreinterpret_f64_p16(*v0); }
void VreinterpretF64U8(float64x1_t* r, uint8x8_t* v0) { *r = vreinterpret_f64_u8(*v0); }
void VreinterpretF64U32(float64x1_t* r, uint32x2_t* v0) { *r = vreinterpret_f64_u32(*v0); }
void VreinterpretF64U64(float64x1_t* r, uint64x1_t* v0) { *r = vreinterpret_f64_u64(*v0); }
void VreinterpretF64U16(float64x1_t* r, uint16x4_t* v0) { *r = vreinterpret_f64_u16(*v0); }
void VreinterpretF64S8(float64x1_t* r, int8x8_t* v0) { *r = vreinterpret_f64_s8(*v0); }
void VreinterpretF64F32(float64x1_t* r, float32x2_t* v0) { *r = vreinterpret_f64_f32(*v0); }
void VreinterpretF64S32(float64x1_t* r, int32x2_t* v0) { *r = vreinterpret_f64_s32(*v0); }
void VreinterpretF64S64(float64x1_t* r, int64x1_t* v0) { *r = vreinterpret_f64_s64(*v0); }
void VreinterpretF64S16(float64x1_t* r, int16x4_t* v0) { *r = vreinterpret_f64_s16(*v0); }
void VreinterpretF32P8(float32x2_t* r, poly8x8_t* v0) { *r = vreinterpret_f32_p8(*v0); }
void VreinterpretF32P64(float32x2_t* r, poly64x1_t* v0) { *r = vreinterpret_f32_p64(*v0); }
void VreinterpretF32P16(float32x2_t* r, poly16x4_t* v0) { *r = vreinterpret_f32_p16(*v0); }
void VreinterpretF32U8(float32x2_t* r, uint8x8_t* v0) { *r = vreinterpret_f32_u8(*v0); }
void VreinterpretF32U32(float32x2_t* r, uint32x2_t* v0) { *r = vreinterpret_f32_u32(*v0); }
void VreinterpretF32U64(float32x2_t* r, uint64x1_t* v0) { *r = vreinterpret_f32_u64(*v0); }
void VreinterpretF32U16(float32x2_t* r, uint16x4_t* v0) { *r = vreinterpret_f32_u16(*v0); }
void VreinterpretF32S8(float32x2_t* r, int8x8_t* v0) { *r = vreinterpret_f32_s8(*v0); }
void VreinterpretF32F64(float32x2_t* r, float64x1_t* v0) { *r = vreinterpret_f32_f64(*v0); }
void VreinterpretF32S32(float32x2_t* r, int32x2_t* v0) { *r = vreinterpret_f32_s32(*v0); }
void VreinterpretF32S64(float32x2_t* r, int64x1_t* v0) { *r = vreinterpret_f32_s64(*v0); }
void VreinterpretF32S16(float32x2_t* r, int16x4_t* v0) { *r = vreinterpret_f32_s16(*v0); }
void VreinterpretS32P8(int32x2_t* r, poly8x8_t* v0) { *r = vreinterpret_s32_p8(*v0); }
void VreinterpretS32P64(int32x2_t* r, poly64x1_t* v0) { *r = vreinterpret_s32_p64(*v0); }
void VreinterpretS32P16(int32x2_t* r, poly16x4_t* v0) { *r = vreinterpret_s32_p16(*v0); }
void VreinterpretS32U8(int32x2_t* r, uint8x8_t* v0) { *r = vreinterpret_s32_u8(*v0); }
void VreinterpretS32U32(int32x2_t* r, uint32x2_t* v0) { *r = vreinterpret_s32_u32(*v0); }
void VreinterpretS32U64(int32x2_t* r, uint64x1_t* v0) { *r = vreinterpret_s32_u64(*v0); }
void VreinterpretS32U16(int32x2_t* r, uint16x4_t* v0) { *r = vreinterpret_s32_u16(*v0); }
void VreinterpretS32S8(int32x2_t* r, int8x8_t* v0) { *r = vreinterpret_s32_s8(*v0); }
void VreinterpretS32F64(int32x2_t* r, float64x1_t* v0) { *r = vreinterpret_s32_f64(*v0); }
void VreinterpretS32F32(int32x2_t* r, float32x2_t* v0) { *r = vreinterpret_s32_f32(*v0); }
void VreinterpretS32S64(int32x2_t* r, int64x1_t* v0) { *r = vreinterpret_s32_s64(*v0); }
void VreinterpretS32S16(int32x2_t* r, int16x4_t* v0) { *r = vreinterpret_s32_s16(*v0); }
void VreinterpretS64P8(int64x1_t* r, poly8x8_t* v0) { *r = vreinterpret_s64_p8(*v0); }
void VreinterpretS64P64(int64x1_t* r, poly64x1_t* v0) { *r = vreinterpret_s64_p64(*v0); }
void VreinterpretS64P16(int64x1_t* r, poly16x4_t* v0) { *r = vreinterpret_s64_p16(*v0); }
void VreinterpretS64U8(int64x1_t* r, uint8x8_t* v0) { *r = vreinterpret_s64_u8(*v0); }
void VreinterpretS64U32(int64x1_t* r, uint32x2_t* v0) { *r = vreinterpret_s64_u32(*v0); }
void VreinterpretS64U64(int64x1_t* r, uint64x1_t* v0) { *r = vreinterpret_s64_u64(*v0); }
void VreinterpretS64U16(int64x1_t* r, uint16x4_t* v0) { *r = vreinterpret_s64_u16(*v0); }
void VreinterpretS64S8(int64x1_t* r, int8x8_t* v0) { *r = vreinterpret_s64_s8(*v0); }
void VreinterpretS64F64(int64x1_t* r, float64x1_t* v0) { *r = vreinterpret_s64_f64(*v0); }
void VreinterpretS64F32(int64x1_t* r, float32x2_t* v0) { *r = vreinterpret_s64_f32(*v0); }
void VreinterpretS64S32(int64x1_t* r, int32x2_t* v0) { *r = vreinterpret_s64_s32(*v0); }
void VreinterpretS64S16(int64x1_t* r, int16x4_t* v0) { *r = vreinterpret_s64_s16(*v0); }
void VreinterpretS16P8(int16x4_t* r, poly8x8_t* v0) { *r = vreinterpret_s16_p8(*v0); }
void VreinterpretS16P64(int16x4_t* r, poly64x1_t* v0) { *r = vreinterpret_s16_p64(*v0); }
void VreinterpretS16P16(int16x4_t* r, poly16x4_t* v0) { *r = vreinterpret_s16_p16(*v0); }
void VreinterpretS16U8(int16x4_t* r, uint8x8_t* v0) { *r = vreinterpret_s16_u8(*v0); }
void VreinterpretS16U32(int16x4_t* r, uint32x2_t* v0) { *r = vreinterpret_s16_u32(*v0); }
void VreinterpretS16U64(int16x4_t* r, uint64x1_t* v0) { *r = vreinterpret_s16_u64(*v0); }
void VreinterpretS16U16(int16x4_t* r, uint16x4_t* v0) { *r = vreinterpret_s16_u16(*v0); }
void VreinterpretS16S8(int16x4_t* r, int8x8_t* v0) { *r = vreinterpret_s16_s8(*v0); }
void VreinterpretS16F64(int16x4_t* r, float64x1_t* v0) { *r = vreinterpret_s16_f64(*v0); }
void VreinterpretS16F32(int16x4_t* r, float32x2_t* v0) { *r = vreinterpret_s16_f32(*v0); }
void VreinterpretS16S32(int16x4_t* r, int32x2_t* v0) { *r = vreinterpret_s16_s32(*v0); }
void VreinterpretS16S64(int16x4_t* r, int64x1_t* v0) { *r = vreinterpret_s16_s64(*v0); }
void VrndqF64(float64x2_t* r, float64x2_t* v0) { *r = vrndq_f64(*v0); }
void VrndF64(float64x1_t* r, float64x1_t* v0) { *r = vrnd_f64(*v0); }
void VrndaqF64(float64x2_t* r, float64x2_t* v0) { *r = vrndaq_f64(*v0); }
void VrndaF64(float64x1_t* r, float64x1_t* v0) { *r = vrnda_f64(*v0); }
void VrndiqF64(float64x2_t* r, float64x2_t* v0) { *r = vrndiq_f64(*v0); }
void VrndiF64(float64x1_t* r, float64x1_t* v0) { *r = vrndi_f64(*v0); }
void VrndmqF64(float64x2_t* r, float64x2_t* v0) { *r = vrndmq_f64(*v0); }
void VrndmF64(float64x1_t* r, float64x1_t* v0) { *r = vrndm_f64(*v0); }
void VrndnqF64(float64x2_t* r, float64x2_t* v0) { *r = vrndnq_f64(*v0); }
void VrndnF64(float64x1_t* r, float64x1_t* v0) { *r = vrndn_f64(*v0); }
void VrndpqF64(float64x2_t* r, float64x2_t* v0) { *r = vrndpq_f64(*v0); }
void VrndpF64(float64x1_t* r, float64x1_t* v0) { *r = vrndp_f64(*v0); }
void VrndxqF64(float64x2_t* r, float64x2_t* v0) { *r = vrndxq_f64(*v0); }
void VrndxF64(float64x1_t* r, float64x1_t* v0) { *r = vrndx_f64(*v0); }
void Vrnd32XqF32(float32x4_t* r, float32x4_t* v0) { *r = vrnd32xq_f32(*v0); }
void Vrnd32XF32(float32x2_t* r, float32x2_t* v0) { *r = vrnd32x_f32(*v0); }
void Vrnd32ZqF32(float32x4_t* r, float32x4_t* v0) { *r = vrnd32zq_f32(*v0); }
void Vrnd32ZF32(float32x2_t* r, float32x2_t* v0) { *r = vrnd32z_f32(*v0); }
void Vrnd64XqF32(float32x4_t* r, float32x4_t* v0) { *r = vrnd64xq_f32(*v0); }
void Vrnd64XF32(float32x2_t* r, float32x2_t* v0) { *r = vrnd64x_f32(*v0); }
void Vrnd64ZqF32(float32x4_t* r, float32x4_t* v0) { *r = vrnd64zq_f32(*v0); }
void Vrnd64ZF32(float32x2_t* r, float32x2_t* v0) { *r = vrnd64z_f32(*v0); }
void VmaxnmqF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vmaxnmq_f64(*v0, *v1); }
void VmaxnmF64(float64x1_t* r, float64x1_t* v0, float64x1_t* v1) { *r = vmaxnm_f64(*v0, *v1); }
void VminnmqF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vminnmq_f64(*v0, *v1); }
void VminnmF64(float64x1_t* r, float64x1_t* v0, float64x1_t* v1) { *r = vminnm_f64(*v0, *v1); }
void VcaddRot270F32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vcadd_rot270_f32(*v0, *v1); }
void VcaddRot90F32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vcadd_rot90_f32(*v0, *v1); }
void VcaddqRot270F32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vcaddq_rot270_f32(*v0, *v1); }
void VcaddqRot90F32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vcaddq_rot90_f32(*v0, *v1); }
void VcaddqRot270F64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vcaddq_rot270_f64(*v0, *v1); }
void VcaddqRot90F64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vcaddq_rot90_f64(*v0, *v1); }
void VdotqU32(uint32x4_t* r, uint32x4_t* v0, uint8x16_t* v1, uint8x16_t* v2) { *r = vdotq_u32(*v0, *v1, *v2); }
void VdotqS32(int32x4_t* r, int32x4_t* v0, int8x16_t* v1, int8x16_t* v2) { *r = vdotq_s32(*v0, *v1, *v2); }
void VdotU32(uint32x2_t* r, uint32x2_t* v0, uint8x8_t* v1, uint8x8_t* v2) { *r = vdot_u32(*v0, *v1, *v2); }
void VdotS32(int32x2_t* r, int32x2_t* v0, int8x8_t* v1, int8x8_t* v2) { *r = vdot_s32(*v0, *v1, *v2); }
void VfmaqF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1, float32x4_t* v2) { *r = vfmaq_f32(*v0, *v1, *v2); }
void VfmaF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1, float32x2_t* v2) { *r = vfma_f32(*v0, *v1, *v2); }
void VfmaqNF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1, float32_t* v2) { *r = vfmaq_n_f32(*v0, *v1, *v2); }
void VfmaNF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1, float32_t* v2) { *r = vfma_n_f32(*v0, *v1, *v2); }
void VfmsqF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1, float32x4_t* v2) { *r = vfmsq_f32(*v0, *v1, *v2); }
void VfmsF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1, float32x2_t* v2) { *r = vfms_f32(*v0, *v1, *v2); }
void VqrdmlahqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1, int32x4_t* v2) { *r = vqrdmlahq_s32(*v0, *v1, *v2); }
void VqrdmlahqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1, int16x8_t* v2) { *r = vqrdmlahq_s16(*v0, *v1, *v2); }
void VqrdmlahS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1, int32x2_t* v2) { *r = vqrdmlah_s32(*v0, *v1, *v2); }
void VqrdmlahS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1, int16x4_t* v2) { *r = vqrdmlah_s16(*v0, *v1, *v2); }
void VqrdmlshqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1, int32x4_t* v2) { *r = vqrdmlshq_s32(*v0, *v1, *v2); }
void VqrdmlshqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1, int16x8_t* v2) { *r = vqrdmlshq_s16(*v0, *v1, *v2); }
void VqrdmlshS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1, int32x2_t* v2) { *r = vqrdmlsh_s32(*v0, *v1, *v2); }
void VqrdmlshS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1, int16x4_t* v2) { *r = vqrdmlsh_s16(*v0, *v1, *v2); }
void VabdqF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vabdq_f64(*v0, *v1); }
void VabdF64(float64x1_t* r, float64x1_t* v0, float64x1_t* v1) { *r = vabd_f64(*v0, *v1); }
void VabddF64(float64_t* r, float64_t* v0, float64_t* v1) { *r = vabdd_f64(*v0, *v1); }
void VabdsF32(float32_t* r, float32_t* v0, float32_t* v1) { *r = vabds_f32(*v0, *v1); }
void VabsqF64(float64x2_t* r, float64x2_t* v0) { *r = vabsq_f64(*v0); }
void VabsqS64(int64x2_t* r, int64x2_t* v0) { *r = vabsq_s64(*v0); }
void VabsF64(float64x1_t* r, float64x1_t* v0) { *r = vabs_f64(*v0); }
void VabsS64(int64x1_t* r, int64x1_t* v0) { *r = vabs_s64(*v0); }
void VabsdS64(int64_t* r, int64_t* v0) { *r = vabsd_s64(*v0); }
void VaddqF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vaddq_f64(*v0, *v1); }
void VaddF64(float64x1_t* r, float64x1_t* v0, float64x1_t* v1) { *r = vadd_f64(*v0, *v1); }
void VadddU64(uint64_t* r, uint64_t* v0, uint64_t* v1) { *r = vaddd_u64(*v0, *v1); }
void VadddS64(int64_t* r, int64_t* v0, int64_t* v1) { *r = vaddd_s64(*v0, *v1); }
void VaddqP128(poly128_t* r, poly128_t* v0, poly128_t* v1) { *r = vaddq_p128(*v0, *v1); }
void VaddhnHighU32(uint16x8_t* r, uint16x4_t* v0, uint32x4_t* v1, uint32x4_t* v2) { *r = vaddhn_high_u32(*v0, *v1, *v2); }
void VaddhnHighU64(uint32x4_t* r, uint32x2_t* v0, uint64x2_t* v1, uint64x2_t* v2) { *r = vaddhn_high_u64(*v0, *v1, *v2); }
void VaddhnHighU16(uint8x16_t* r, uint8x8_t* v0, uint16x8_t* v1, uint16x8_t* v2) { *r = vaddhn_high_u16(*v0, *v1, *v2); }
void VaddhnHighS32(int16x8_t* r, int16x4_t* v0, int32x4_t* v1, int32x4_t* v2) { *r = vaddhn_high_s32(*v0, *v1, *v2); }
void VaddhnHighS64(int32x4_t* r, int32x2_t* v0, int64x2_t* v1, int64x2_t* v2) { *r = vaddhn_high_s64(*v0, *v1, *v2); }
void VaddhnHighS16(int8x16_t* r, int8x8_t* v0, int16x8_t* v1, int16x8_t* v2) { *r = vaddhn_high_s16(*v0, *v1, *v2); }
void VaddlvqU8(uint16_t* r, uint8x16_t* v0) { *r = vaddlvq_u8(*v0); }
void VaddlvqU32(uint64_t* r, uint32x4_t* v0) { *r = vaddlvq_u32(*v0); }
void VaddlvqU16(uint32_t* r, uint16x8_t* v0) { *r = vaddlvq_u16(*v0); }
void VaddlvqS8(int16_t* r, int8x16_t* v0) { *r = vaddlvq_s8(*v0); }
void VaddlvqS32(int64_t* r, int32x4_t* v0) { *r = vaddlvq_s32(*v0); }
void VaddlvqS16(int32_t* r, int16x8_t* v0) { *r = vaddlvq_s16(*v0); }
void VaddlvU8(uint16_t* r, uint8x8_t* v0) { *r = vaddlv_u8(*v0); }
void VaddlvU32(uint64_t* r, uint32x2_t* v0) { *r = vaddlv_u32(*v0); }
void VaddlvU16(uint32_t* r, uint16x4_t* v0) { *r = vaddlv_u16(*v0); }
void VaddlvS8(int16_t* r, int8x8_t* v0) { *r = vaddlv_s8(*v0); }
void VaddlvS32(int64_t* r, int32x2_t* v0) { *r = vaddlv_s32(*v0); }
void VaddlvS16(int32_t* r, int16x4_t* v0) { *r = vaddlv_s16(*v0); }
void VaddvqU8(uint8_t* r, uint8x16_t* v0) { *r = vaddvq_u8(*v0); }
void VaddvqU32(uint32_t* r, uint32x4_t* v0) { *r = vaddvq_u32(*v0); }
void VaddvqU64(uint64_t* r, uint64x2_t* v0) { *r = vaddvq_u64(*v0); }
void VaddvqU16(uint16_t* r, uint16x8_t* v0) { *r = vaddvq_u16(*v0); }
void VaddvqS8(int8_t* r, int8x16_t* v0) { *r = vaddvq_s8(*v0); }
void VaddvqF64(float64_t* r, float64x2_t* v0) { *r = vaddvq_f64(*v0); }
void VaddvqF32(float32_t* r, float32x4_t* v0) { *r = vaddvq_f32(*v0); }
void VaddvqS32(int32_t* r, int32x4_t* v0) { *r = vaddvq_s32(*v0); }
void VaddvqS64(int64_t* r, int64x2_t* v0) { *r = vaddvq_s64(*v0); }
void VaddvqS16(int16_t* r, int16x8_t* v0) { *r = vaddvq_s16(*v0); }
void VaddvU8(uint8_t* r, uint8x8_t* v0) { *r = vaddv_u8(*v0); }
void VaddvU32(uint32_t* r, uint32x2_t* v0) { *r = vaddv_u32(*v0); }
void VaddvU16(uint16_t* r, uint16x4_t* v0) { *r = vaddv_u16(*v0); }
void VaddvS8(int8_t* r, int8x8_t* v0) { *r = vaddv_s8(*v0); }
void VaddvF32(float32_t* r, float32x2_t* v0) { *r = vaddv_f32(*v0); }
void VaddvS32(int32_t* r, int32x2_t* v0) { *r = vaddv_s32(*v0); }
void VaddvS16(int16_t* r, int16x4_t* v0) { *r = vaddv_s16(*v0); }
void VbslP64(poly64x1_t* r, uint64x1_t* v0, poly64x1_t* v1, poly64x1_t* v2) { *r = vbsl_p64(*v0, *v1, *v2); }
void VbslqP64(poly64x2_t* r, uint64x2_t* v0, poly64x2_t* v1, poly64x2_t* v2) { *r = vbslq_p64(*v0, *v1, *v2); }
void VbslqF64(float64x2_t* r, uint64x2_t* v0, float64x2_t* v1, float64x2_t* v2) { *r = vbslq_f64(*v0, *v1, *v2); }
void VbslF64(float64x1_t* r, uint64x1_t* v0, float64x1_t* v1, float64x1_t* v2) { *r = vbsl_f64(*v0, *v1, *v2); }
void VcageqF64(uint64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vcageq_f64(*v0, *v1); }
void VcageF64(uint64x1_t* r, float64x1_t* v0, float64x1_t* v1) { *r = vcage_f64(*v0, *v1); }
void VcagedF64(uint64_t* r, float64_t* v0, float64_t* v1) { *r = vcaged_f64(*v0, *v1); }
void VcagesF32(uint32_t* r, float32_t* v0, float32_t* v1) { *r = vcages_f32(*v0, *v1); }
void VcagtqF64(uint64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vcagtq_f64(*v0, *v1); }
void VcagtF64(uint64x1_t* r, float64x1_t* v0, float64x1_t* v1) { *r = vcagt_f64(*v0, *v1); }
void VcagtdF64(uint64_t* r, float64_t* v0, float64_t* v1) { *r = vcagtd_f64(*v0, *v1); }
void VcagtsF32(uint32_t* r, float32_t* v0, float32_t* v1) { *r = vcagts_f32(*v0, *v1); }
void VcaleqF64(uint64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vcaleq_f64(*v0, *v1); }
void VcaleF64(uint64x1_t* r, float64x1_t* v0, float64x1_t* v1) { *r = vcale_f64(*v0, *v1); }
void VcaledF64(uint64_t* r, float64_t* v0, float64_t* v1) { *r = vcaled_f64(*v0, *v1); }
void VcalesF32(uint32_t* r, float32_t* v0, float32_t* v1) { *r = vcales_f32(*v0, *v1); }
void VcaltqF64(uint64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vcaltq_f64(*v0, *v1); }
void VcaltF64(uint64x1_t* r, float64x1_t* v0, float64x1_t* v1) { *r = vcalt_f64(*v0, *v1); }
void VcaltdF64(uint64_t* r, float64_t* v0, float64_t* v1) { *r = vcaltd_f64(*v0, *v1); }
void VcaltsF32(uint32_t* r, float32_t* v0, float32_t* v1) { *r = vcalts_f32(*v0, *v1); }
void VceqP64(uint64x1_t* r, poly64x1_t* v0, poly64x1_t* v1) { *r = vceq_p64(*v0, *v1); }
void VceqqP64(uint64x2_t* r, poly64x2_t* v0, poly64x2_t* v1) { *r = vceqq_p64(*v0, *v1); }
void VceqqU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vceqq_u64(*v0, *v1); }
void VceqqF64(uint64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vceqq_f64(*v0, *v1); }
void VceqqS64(uint64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vceqq_s64(*v0, *v1); }
void VceqU64(uint64x1_t* r, uint64x1_t* v0, uint64x1_t* v1) { *r = vceq_u64(*v0, *v1); }
void VceqF64(uint64x1_t* r, float64x1_t* v0, float64x1_t* v1) { *r = vceq_f64(*v0, *v1); }
void VceqS64(uint64x1_t* r, int64x1_t* v0, int64x1_t* v1) { *r = vceq_s64(*v0, *v1); }
void VceqdU64(uint64_t* r, uint64_t* v0, uint64_t* v1) { *r = vceqd_u64(*v0, *v1); }
void VceqdS64(uint64_t* r, int64_t* v0, int64_t* v1) { *r = vceqd_s64(*v0, *v1); }
void VceqdF64(uint64_t* r, float64_t* v0, float64_t* v1) { *r = vceqd_f64(*v0, *v1); }
void VceqsF32(uint32_t* r, float32_t* v0, float32_t* v1) { *r = vceqs_f32(*v0, *v1); }
void VceqzP8(uint8x8_t* r, poly8x8_t* v0) { *r = vceqz_p8(*v0); }
void VceqzP64(uint64x1_t* r, poly64x1_t* v0) { *r = vceqz_p64(*v0); }
void VceqzqP8(uint8x16_t* r, poly8x16_t* v0) { *r = vceqzq_p8(*v0); }
void VceqzqP64(uint64x2_t* r, poly64x2_t* v0) { *r = vceqzq_p64(*v0); }
void VceqzqU8(uint8x16_t* r, uint8x16_t* v0) { *r = vceqzq_u8(*v0); }
void VceqzqU32(uint32x4_t* r, uint32x4_t* v0) { *r = vceqzq_u32(*v0); }
void VceqzqU64(uint64x2_t* r, uint64x2_t* v0) { *r = vceqzq_u64(*v0); }
void VceqzqU16(uint16x8_t* r, uint16x8_t* v0) { *r = vceqzq_u16(*v0); }
void VceqzqS8(uint8x16_t* r, int8x16_t* v0) { *r = vceqzq_s8(*v0); }
void VceqzqF64(uint64x2_t* r, float64x2_t* v0) { *r = vceqzq_f64(*v0); }
void VceqzqF32(uint32x4_t* r, float32x4_t* v0) { *r = vceqzq_f32(*v0); }
void VceqzqS32(uint32x4_t* r, int32x4_t* v0) { *r = vceqzq_s32(*v0); }
void VceqzqS64(uint64x2_t* r, int64x2_t* v0) { *r = vceqzq_s64(*v0); }
void VceqzqS16(uint16x8_t* r, int16x8_t* v0) { *r = vceqzq_s16(*v0); }
void VceqzU8(uint8x8_t* r, uint8x8_t* v0) { *r = vceqz_u8(*v0); }
void VceqzU32(uint32x2_t* r, uint32x2_t* v0) { *r = vceqz_u32(*v0); }
void VceqzU64(uint64x1_t* r, uint64x1_t* v0) { *r = vceqz_u64(*v0); }
void VceqzU16(uint16x4_t* r, uint16x4_t* v0) { *r = vceqz_u16(*v0); }
void VceqzS8(uint8x8_t* r, int8x8_t* v0) { *r = vceqz_s8(*v0); }
void VceqzF64(uint64x1_t* r, float64x1_t* v0) { *r = vceqz_f64(*v0); }
void VceqzF32(uint32x2_t* r, float32x2_t* v0) { *r = vceqz_f32(*v0); }
void VceqzS32(uint32x2_t* r, int32x2_t* v0) { *r = vceqz_s32(*v0); }
void VceqzS64(uint64x1_t* r, int64x1_t* v0) { *r = vceqz_s64(*v0); }
void VceqzS16(uint16x4_t* r, int16x4_t* v0) { *r = vceqz_s16(*v0); }
void VceqzdU64(uint64_t* r, uint64_t* v0) { *r = vceqzd_u64(*v0); }
void VceqzdS64(uint64_t* r, int64_t* v0) { *r = vceqzd_s64(*v0); }
void VceqzdF64(uint64_t* r, float64_t* v0) { *r = vceqzd_f64(*v0); }
void VceqzsF32(uint32_t* r, float32_t* v0) { *r = vceqzs_f32(*v0); }
void VcgeqU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vcgeq_u64(*v0, *v1); }
void VcgeqF64(uint64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vcgeq_f64(*v0, *v1); }
void VcgeqS64(uint64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vcgeq_s64(*v0, *v1); }
void VcgeU64(uint64x1_t* r, uint64x1_t* v0, uint64x1_t* v1) { *r = vcge_u64(*v0, *v1); }
void VcgeF64(uint64x1_t* r, float64x1_t* v0, float64x1_t* v1) { *r = vcge_f64(*v0, *v1); }
void VcgeS64(uint64x1_t* r, int64x1_t* v0, int64x1_t* v1) { *r = vcge_s64(*v0, *v1); }
void VcgedS64(uint64_t* r, int64_t* v0, int64_t* v1) { *r = vcged_s64(*v0, *v1); }
void VcgedU64(uint64_t* r, uint64_t* v0, uint64_t* v1) { *r = vcged_u64(*v0, *v1); }
void VcgedF64(uint64_t* r, float64_t* v0, float64_t* v1) { *r = vcged_f64(*v0, *v1); }
void VcgesF32(uint32_t* r, float32_t* v0, float32_t* v1) { *r = vcges_f32(*v0, *v1); }
void VcgezqS8(uint8x16_t* r, int8x16_t* v0) { *r = vcgezq_s8(*v0); }
void VcgezqF64(uint64x2_t* r, float64x2_t* v0) { *r = vcgezq_f64(*v0); }
void VcgezqF32(uint32x4_t* r, float32x4_t* v0) { *r = vcgezq_f32(*v0); }
void VcgezqS32(uint32x4_t* r, int32x4_t* v0) { *r = vcgezq_s32(*v0); }
void VcgezqS64(uint64x2_t* r, int64x2_t* v0) { *r = vcgezq_s64(*v0); }
void VcgezqS16(uint16x8_t* r, int16x8_t* v0) { *r = vcgezq_s16(*v0); }
void VcgezS8(uint8x8_t* r, int8x8_t* v0) { *r = vcgez_s8(*v0); }
void VcgezF64(uint64x1_t* r, float64x1_t* v0) { *r = vcgez_f64(*v0); }
void VcgezF32(uint32x2_t* r, float32x2_t* v0) { *r = vcgez_f32(*v0); }
void VcgezS32(uint32x2_t* r, int32x2_t* v0) { *r = vcgez_s32(*v0); }
void VcgezS64(uint64x1_t* r, int64x1_t* v0) { *r = vcgez_s64(*v0); }
void VcgezS16(uint16x4_t* r, int16x4_t* v0) { *r = vcgez_s16(*v0); }
void VcgezdS64(uint64_t* r, int64_t* v0) { *r = vcgezd_s64(*v0); }
void VcgezdF64(uint64_t* r, float64_t* v0) { *r = vcgezd_f64(*v0); }
void VcgezsF32(uint32_t* r, float32_t* v0) { *r = vcgezs_f32(*v0); }
void VcgtqU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vcgtq_u64(*v0, *v1); }
void VcgtqF64(uint64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vcgtq_f64(*v0, *v1); }
void VcgtqS64(uint64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vcgtq_s64(*v0, *v1); }
void VcgtU64(uint64x1_t* r, uint64x1_t* v0, uint64x1_t* v1) { *r = vcgt_u64(*v0, *v1); }
void VcgtF64(uint64x1_t* r, float64x1_t* v0, float64x1_t* v1) { *r = vcgt_f64(*v0, *v1); }
void VcgtS64(uint64x1_t* r, int64x1_t* v0, int64x1_t* v1) { *r = vcgt_s64(*v0, *v1); }
void VcgtdS64(uint64_t* r, int64_t* v0, int64_t* v1) { *r = vcgtd_s64(*v0, *v1); }
void VcgtdU64(uint64_t* r, uint64_t* v0, uint64_t* v1) { *r = vcgtd_u64(*v0, *v1); }
void VcgtdF64(uint64_t* r, float64_t* v0, float64_t* v1) { *r = vcgtd_f64(*v0, *v1); }
void VcgtsF32(uint32_t* r, float32_t* v0, float32_t* v1) { *r = vcgts_f32(*v0, *v1); }
void VcgtzqS8(uint8x16_t* r, int8x16_t* v0) { *r = vcgtzq_s8(*v0); }
void VcgtzqF64(uint64x2_t* r, float64x2_t* v0) { *r = vcgtzq_f64(*v0); }
void VcgtzqF32(uint32x4_t* r, float32x4_t* v0) { *r = vcgtzq_f32(*v0); }
void VcgtzqS32(uint32x4_t* r, int32x4_t* v0) { *r = vcgtzq_s32(*v0); }
void VcgtzqS64(uint64x2_t* r, int64x2_t* v0) { *r = vcgtzq_s64(*v0); }
void VcgtzqS16(uint16x8_t* r, int16x8_t* v0) { *r = vcgtzq_s16(*v0); }
void VcgtzS8(uint8x8_t* r, int8x8_t* v0) { *r = vcgtz_s8(*v0); }
void VcgtzF64(uint64x1_t* r, float64x1_t* v0) { *r = vcgtz_f64(*v0); }
void VcgtzF32(uint32x2_t* r, float32x2_t* v0) { *r = vcgtz_f32(*v0); }
void VcgtzS32(uint32x2_t* r, int32x2_t* v0) { *r = vcgtz_s32(*v0); }
void VcgtzS64(uint64x1_t* r, int64x1_t* v0) { *r = vcgtz_s64(*v0); }
void VcgtzS16(uint16x4_t* r, int16x4_t* v0) { *r = vcgtz_s16(*v0); }
void VcgtzdS64(uint64_t* r, int64_t* v0) { *r = vcgtzd_s64(*v0); }
void VcgtzdF64(uint64_t* r, float64_t* v0) { *r = vcgtzd_f64(*v0); }
void VcgtzsF32(uint32_t* r, float32_t* v0) { *r = vcgtzs_f32(*v0); }
void VcleqU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vcleq_u64(*v0, *v1); }
void VcleqF64(uint64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vcleq_f64(*v0, *v1); }
void VcleqS64(uint64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vcleq_s64(*v0, *v1); }
void VcleU64(uint64x1_t* r, uint64x1_t* v0, uint64x1_t* v1) { *r = vcle_u64(*v0, *v1); }
void VcleF64(uint64x1_t* r, float64x1_t* v0, float64x1_t* v1) { *r = vcle_f64(*v0, *v1); }
void VcleS64(uint64x1_t* r, int64x1_t* v0, int64x1_t* v1) { *r = vcle_s64(*v0, *v1); }
void VcledU64(uint64_t* r, uint64_t* v0, uint64_t* v1) { *r = vcled_u64(*v0, *v1); }
void VcledS64(uint64_t* r, int64_t* v0, int64_t* v1) { *r = vcled_s64(*v0, *v1); }
void VcledF64(uint64_t* r, float64_t* v0, float64_t* v1) { *r = vcled_f64(*v0, *v1); }
void VclesF32(uint32_t* r, float32_t* v0, float32_t* v1) { *r = vcles_f32(*v0, *v1); }
void VclezqS8(uint8x16_t* r, int8x16_t* v0) { *r = vclezq_s8(*v0); }
void VclezqF64(uint64x2_t* r, float64x2_t* v0) { *r = vclezq_f64(*v0); }
void VclezqF32(uint32x4_t* r, float32x4_t* v0) { *r = vclezq_f32(*v0); }
void VclezqS32(uint32x4_t* r, int32x4_t* v0) { *r = vclezq_s32(*v0); }
void VclezqS64(uint64x2_t* r, int64x2_t* v0) { *r = vclezq_s64(*v0); }
void VclezqS16(uint16x8_t* r, int16x8_t* v0) { *r = vclezq_s16(*v0); }
void VclezS8(uint8x8_t* r, int8x8_t* v0) { *r = vclez_s8(*v0); }
void VclezF64(uint64x1_t* r, float64x1_t* v0) { *r = vclez_f64(*v0); }
void VclezF32(uint32x2_t* r, float32x2_t* v0) { *r = vclez_f32(*v0); }
void VclezS32(uint32x2_t* r, int32x2_t* v0) { *r = vclez_s32(*v0); }
void VclezS64(uint64x1_t* r, int64x1_t* v0) { *r = vclez_s64(*v0); }
void VclezS16(uint16x4_t* r, int16x4_t* v0) { *r = vclez_s16(*v0); }
void VclezdS64(uint64_t* r, int64_t* v0) { *r = vclezd_s64(*v0); }
void VclezdF64(uint64_t* r, float64_t* v0) { *r = vclezd_f64(*v0); }
void VclezsF32(uint32_t* r, float32_t* v0) { *r = vclezs_f32(*v0); }
void VcltqU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vcltq_u64(*v0, *v1); }
void VcltqF64(uint64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vcltq_f64(*v0, *v1); }
void VcltqS64(uint64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vcltq_s64(*v0, *v1); }
void VcltU64(uint64x1_t* r, uint64x1_t* v0, uint64x1_t* v1) { *r = vclt_u64(*v0, *v1); }
void VcltF64(uint64x1_t* r, float64x1_t* v0, float64x1_t* v1) { *r = vclt_f64(*v0, *v1); }
void VcltS64(uint64x1_t* r, int64x1_t* v0, int64x1_t* v1) { *r = vclt_s64(*v0, *v1); }
void VcltdU64(uint64_t* r, uint64_t* v0, uint64_t* v1) { *r = vcltd_u64(*v0, *v1); }
void VcltdS64(uint64_t* r, int64_t* v0, int64_t* v1) { *r = vcltd_s64(*v0, *v1); }
void VcltdF64(uint64_t* r, float64_t* v0, float64_t* v1) { *r = vcltd_f64(*v0, *v1); }
void VcltsF32(uint32_t* r, float32_t* v0, float32_t* v1) { *r = vclts_f32(*v0, *v1); }
void VcltzqS8(uint8x16_t* r, int8x16_t* v0) { *r = vcltzq_s8(*v0); }
void VcltzqF64(uint64x2_t* r, float64x2_t* v0) { *r = vcltzq_f64(*v0); }
void VcltzqF32(uint32x4_t* r, float32x4_t* v0) { *r = vcltzq_f32(*v0); }
void VcltzqS32(uint32x4_t* r, int32x4_t* v0) { *r = vcltzq_s32(*v0); }
void VcltzqS64(uint64x2_t* r, int64x2_t* v0) { *r = vcltzq_s64(*v0); }
void VcltzqS16(uint16x8_t* r, int16x8_t* v0) { *r = vcltzq_s16(*v0); }
void VcltzS8(uint8x8_t* r, int8x8_t* v0) { *r = vcltz_s8(*v0); }
void VcltzF64(uint64x1_t* r, float64x1_t* v0) { *r = vcltz_f64(*v0); }
void VcltzF32(uint32x2_t* r, float32x2_t* v0) { *r = vcltz_f32(*v0); }
void VcltzS32(uint32x2_t* r, int32x2_t* v0) { *r = vcltz_s32(*v0); }
void VcltzS64(uint64x1_t* r, int64x1_t* v0) { *r = vcltz_s64(*v0); }
void VcltzS16(uint16x4_t* r, int16x4_t* v0) { *r = vcltz_s16(*v0); }
void VcltzdS64(uint64_t* r, int64_t* v0) { *r = vcltzd_s64(*v0); }
void VcltzdF64(uint64_t* r, float64_t* v0) { *r = vcltzd_f64(*v0); }
void VcltzsF32(uint32_t* r, float32_t* v0) { *r = vcltzs_f32(*v0); }
void VcombineP64(poly64x2_t* r, poly64x1_t* v0, poly64x1_t* v1) { *r = vcombine_p64(*v0, *v1); }
void VcombineF64(float64x2_t* r, float64x1_t* v0, float64x1_t* v1) { *r = vcombine_f64(*v0, *v1); }
void VcvtsF32S32(float32_t* r, int32_t* v0) { *r = vcvts_f32_s32(*v0); }
void VcvtsF32U32(float32_t* r, uint32_t* v0) { *r = vcvts_f32_u32(*v0); }
void VcvtF32F64(float32x2_t* r, float64x2_t* v0) { *r = vcvt_f32_f64(*v0); }
void VcvtdF64S64(float64_t* r, int64_t* v0) { *r = vcvtd_f64_s64(*v0); }
void VcvtdF64U64(float64_t* r, uint64_t* v0) { *r = vcvtd_f64_u64(*v0); }
void VcvtqF64U64(float64x2_t* r, uint64x2_t* v0) { *r = vcvtq_f64_u64(*v0); }
void VcvtqF64S64(float64x2_t* r, int64x2_t* v0) { *r = vcvtq_f64_s64(*v0); }
void VcvtF64U64(float64x1_t* r, uint64x1_t* v0) { *r = vcvt_f64_u64(*v0); }
void VcvtF64S64(float64x1_t* r, int64x1_t* v0) { *r = vcvt_f64_s64(*v0); }
void VcvtF64F32(float64x2_t* r, float32x2_t* v0) { *r = vcvt_f64_f32(*v0); }
void VcvtHighF32F64(float32x4_t* r, float32x2_t* v0, float64x2_t* v1) { *r = vcvt_high_f32_f64(*v0, *v1); }
void VcvtHighF64F32(float64x2_t* r, float32x4_t* v0) { *r = vcvt_high_f64_f32(*v0); }
void VcvtsS32F32(int32_t* r, float32_t* v0) { *r = vcvts_s32_f32(*v0); }
void VcvtdS64F64(int64_t* r, float64_t* v0) { *r = vcvtd_s64_f64(*v0); }
void VcvtqS64F64(int64x2_t* r, float64x2_t* v0) { *r = vcvtq_s64_f64(*v0); }
void VcvtS64F64(int64x1_t* r, float64x1_t* v0) { *r = vcvt_s64_f64(*v0); }
void VcvtsU32F32(uint32_t* r, float32_t* v0) { *r = vcvts_u32_f32(*v0); }
void VcvtdU64F64(uint64_t* r, float64_t* v0) { *r = vcvtd_u64_f64(*v0); }
void VcvtqU64F64(uint64x2_t* r, float64x2_t* v0) { *r = vcvtq_u64_f64(*v0); }
void VcvtU64F64(uint64x1_t* r, float64x1_t* v0) { *r = vcvt_u64_f64(*v0); }
void VcvtasS32F32(int32_t* r, float32_t* v0) { *r = vcvtas_s32_f32(*v0); }
void VcvtadS64F64(int64_t* r, float64_t* v0) { *r = vcvtad_s64_f64(*v0); }
void VcvtasU32F32(uint32_t* r, float32_t* v0) { *r = vcvtas_u32_f32(*v0); }
void VcvtadU64F64(uint64_t* r, float64_t* v0) { *r = vcvtad_u64_f64(*v0); }
void VcvtmsS32F32(int32_t* r, float32_t* v0) { *r = vcvtms_s32_f32(*v0); }
void VcvtmdS64F64(int64_t* r, float64_t* v0) { *r = vcvtmd_s64_f64(*v0); }
void VcvtmsU32F32(uint32_t* r, float32_t* v0) { *r = vcvtms_u32_f32(*v0); }
void VcvtmdU64F64(uint64_t* r, float64_t* v0) { *r = vcvtmd_u64_f64(*v0); }
void VcvtnsS32F32(int32_t* r, float32_t* v0) { *r = vcvtns_s32_f32(*v0); }
void VcvtndS64F64(int64_t* r, float64_t* v0) { *r = vcvtnd_s64_f64(*v0); }
void VcvtnsU32F32(uint32_t* r, float32_t* v0) { *r = vcvtns_u32_f32(*v0); }
void VcvtndU64F64(uint64_t* r, float64_t* v0) { *r = vcvtnd_u64_f64(*v0); }
void VcvtpsS32F32(int32_t* r, float32_t* v0) { *r = vcvtps_s32_f32(*v0); }
void VcvtpdS64F64(int64_t* r, float64_t* v0) { *r = vcvtpd_s64_f64(*v0); }
void VcvtpsU32F32(uint32_t* r, float32_t* v0) { *r = vcvtps_u32_f32(*v0); }
void VcvtpdU64F64(uint64_t* r, float64_t* v0) { *r = vcvtpd_u64_f64(*v0); }
void VcvtxdF32F64(float32_t* r, float64_t* v0) { *r = vcvtxd_f32_f64(*v0); }
void VcvtxF32F64(float32x2_t* r, float64x2_t* v0) { *r = vcvtx_f32_f64(*v0); }
void VcvtxHighF32F64(float32x4_t* r, float32x2_t* v0, float64x2_t* v1) { *r = vcvtx_high_f32_f64(*v0, *v1); }
void VdivqF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vdivq_f64(*v0, *v1); }
void VdivqF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vdivq_f32(*v0, *v1); }
void VdivF64(float64x1_t* r, float64x1_t* v0, float64x1_t* v1) { *r = vdiv_f64(*v0, *v1); }
void VdivF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vdiv_f32(*v0, *v1); }
void VdupNP64(poly64x1_t* r, poly64_t* v0) { *r = vdup_n_p64(*v0); }
void VdupqNP64(poly64x2_t* r, poly64_t* v0) { *r = vdupq_n_p64(*v0); }
void VdupqNF64(float64x2_t* r, float64_t* v0) { *r = vdupq_n_f64(*v0); }
void VdupNF64(float64x1_t* r, float64_t* v0) { *r = vdup_n_f64(*v0); }
void VfmaqF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1, float64x2_t* v2) { *r = vfmaq_f64(*v0, *v1, *v2); }
void VfmaF64(float64x1_t* r, float64x1_t* v0, float64x1_t* v1, float64x1_t* v2) { *r = vfma_f64(*v0, *v1, *v2); }
void VfmaqNF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1, float64_t* v2) { *r = vfmaq_n_f64(*v0, *v1, *v2); }
void VfmaNF64(float64x1_t* r, float64x1_t* v0, float64x1_t* v1, float64_t* v2) { *r = vfma_n_f64(*v0, *v1, *v2); }
void VfmsqF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1, float64x2_t* v2) { *r = vfmsq_f64(*v0, *v1, *v2); }
void VfmsF64(float64x1_t* r, float64x1_t* v0, float64x1_t* v1, float64x1_t* v2) { *r = vfms_f64(*v0, *v1, *v2); }
void VfmsqNF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1, float64_t* v2) { *r = vfmsq_n_f64(*v0, *v1, *v2); }
void VfmsqNF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1, float32_t* v2) { *r = vfmsq_n_f32(*v0, *v1, *v2); }
void VfmsNF64(float64x1_t* r, float64x1_t* v0, float64x1_t* v1, float64_t* v2) { *r = vfms_n_f64(*v0, *v1, *v2); }
void VfmsNF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1, float32_t* v2) { *r = vfms_n_f32(*v0, *v1, *v2); }
void VgetHighP64(poly64x1_t* r, poly64x2_t* v0) { *r = vget_high_p64(*v0); }
void VgetHighF64(float64x1_t* r, float64x2_t* v0) { *r = vget_high_f64(*v0); }
void VgetLowP64(poly64x1_t* r, poly64x2_t* v0) { *r = vget_low_p64(*v0); }
void VgetLowF64(float64x1_t* r, float64x2_t* v0) { *r = vget_low_f64(*v0); }
void VmaxqF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vmaxq_f64(*v0, *v1); }
void VmaxF64(float64x1_t* r, float64x1_t* v0, float64x1_t* v1) { *r = vmax_f64(*v0, *v1); }
void VmaxnmvqF64(float64_t* r, float64x2_t* v0) { *r = vmaxnmvq_f64(*v0); }
void VmaxnmvqF32(float32_t* r, float32x4_t* v0) { *r = vmaxnmvq_f32(*v0); }
void VmaxnmvF32(float32_t* r, float32x2_t* v0) { *r = vmaxnmv_f32(*v0); }
void VmaxvqU8(uint8_t* r, uint8x16_t* v0) { *r = vmaxvq_u8(*v0); }
void VmaxvqU32(uint32_t* r, uint32x4_t* v0) { *r = vmaxvq_u32(*v0); }
void VmaxvqU16(uint16_t* r, uint16x8_t* v0) { *r = vmaxvq_u16(*v0); }
void VmaxvqS8(int8_t* r, int8x16_t* v0) { *r = vmaxvq_s8(*v0); }
void VmaxvqF64(float64_t* r, float64x2_t* v0) { *r = vmaxvq_f64(*v0); }
void VmaxvqF32(float32_t* r, float32x4_t* v0) { *r = vmaxvq_f32(*v0); }
void VmaxvqS32(int32_t* r, int32x4_t* v0) { *r = vmaxvq_s32(*v0); }
void VmaxvqS16(int16_t* r, int16x8_t* v0) { *r = vmaxvq_s16(*v0); }
void VmaxvU8(uint8_t* r, uint8x8_t* v0) { *r = vmaxv_u8(*v0); }
void VmaxvU32(uint32_t* r, uint32x2_t* v0) { *r = vmaxv_u32(*v0); }
void VmaxvU16(uint16_t* r, uint16x4_t* v0) { *r = vmaxv_u16(*v0); }
void VmaxvS8(int8_t* r, int8x8_t* v0) { *r = vmaxv_s8(*v0); }
void VmaxvF32(float32_t* r, float32x2_t* v0) { *r = vmaxv_f32(*v0); }
void VmaxvS32(int32_t* r, int32x2_t* v0) { *r = vmaxv_s32(*v0); }
void VmaxvS16(int16_t* r, int16x4_t* v0) { *r = vmaxv_s16(*v0); }
void VminqF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vminq_f64(*v0, *v1); }
void VminF64(float64x1_t* r, float64x1_t* v0, float64x1_t* v1) { *r = vmin_f64(*v0, *v1); }
void VminnmvqF64(float64_t* r, float64x2_t* v0) { *r = vminnmvq_f64(*v0); }
void VminnmvqF32(float32_t* r, float32x4_t* v0) { *r = vminnmvq_f32(*v0); }
void VminnmvF32(float32_t* r, float32x2_t* v0) { *r = vminnmv_f32(*v0); }
void VminvqU8(uint8_t* r, uint8x16_t* v0) { *r = vminvq_u8(*v0); }
void VminvqU32(uint32_t* r, uint32x4_t* v0) { *r = vminvq_u32(*v0); }
void VminvqU16(uint16_t* r, uint16x8_t* v0) { *r = vminvq_u16(*v0); }
void VminvqS8(int8_t* r, int8x16_t* v0) { *r = vminvq_s8(*v0); }
void VminvqF64(float64_t* r, float64x2_t* v0) { *r = vminvq_f64(*v0); }
void VminvqF32(float32_t* r, float32x4_t* v0) { *r = vminvq_f32(*v0); }
void VminvqS32(int32_t* r, int32x4_t* v0) { *r = vminvq_s32(*v0); }
void VminvqS16(int16_t* r, int16x8_t* v0) { *r = vminvq_s16(*v0); }
void VminvU8(uint8_t* r, uint8x8_t* v0) { *r = vminv_u8(*v0); }
void VminvU32(uint32_t* r, uint32x2_t* v0) { *r = vminv_u32(*v0); }
void VminvU16(uint16_t* r, uint16x4_t* v0) { *r = vminv_u16(*v0); }
void VminvS8(int8_t* r, int8x8_t* v0) { *r = vminv_s8(*v0); }
void VminvF32(float32_t* r, float32x2_t* v0) { *r = vminv_f32(*v0); }
void VminvS32(int32_t* r, int32x2_t* v0) { *r = vminv_s32(*v0); }
void VminvS16(int16_t* r, int16x4_t* v0) { *r = vminv_s16(*v0); }
void VmlaqF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1, float64x2_t* v2) { *r = vmlaq_f64(*v0, *v1, *v2); }
void VmlaF64(float64x1_t* r, float64x1_t* v0, float64x1_t* v1, float64x1_t* v2) { *r = vmla_f64(*v0, *v1, *v2); }
void VmlsqF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1, float64x2_t* v2) { *r = vmlsq_f64(*v0, *v1, *v2); }
void VmlsF64(float64x1_t* r, float64x1_t* v0, float64x1_t* v1, float64x1_t* v2) { *r = vmls_f64(*v0, *v1, *v2); }
void VmovNP64(poly64x1_t* r, poly64_t* v0) { *r = vmov_n_p64(*v0); }
void VmovqNP64(poly64x2_t* r, poly64_t* v0) { *r = vmovq_n_p64(*v0); }
void VmovqNF64(float64x2_t* r, float64_t* v0) { *r = vmovq_n_f64(*v0); }
void VmovNF64(float64x1_t* r, float64_t* v0) { *r = vmov_n_f64(*v0); }
void VmovlHighU8(uint16x8_t* r, uint8x16_t* v0) { *r = vmovl_high_u8(*v0); }
void VmovlHighU32(uint64x2_t* r, uint32x4_t* v0) { *r = vmovl_high_u32(*v0); }
void VmovlHighU16(uint32x4_t* r, uint16x8_t* v0) { *r = vmovl_high_u16(*v0); }
void VmovlHighS8(int16x8_t* r, int8x16_t* v0) { *r = vmovl_high_s8(*v0); }
void VmovlHighS32(int64x2_t* r, int32x4_t* v0) { *r = vmovl_high_s32(*v0); }
void VmovlHighS16(int32x4_t* r, int16x8_t* v0) { *r = vmovl_high_s16(*v0); }
void VmovnHighU32(uint16x8_t* r, uint16x4_t* v0, uint32x4_t* v1) { *r = vmovn_high_u32(*v0, *v1); }
void VmovnHighU64(uint32x4_t* r, uint32x2_t* v0, uint64x2_t* v1) { *r = vmovn_high_u64(*v0, *v1); }
void VmovnHighU16(uint8x16_t* r, uint8x8_t* v0, uint16x8_t* v1) { *r = vmovn_high_u16(*v0, *v1); }
void VmovnHighS32(int16x8_t* r, int16x4_t* v0, int32x4_t* v1) { *r = vmovn_high_s32(*v0, *v1); }
void VmovnHighS64(int32x4_t* r, int32x2_t* v0, int64x2_t* v1) { *r = vmovn_high_s64(*v0, *v1); }
void VmovnHighS16(int8x16_t* r, int8x8_t* v0, int16x8_t* v1) { *r = vmovn_high_s16(*v0, *v1); }
void VmulqF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vmulq_f64(*v0, *v1); }
void VmulF64(float64x1_t* r, float64x1_t* v0, float64x1_t* v1) { *r = vmul_f64(*v0, *v1); }
void VmulNF64(float64x1_t* r, float64x1_t* v0, float64_t* v1) { *r = vmul_n_f64(*v0, *v1); }
void VmulqNF64(float64x2_t* r, float64x2_t* v0, float64_t* v1) { *r = vmulq_n_f64(*v0, *v1); }
void VmullP64(poly128_t* r, poly64_t* v0, poly64_t* v1) { *r = vmull_p64(*v0, *v1); }
void VmullHighP8(poly16x8_t* r, poly8x16_t* v0, poly8x16_t* v1) { *r = vmull_high_p8(*v0, *v1); }
void VmullHighU8(uint16x8_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vmull_high_u8(*v0, *v1); }
void VmullHighU32(uint64x2_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vmull_high_u32(*v0, *v1); }
void VmullHighU16(uint32x4_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vmull_high_u16(*v0, *v1); }
void VmullHighS8(int16x8_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vmull_high_s8(*v0, *v1); }
void VmullHighS32(int64x2_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vmull_high_s32(*v0, *v1); }
void VmullHighS16(int32x4_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vmull_high_s16(*v0, *v1); }
void VmullHighP64(poly128_t* r, poly64x2_t* v0, poly64x2_t* v1) { *r = vmull_high_p64(*v0, *v1); }
void VmullHighNU32(uint64x2_t* r, uint32x4_t* v0, uint32_t* v1) { *r = vmull_high_n_u32(*v0, *v1); }
void VmullHighNU16(uint32x4_t* r, uint16x8_t* v0, uint16_t* v1) { *r = vmull_high_n_u16(*v0, *v1); }
void VmullHighNS32(int64x2_t* r, int32x4_t* v0, int32_t* v1) { *r = vmull_high_n_s32(*v0, *v1); }
void VmullHighNS16(int32x4_t* r, int16x8_t* v0, int16_t* v1) { *r = vmull_high_n_s16(*v0, *v1); }
void VmulxqF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vmulxq_f64(*v0, *v1); }
void VmulxqF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vmulxq_f32(*v0, *v1); }
void VmulxF64(float64x1_t* r, float64x1_t* v0, float64x1_t* v1) { *r = vmulx_f64(*v0, *v1); }
void VmulxF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vmulx_f32(*v0, *v1); }
void VmulxdF64(float64_t* r, float64_t* v0, float64_t* v1) { *r = vmulxd_f64(*v0, *v1); }
void VmulxsF32(float32_t* r, float32_t* v0, float32_t* v1) { *r = vmulxs_f32(*v0, *v1); }
void VnegqF64(float64x2_t* r, float64x2_t* v0) { *r = vnegq_f64(*v0); }
void VnegqS64(int64x2_t* r, int64x2_t* v0) { *r = vnegq_s64(*v0); }
void VnegF64(float64x1_t* r, float64x1_t* v0) { *r = vneg_f64(*v0); }
void VnegS64(int64x1_t* r, int64x1_t* v0) { *r = vneg_s64(*v0); }
void VnegdS64(int64_t* r, int64_t* v0) { *r = vnegd_s64(*v0); }
void VpaddqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vpaddq_u8(*v0, *v1); }
void VpaddqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vpaddq_u32(*v0, *v1); }
void VpaddqU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vpaddq_u64(*v0, *v1); }
void VpaddqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vpaddq_u16(*v0, *v1); }
void VpaddqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vpaddq_s8(*v0, *v1); }
void VpaddqF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vpaddq_f64(*v0, *v1); }
void VpaddqF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vpaddq_f32(*v0, *v1); }
void VpaddqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vpaddq_s32(*v0, *v1); }
void VpaddqS64(int64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vpaddq_s64(*v0, *v1); }
void VpaddqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vpaddq_s16(*v0, *v1); }
void VpadddU64(uint64_t* r, uint64x2_t* v0) { *r = vpaddd_u64(*v0); }
void VpadddF64(float64_t* r, float64x2_t* v0) { *r = vpaddd_f64(*v0); }
void VpadddS64(int64_t* r, int64x2_t* v0) { *r = vpaddd_s64(*v0); }
void VpaddsF32(float32_t* r, float32x2_t* v0) { *r = vpadds_f32(*v0); }
void VpmaxqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vpmaxq_u8(*v0, *v1); }
void VpmaxqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vpmaxq_u32(*v0, *v1); }
void VpmaxqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vpmaxq_u16(*v0, *v1); }
void VpmaxqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vpmaxq_s8(*v0, *v1); }
void VpmaxqF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vpmaxq_f64(*v0, *v1); }
void VpmaxqF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vpmaxq_f32(*v0, *v1); }
void VpmaxqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vpmaxq_s32(*v0, *v1); }
void VpmaxqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vpmaxq_s16(*v0, *v1); }
void VpmaxqdF64(float64_t* r, float64x2_t* v0) { *r = vpmaxqd_f64(*v0); }
void VpmaxsF32(float32_t* r, float32x2_t* v0) { *r = vpmaxs_f32(*v0); }
void VpmaxnmqF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vpmaxnmq_f64(*v0, *v1); }
void VpmaxnmqF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vpmaxnmq_f32(*v0, *v1); }
void VpmaxnmF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vpmaxnm_f32(*v0, *v1); }
void VpmaxnmqdF64(float64_t* r, float64x2_t* v0) { *r = vpmaxnmqd_f64(*v0); }
void VpmaxnmsF32(float32_t* r, float32x2_t* v0) { *r = vpmaxnms_f32(*v0); }
void VpminqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vpminq_u8(*v0, *v1); }
void VpminqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vpminq_u32(*v0, *v1); }
void VpminqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vpminq_u16(*v0, *v1); }
void VpminqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vpminq_s8(*v0, *v1); }
void VpminqF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vpminq_f64(*v0, *v1); }
void VpminqF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vpminq_f32(*v0, *v1); }
void VpminqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vpminq_s32(*v0, *v1); }
void VpminqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vpminq_s16(*v0, *v1); }
void VpminqdF64(float64_t* r, float64x2_t* v0) { *r = vpminqd_f64(*v0); }
void VpminsF32(float32_t* r, float32x2_t* v0) { *r = vpmins_f32(*v0); }
void VpminnmqF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vpminnmq_f64(*v0, *v1); }
void VpminnmqF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vpminnmq_f32(*v0, *v1); }
void VpminnmF32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vpminnm_f32(*v0, *v1); }
void VpminnmqdF64(float64_t* r, float64x2_t* v0) { *r = vpminnmqd_f64(*v0); }
void VpminnmsF32(float32_t* r, float32x2_t* v0) { *r = vpminnms_f32(*v0); }
void VqabsqS64(int64x2_t* r, int64x2_t* v0) { *r = vqabsq_s64(*v0); }
void VqabsS64(int64x1_t* r, int64x1_t* v0) { *r = vqabs_s64(*v0); }
void VqabsbS8(int8_t* r, int8_t* v0) { *r = vqabsb_s8(*v0); }
void VqabssS32(int32_t* r, int32_t* v0) { *r = vqabss_s32(*v0); }
void VqabsdS64(int64_t* r, int64_t* v0) { *r = vqabsd_s64(*v0); }
void VqabshS16(int16_t* r, int16_t* v0) { *r = vqabsh_s16(*v0); }
void VqaddbU8(uint8_t* r, uint8_t* v0, uint8_t* v1) { *r = vqaddb_u8(*v0, *v1); }
void VqaddsU32(uint32_t* r, uint32_t* v0, uint32_t* v1) { *r = vqadds_u32(*v0, *v1); }
void VqadddU64(uint64_t* r, uint64_t* v0, uint64_t* v1) { *r = vqaddd_u64(*v0, *v1); }
void VqaddhU16(uint16_t* r, uint16_t* v0, uint16_t* v1) { *r = vqaddh_u16(*v0, *v1); }
void VqaddbS8(int8_t* r, int8_t* v0, int8_t* v1) { *r = vqaddb_s8(*v0, *v1); }
void VqaddsS32(int32_t* r, int32_t* v0, int32_t* v1) { *r = vqadds_s32(*v0, *v1); }
void VqadddS64(int64_t* r, int64_t* v0, int64_t* v1) { *r = vqaddd_s64(*v0, *v1); }
void VqaddhS16(int16_t* r, int16_t* v0, int16_t* v1) { *r = vqaddh_s16(*v0, *v1); }
void VqdmlalsS32(int64_t* r, int64_t* v0, int32_t* v1, int32_t* v2) { *r = vqdmlals_s32(*v0, *v1, *v2); }
void VqdmlalhS16(int32_t* r, int32_t* v0, int16_t* v1, int16_t* v2) { *r = vqdmlalh_s16(*v0, *v1, *v2); }
void VqdmlalHighS32(int64x2_t* r, int64x2_t* v0, int32x4_t* v1, int32x4_t* v2) { *r = vqdmlal_high_s32(*v0, *v1, *v2); }
void VqdmlalHighS16(int32x4_t* r, int32x4_t* v0, int16x8_t* v1, int16x8_t* v2) { *r = vqdmlal_high_s16(*v0, *v1, *v2); }
void VqdmlalHighNS32(int64x2_t* r, int64x2_t* v0, int32x4_t* v1, int32_t* v2) { *r = vqdmlal_high_n_s32(*v0, *v1, *v2); }
void VqdmlalHighNS16(int32x4_t* r, int32x4_t* v0, int16x8_t* v1, int16_t* v2) { *r = vqdmlal_high_n_s16(*v0, *v1, *v2); }
void VqdmlslsS32(int64_t* r, int64_t* v0, int32_t* v1, int32_t* v2) { *r = vqdmlsls_s32(*v0, *v1, *v2); }
void VqdmlslhS16(int32_t* r, int32_t* v0, int16_t* v1, int16_t* v2) { *r = vqdmlslh_s16(*v0, *v1, *v2); }
void VqdmlslHighS32(int64x2_t* r, int64x2_t* v0, int32x4_t* v1, int32x4_t* v2) { *r = vqdmlsl_high_s32(*v0, *v1, *v2); }
void VqdmlslHighS16(int32x4_t* r, int32x4_t* v0, int16x8_t* v1, int16x8_t* v2) { *r = vqdmlsl_high_s16(*v0, *v1, *v2); }
void VqdmlslHighNS32(int64x2_t* r, int64x2_t* v0, int32x4_t* v1, int32_t* v2) { *r = vqdmlsl_high_n_s32(*v0, *v1, *v2); }
void VqdmlslHighNS16(int32x4_t* r, int32x4_t* v0, int16x8_t* v1, int16_t* v2) { *r = vqdmlsl_high_n_s16(*v0, *v1, *v2); }
void VqdmulhsS32(int32_t* r, int32_t* v0, int32_t* v1) { *r = vqdmulhs_s32(*v0, *v1); }
void VqdmulhhS16(int16_t* r, int16_t* v0, int16_t* v1) { *r = vqdmulhh_s16(*v0, *v1); }
void VqdmullsS32(int64_t* r, int32_t* v0, int32_t* v1) { *r = vqdmulls_s32(*v0, *v1); }
void VqdmullhS16(int32_t* r, int16_t* v0, int16_t* v1) { *r = vqdmullh_s16(*v0, *v1); }
void VqdmullHighS32(int64x2_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vqdmull_high_s32(*v0, *v1); }
void VqdmullHighS16(int32x4_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vqdmull_high_s16(*v0, *v1); }
void VqdmullHighNS32(int64x2_t* r, int32x4_t* v0, int32_t* v1) { *r = vqdmull_high_n_s32(*v0, *v1); }
void VqdmullHighNS16(int32x4_t* r, int16x8_t* v0, int16_t* v1) { *r = vqdmull_high_n_s16(*v0, *v1); }
void VqmovnsS32(int16_t* r, int32_t* v0) { *r = vqmovns_s32(*v0); }
void VqmovndS64(int32_t* r, int64_t* v0) { *r = vqmovnd_s64(*v0); }
void VqmovnhS16(int8_t* r, int16_t* v0) { *r = vqmovnh_s16(*v0); }
void VqmovnsU32(uint16_t* r, uint32_t* v0) { *r = vqmovns_u32(*v0); }
void VqmovndU64(uint32_t* r, uint64_t* v0) { *r = vqmovnd_u64(*v0); }
void VqmovnhU16(uint8_t* r, uint16_t* v0) { *r = vqmovnh_u16(*v0); }
void VqmovnHighU32(uint16x8_t* r, uint16x4_t* v0, uint32x4_t* v1) { *r = vqmovn_high_u32(*v0, *v1); }
void VqmovnHighU64(uint32x4_t* r, uint32x2_t* v0, uint64x2_t* v1) { *r = vqmovn_high_u64(*v0, *v1); }
void VqmovnHighU16(uint8x16_t* r, uint8x8_t* v0, uint16x8_t* v1) { *r = vqmovn_high_u16(*v0, *v1); }
void VqmovnHighS32(int16x8_t* r, int16x4_t* v0, int32x4_t* v1) { *r = vqmovn_high_s32(*v0, *v1); }
void VqmovnHighS64(int32x4_t* r, int32x2_t* v0, int64x2_t* v1) { *r = vqmovn_high_s64(*v0, *v1); }
void VqmovnHighS16(int8x16_t* r, int8x8_t* v0, int16x8_t* v1) { *r = vqmovn_high_s16(*v0, *v1); }
void VqmovunsS32(uint16_t* r, int32_t* v0) { *r = vqmovuns_s32(*v0); }
void VqmovundS64(uint32_t* r, int64_t* v0) { *r = vqmovund_s64(*v0); }
void VqmovunhS16(uint8_t* r, int16_t* v0) { *r = vqmovunh_s16(*v0); }
void VqmovunHighS32(uint16x8_t* r, uint16x4_t* v0, int32x4_t* v1) { *r = vqmovun_high_s32(*v0, *v1); }
void VqmovunHighS64(uint32x4_t* r, uint32x2_t* v0, int64x2_t* v1) { *r = vqmovun_high_s64(*v0, *v1); }
void VqmovunHighS16(uint8x16_t* r, uint8x8_t* v0, int16x8_t* v1) { *r = vqmovun_high_s16(*v0, *v1); }
void VqnegqS64(int64x2_t* r, int64x2_t* v0) { *r = vqnegq_s64(*v0); }
void VqnegS64(int64x1_t* r, int64x1_t* v0) { *r = vqneg_s64(*v0); }
void VqnegbS8(int8_t* r, int8_t* v0) { *r = vqnegb_s8(*v0); }
void VqnegsS32(int32_t* r, int32_t* v0) { *r = vqnegs_s32(*v0); }
void VqnegdS64(int64_t* r, int64_t* v0) { *r = vqnegd_s64(*v0); }
void VqneghS16(int16_t* r, int16_t* v0) { *r = vqnegh_s16(*v0); }
void VqrdmulhsS32(int32_t* r, int32_t* v0, int32_t* v1) { *r = vqrdmulhs_s32(*v0, *v1); }
void VqrdmulhhS16(int16_t* r, int16_t* v0, int16_t* v1) { *r = vqrdmulhh_s16(*v0, *v1); }
void VqrshlbU8(uint8_t* r, uint8_t* v0, int8_t* v1) { *r = vqrshlb_u8(*v0, *v1); }
void VqrshlsU32(uint32_t* r, uint32_t* v0, int32_t* v1) { *r = vqrshls_u32(*v0, *v1); }
void VqrshldU64(uint64_t* r, uint64_t* v0, int64_t* v1) { *r = vqrshld_u64(*v0, *v1); }
void VqrshlhU16(uint16_t* r, uint16_t* v0, int16_t* v1) { *r = vqrshlh_u16(*v0, *v1); }
void VqrshlbS8(int8_t* r, int8_t* v0, int8_t* v1) { *r = vqrshlb_s8(*v0, *v1); }
void VqrshlsS32(int32_t* r, int32_t* v0, int32_t* v1) { *r = vqrshls_s32(*v0, *v1); }
void VqrshldS64(int64_t* r, int64_t* v0, int64_t* v1) { *r = vqrshld_s64(*v0, *v1); }
void VqrshlhS16(int16_t* r, int16_t* v0, int16_t* v1) { *r = vqrshlh_s16(*v0, *v1); }
void VqshlbU8(uint8_t* r, uint8_t* v0, int8_t* v1) { *r = vqshlb_u8(*v0, *v1); }
void VqshlsU32(uint32_t* r, uint32_t* v0, int32_t* v1) { *r = vqshls_u32(*v0, *v1); }
void VqshldU64(uint64_t* r, uint64_t* v0, int64_t* v1) { *r = vqshld_u64(*v0, *v1); }
void VqshlhU16(uint16_t* r, uint16_t* v0, int16_t* v1) { *r = vqshlh_u16(*v0, *v1); }
void VqshlbS8(int8_t* r, int8_t* v0, int8_t* v1) { *r = vqshlb_s8(*v0, *v1); }
void VqshlsS32(int32_t* r, int32_t* v0, int32_t* v1) { *r = vqshls_s32(*v0, *v1); }
void VqshldS64(int64_t* r, int64_t* v0, int64_t* v1) { *r = vqshld_s64(*v0, *v1); }
void VqshlhS16(int16_t* r, int16_t* v0, int16_t* v1) { *r = vqshlh_s16(*v0, *v1); }
void VqsubbU8(uint8_t* r, uint8_t* v0, uint8_t* v1) { *r = vqsubb_u8(*v0, *v1); }
void VqsubsU32(uint32_t* r, uint32_t* v0, uint32_t* v1) { *r = vqsubs_u32(*v0, *v1); }
void VqsubdU64(uint64_t* r, uint64_t* v0, uint64_t* v1) { *r = vqsubd_u64(*v0, *v1); }
void VqsubhU16(uint16_t* r, uint16_t* v0, uint16_t* v1) { *r = vqsubh_u16(*v0, *v1); }
void VqsubbS8(int8_t* r, int8_t* v0, int8_t* v1) { *r = vqsubb_s8(*v0, *v1); }
void VqsubsS32(int32_t* r, int32_t* v0, int32_t* v1) { *r = vqsubs_s32(*v0, *v1); }
void VqsubdS64(int64_t* r, int64_t* v0, int64_t* v1) { *r = vqsubd_s64(*v0, *v1); }
void VqsubhS16(int16_t* r, int16_t* v0, int16_t* v1) { *r = vqsubh_s16(*v0, *v1); }
void Vqtbl1P8(poly8x8_t* r, poly8x16_t* v0, uint8x8_t* v1) { *r = vqtbl1_p8(*v0, *v1); }
void Vqtbl1QP8(poly8x16_t* r, poly8x16_t* v0, uint8x16_t* v1) { *r = vqtbl1q_p8(*v0, *v1); }
void Vqtbl1QU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vqtbl1q_u8(*v0, *v1); }
void Vqtbl1QS8(int8x16_t* r, int8x16_t* v0, uint8x16_t* v1) { *r = vqtbl1q_s8(*v0, *v1); }
void Vqtbl1U8(uint8x8_t* r, uint8x16_t* v0, uint8x8_t* v1) { *r = vqtbl1_u8(*v0, *v1); }
void Vqtbl1S8(int8x8_t* r, int8x16_t* v0, uint8x8_t* v1) { *r = vqtbl1_s8(*v0, *v1); }
void Vqtbl2P8(poly8x8_t* r, poly8x16x2_t* v0, uint8x8_t* v1) { *r = vqtbl2_p8(*v0, *v1); }
void Vqtbl2QP8(poly8x16_t* r, poly8x16x2_t* v0, uint8x16_t* v1) { *r = vqtbl2q_p8(*v0, *v1); }
void Vqtbl2QU8(uint8x16_t* r, uint8x16x2_t* v0, uint8x16_t* v1) { *r = vqtbl2q_u8(*v0, *v1); }
void Vqtbl2QS8(int8x16_t* r, int8x16x2_t* v0, uint8x16_t* v1) { *r = vqtbl2q_s8(*v0, *v1); }
void Vqtbl2U8(uint8x8_t* r, uint8x16x2_t* v0, uint8x8_t* v1) { *r = vqtbl2_u8(*v0, *v1); }
void Vqtbl2S8(int8x8_t* r, int8x16x2_t* v0, uint8x8_t* v1) { *r = vqtbl2_s8(*v0, *v1); }
void Vqtbl3P8(poly8x8_t* r, poly8x16x3_t* v0, uint8x8_t* v1) { *r = vqtbl3_p8(*v0, *v1); }
void Vqtbl3QP8(poly8x16_t* r, poly8x16x3_t* v0, uint8x16_t* v1) { *r = vqtbl3q_p8(*v0, *v1); }
void Vqtbl3QU8(uint8x16_t* r, uint8x16x3_t* v0, uint8x16_t* v1) { *r = vqtbl3q_u8(*v0, *v1); }
void Vqtbl3QS8(int8x16_t* r, int8x16x3_t* v0, uint8x16_t* v1) { *r = vqtbl3q_s8(*v0, *v1); }
void Vqtbl3U8(uint8x8_t* r, uint8x16x3_t* v0, uint8x8_t* v1) { *r = vqtbl3_u8(*v0, *v1); }
void Vqtbl3S8(int8x8_t* r, int8x16x3_t* v0, uint8x8_t* v1) { *r = vqtbl3_s8(*v0, *v1); }
void Vqtbl4P8(poly8x8_t* r, poly8x16x4_t* v0, uint8x8_t* v1) { *r = vqtbl4_p8(*v0, *v1); }
void Vqtbl4QP8(poly8x16_t* r, poly8x16x4_t* v0, uint8x16_t* v1) { *r = vqtbl4q_p8(*v0, *v1); }
void Vqtbl4QU8(uint8x16_t* r, uint8x16x4_t* v0, uint8x16_t* v1) { *r = vqtbl4q_u8(*v0, *v1); }
void Vqtbl4QS8(int8x16_t* r, int8x16x4_t* v0, uint8x16_t* v1) { *r = vqtbl4q_s8(*v0, *v1); }
void Vqtbl4U8(uint8x8_t* r, uint8x16x4_t* v0, uint8x8_t* v1) { *r = vqtbl4_u8(*v0, *v1); }
void Vqtbl4S8(int8x8_t* r, int8x16x4_t* v0, uint8x8_t* v1) { *r = vqtbl4_s8(*v0, *v1); }
void Vqtbx1P8(poly8x8_t* r, poly8x8_t* v0, poly8x16_t* v1, uint8x8_t* v2) { *r = vqtbx1_p8(*v0, *v1, *v2); }
void Vqtbx1QP8(poly8x16_t* r, poly8x16_t* v0, poly8x16_t* v1, uint8x16_t* v2) { *r = vqtbx1q_p8(*v0, *v1, *v2); }
void Vqtbx1QU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1, uint8x16_t* v2) { *r = vqtbx1q_u8(*v0, *v1, *v2); }
void Vqtbx1QS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1, uint8x16_t* v2) { *r = vqtbx1q_s8(*v0, *v1, *v2); }
void Vqtbx1U8(uint8x8_t* r, uint8x8_t* v0, uint8x16_t* v1, uint8x8_t* v2) { *r = vqtbx1_u8(*v0, *v1, *v2); }
void Vqtbx1S8(int8x8_t* r, int8x8_t* v0, int8x16_t* v1, uint8x8_t* v2) { *r = vqtbx1_s8(*v0, *v1, *v2); }
void Vqtbx2P8(poly8x8_t* r, poly8x8_t* v0, poly8x16x2_t* v1, uint8x8_t* v2) { *r = vqtbx2_p8(*v0, *v1, *v2); }
void Vqtbx2QP8(poly8x16_t* r, poly8x16_t* v0, poly8x16x2_t* v1, uint8x16_t* v2) { *r = vqtbx2q_p8(*v0, *v1, *v2); }
void Vqtbx2QU8(uint8x16_t* r, uint8x16_t* v0, uint8x16x2_t* v1, uint8x16_t* v2) { *r = vqtbx2q_u8(*v0, *v1, *v2); }
void Vqtbx2QS8(int8x16_t* r, int8x16_t* v0, int8x16x2_t* v1, uint8x16_t* v2) { *r = vqtbx2q_s8(*v0, *v1, *v2); }
void Vqtbx2U8(uint8x8_t* r, uint8x8_t* v0, uint8x16x2_t* v1, uint8x8_t* v2) { *r = vqtbx2_u8(*v0, *v1, *v2); }
void Vqtbx2S8(int8x8_t* r, int8x8_t* v0, int8x16x2_t* v1, uint8x8_t* v2) { *r = vqtbx2_s8(*v0, *v1, *v2); }
void Vqtbx3P8(poly8x8_t* r, poly8x8_t* v0, poly8x16x3_t* v1, uint8x8_t* v2) { *r = vqtbx3_p8(*v0, *v1, *v2); }
void Vqtbx3QP8(poly8x16_t* r, poly8x16_t* v0, poly8x16x3_t* v1, uint8x16_t* v2) { *r = vqtbx3q_p8(*v0, *v1, *v2); }
void Vqtbx3QU8(uint8x16_t* r, uint8x16_t* v0, uint8x16x3_t* v1, uint8x16_t* v2) { *r = vqtbx3q_u8(*v0, *v1, *v2); }
void Vqtbx3QS8(int8x16_t* r, int8x16_t* v0, int8x16x3_t* v1, uint8x16_t* v2) { *r = vqtbx3q_s8(*v0, *v1, *v2); }
void Vqtbx3U8(uint8x8_t* r, uint8x8_t* v0, uint8x16x3_t* v1, uint8x8_t* v2) { *r = vqtbx3_u8(*v0, *v1, *v2); }
void Vqtbx3S8(int8x8_t* r, int8x8_t* v0, int8x16x3_t* v1, uint8x8_t* v2) { *r = vqtbx3_s8(*v0, *v1, *v2); }
void Vqtbx4P8(poly8x8_t* r, poly8x8_t* v0, poly8x16x4_t* v1, uint8x8_t* v2) { *r = vqtbx4_p8(*v0, *v1, *v2); }
void Vqtbx4QP8(poly8x16_t* r, poly8x16_t* v0, poly8x16x4_t* v1, uint8x16_t* v2) { *r = vqtbx4q_p8(*v0, *v1, *v2); }
void Vqtbx4QU8(uint8x16_t* r, uint8x16_t* v0, uint8x16x4_t* v1, uint8x16_t* v2) { *r = vqtbx4q_u8(*v0, *v1, *v2); }
void Vqtbx4QS8(int8x16_t* r, int8x16_t* v0, int8x16x4_t* v1, uint8x16_t* v2) { *r = vqtbx4q_s8(*v0, *v1, *v2); }
void Vqtbx4U8(uint8x8_t* r, uint8x8_t* v0, uint8x16x4_t* v1, uint8x8_t* v2) { *r = vqtbx4_u8(*v0, *v1, *v2); }
void Vqtbx4S8(int8x8_t* r, int8x8_t* v0, int8x16x4_t* v1, uint8x8_t* v2) { *r = vqtbx4_s8(*v0, *v1, *v2); }
void VraddhnHighU32(uint16x8_t* r, uint16x4_t* v0, uint32x4_t* v1, uint32x4_t* v2) { *r = vraddhn_high_u32(*v0, *v1, *v2); }
void VraddhnHighU64(uint32x4_t* r, uint32x2_t* v0, uint64x2_t* v1, uint64x2_t* v2) { *r = vraddhn_high_u64(*v0, *v1, *v2); }
void VraddhnHighU16(uint8x16_t* r, uint8x8_t* v0, uint16x8_t* v1, uint16x8_t* v2) { *r = vraddhn_high_u16(*v0, *v1, *v2); }
void VraddhnHighS32(int16x8_t* r, int16x4_t* v0, int32x4_t* v1, int32x4_t* v2) { *r = vraddhn_high_s32(*v0, *v1, *v2); }
void VraddhnHighS64(int32x4_t* r, int32x2_t* v0, int64x2_t* v1, int64x2_t* v2) { *r = vraddhn_high_s64(*v0, *v1, *v2); }
void VraddhnHighS16(int8x16_t* r, int8x8_t* v0, int16x8_t* v1, int16x8_t* v2) { *r = vraddhn_high_s16(*v0, *v1, *v2); }
void VrbitP8(poly8x8_t* r, poly8x8_t* v0) { *r = vrbit_p8(*v0); }
void VrbitqP8(poly8x16_t* r, poly8x16_t* v0) { *r = vrbitq_p8(*v0); }
void VrbitqU8(uint8x16_t* r, uint8x16_t* v0) { *r = vrbitq_u8(*v0); }
void VrbitqS8(int8x16_t* r, int8x16_t* v0) { *r = vrbitq_s8(*v0); }
void VrbitU8(uint8x8_t* r, uint8x8_t* v0) { *r = vrbit_u8(*v0); }
void VrbitS8(int8x8_t* r, int8x8_t* v0) { *r = vrbit_s8(*v0); }
void VrecpeqF64(float64x2_t* r, float64x2_t* v0) { *r = vrecpeq_f64(*v0); }
void VrecpeF64(float64x1_t* r, float64x1_t* v0) { *r = vrecpe_f64(*v0); }
void VrecpedF64(float64_t* r, float64_t* v0) { *r = vrecped_f64(*v0); }
void VrecpesF32(float32_t* r, float32_t* v0) { *r = vrecpes_f32(*v0); }
void VrecpsqF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vrecpsq_f64(*v0, *v1); }
void VrecpsF64(float64x1_t* r, float64x1_t* v0, float64x1_t* v1) { *r = vrecps_f64(*v0, *v1); }
void VrecpsdF64(float64_t* r, float64_t* v0, float64_t* v1) { *r = vrecpsd_f64(*v0, *v1); }
void VrecpssF32(float32_t* r, float32_t* v0, float32_t* v1) { *r = vrecpss_f32(*v0, *v1); }
void VrecpxdF64(float64_t* r, float64_t* v0) { *r = vrecpxd_f64(*v0); }
void VrecpxsF32(float32_t* r, float32_t* v0) { *r = vrecpxs_f32(*v0); }
void VrshldU64(uint64_t* r, uint64_t* v0, int64_t* v1) { *r = vrshld_u64(*v0, *v1); }
void VrshldS64(int64_t* r, int64_t* v0, int64_t* v1) { *r = vrshld_s64(*v0, *v1); }
void VrsqrteqF64(float64x2_t* r, float64x2_t* v0) { *r = vrsqrteq_f64(*v0); }
void VrsqrteF64(float64x1_t* r, float64x1_t* v0) { *r = vrsqrte_f64(*v0); }
void VrsqrtedF64(float64_t* r, float64_t* v0) { *r = vrsqrted_f64(*v0); }
void VrsqrtesF32(float32_t* r, float32_t* v0) { *r = vrsqrtes_f32(*v0); }
void VrsqrtsqF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vrsqrtsq_f64(*v0, *v1); }
void VrsqrtsF64(float64x1_t* r, float64x1_t* v0, float64x1_t* v1) { *r = vrsqrts_f64(*v0, *v1); }
void VrsqrtsdF64(float64_t* r, float64_t* v0, float64_t* v1) { *r = vrsqrtsd_f64(*v0, *v1); }
void VrsqrtssF32(float32_t* r, float32_t* v0, float32_t* v1) { *r = vrsqrtss_f32(*v0, *v1); }
void VrsubhnHighU32(uint16x8_t* r, uint16x4_t* v0, uint32x4_t* v1, uint32x4_t* v2) { *r = vrsubhn_high_u32(*v0, *v1, *v2); }
void VrsubhnHighU64(uint32x4_t* r, uint32x2_t* v0, uint64x2_t* v1, uint64x2_t* v2) { *r = vrsubhn_high_u64(*v0, *v1, *v2); }
void VrsubhnHighU16(uint8x16_t* r, uint8x8_t* v0, uint16x8_t* v1, uint16x8_t* v2) { *r = vrsubhn_high_u16(*v0, *v1, *v2); }
void VrsubhnHighS32(int16x8_t* r, int16x4_t* v0, int32x4_t* v1, int32x4_t* v2) { *r = vrsubhn_high_s32(*v0, *v1, *v2); }
void VrsubhnHighS64(int32x4_t* r, int32x2_t* v0, int64x2_t* v1, int64x2_t* v2) { *r = vrsubhn_high_s64(*v0, *v1, *v2); }
void VrsubhnHighS16(int8x16_t* r, int8x8_t* v0, int16x8_t* v1, int16x8_t* v2) { *r = vrsubhn_high_s16(*v0, *v1, *v2); }
void VshldU64(uint64_t* r, uint64_t* v0, int64_t* v1) { *r = vshld_u64(*v0, *v1); }
void VshldS64(int64_t* r, int64_t* v0, int64_t* v1) { *r = vshld_s64(*v0, *v1); }
void VsqaddbU8(uint8_t* r, uint8_t* v0, int8_t* v1) { *r = vsqaddb_u8(*v0, *v1); }
void VsqaddsU32(uint32_t* r, uint32_t* v0, int32_t* v1) { *r = vsqadds_u32(*v0, *v1); }
void VsqadddU64(uint64_t* r, uint64_t* v0, int64_t* v1) { *r = vsqaddd_u64(*v0, *v1); }
void VsqaddhU16(uint16_t* r, uint16_t* v0, int16_t* v1) { *r = vsqaddh_u16(*v0, *v1); }
void VsqaddqU8(uint8x16_t* r, uint8x16_t* v0, int8x16_t* v1) { *r = vsqaddq_u8(*v0, *v1); }
void VsqaddqU32(uint32x4_t* r, uint32x4_t* v0, int32x4_t* v1) { *r = vsqaddq_u32(*v0, *v1); }
void VsqaddqU64(uint64x2_t* r, uint64x2_t* v0, int64x2_t* v1) { *r = vsqaddq_u64(*v0, *v1); }
void VsqaddqU16(uint16x8_t* r, uint16x8_t* v0, int16x8_t* v1) { *r = vsqaddq_u16(*v0, *v1); }
void VsqaddU8(uint8x8_t* r, uint8x8_t* v0, int8x8_t* v1) { *r = vsqadd_u8(*v0, *v1); }
void VsqaddU32(uint32x2_t* r, uint32x2_t* v0, int32x2_t* v1) { *r = vsqadd_u32(*v0, *v1); }
void VsqaddU64(uint64x1_t* r, uint64x1_t* v0, int64x1_t* v1) { *r = vsqadd_u64(*v0, *v1); }
void VsqaddU16(uint16x4_t* r, uint16x4_t* v0, int16x4_t* v1) { *r = vsqadd_u16(*v0, *v1); }
void VsqrtqF64(float64x2_t* r, float64x2_t* v0) { *r = vsqrtq_f64(*v0); }
void VsqrtqF32(float32x4_t* r, float32x4_t* v0) { *r = vsqrtq_f32(*v0); }
void VsqrtF64(float64x1_t* r, float64x1_t* v0) { *r = vsqrt_f64(*v0); }
void VsqrtF32(float32x2_t* r, float32x2_t* v0) { *r = vsqrt_f32(*v0); }
void VsubdU64(uint64_t* r, uint64_t* v0, uint64_t* v1) { *r = vsubd_u64(*v0, *v1); }
void VsubdS64(int64_t* r, int64_t* v0, int64_t* v1) { *r = vsubd_s64(*v0, *v1); }
void VsubqF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vsubq_f64(*v0, *v1); }
void VsubF64(float64x1_t* r, float64x1_t* v0, float64x1_t* v1) { *r = vsub_f64(*v0, *v1); }
void VsubhnHighU32(uint16x8_t* r, uint16x4_t* v0, uint32x4_t* v1, uint32x4_t* v2) { *r = vsubhn_high_u32(*v0, *v1, *v2); }
void VsubhnHighU64(uint32x4_t* r, uint32x2_t* v0, uint64x2_t* v1, uint64x2_t* v2) { *r = vsubhn_high_u64(*v0, *v1, *v2); }
void VsubhnHighU16(uint8x16_t* r, uint8x8_t* v0, uint16x8_t* v1, uint16x8_t* v2) { *r = vsubhn_high_u16(*v0, *v1, *v2); }
void VsubhnHighS32(int16x8_t* r, int16x4_t* v0, int32x4_t* v1, int32x4_t* v2) { *r = vsubhn_high_s32(*v0, *v1, *v2); }
void VsubhnHighS64(int32x4_t* r, int32x2_t* v0, int64x2_t* v1, int64x2_t* v2) { *r = vsubhn_high_s64(*v0, *v1, *v2); }
void VsubhnHighS16(int8x16_t* r, int8x8_t* v0, int16x8_t* v1, int16x8_t* v2) { *r = vsubhn_high_s16(*v0, *v1, *v2); }
void VsublHighU8(uint16x8_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vsubl_high_u8(*v0, *v1); }
void VsublHighU32(uint64x2_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vsubl_high_u32(*v0, *v1); }
void VsublHighU16(uint32x4_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vsubl_high_u16(*v0, *v1); }
void VsublHighS8(int16x8_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vsubl_high_s8(*v0, *v1); }
void VsublHighS32(int64x2_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vsubl_high_s32(*v0, *v1); }
void VsublHighS16(int32x4_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vsubl_high_s16(*v0, *v1); }
void VsubwHighU8(uint16x8_t* r, uint16x8_t* v0, uint8x16_t* v1) { *r = vsubw_high_u8(*v0, *v1); }
void VsubwHighU32(uint64x2_t* r, uint64x2_t* v0, uint32x4_t* v1) { *r = vsubw_high_u32(*v0, *v1); }
void VsubwHighU16(uint32x4_t* r, uint32x4_t* v0, uint16x8_t* v1) { *r = vsubw_high_u16(*v0, *v1); }
void VsubwHighS8(int16x8_t* r, int16x8_t* v0, int8x16_t* v1) { *r = vsubw_high_s8(*v0, *v1); }
void VsubwHighS32(int64x2_t* r, int64x2_t* v0, int32x4_t* v1) { *r = vsubw_high_s32(*v0, *v1); }
void VsubwHighS16(int32x4_t* r, int32x4_t* v0, int16x8_t* v1) { *r = vsubw_high_s16(*v0, *v1); }
void Vtrn1P8(poly8x8_t* r, poly8x8_t* v0, poly8x8_t* v1) { *r = vtrn1_p8(*v0, *v1); }
void Vtrn1P16(poly16x4_t* r, poly16x4_t* v0, poly16x4_t* v1) { *r = vtrn1_p16(*v0, *v1); }
void Vtrn1QP8(poly8x16_t* r, poly8x16_t* v0, poly8x16_t* v1) { *r = vtrn1q_p8(*v0, *v1); }
void Vtrn1QP64(poly64x2_t* r, poly64x2_t* v0, poly64x2_t* v1) { *r = vtrn1q_p64(*v0, *v1); }
void Vtrn1QP16(poly16x8_t* r, poly16x8_t* v0, poly16x8_t* v1) { *r = vtrn1q_p16(*v0, *v1); }
void Vtrn1QU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vtrn1q_u8(*v0, *v1); }
void Vtrn1QU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vtrn1q_u32(*v0, *v1); }
void Vtrn1QU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vtrn1q_u64(*v0, *v1); }
void Vtrn1QU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vtrn1q_u16(*v0, *v1); }
void Vtrn1QS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vtrn1q_s8(*v0, *v1); }
void Vtrn1QF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vtrn1q_f64(*v0, *v1); }
void Vtrn1QF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vtrn1q_f32(*v0, *v1); }
void Vtrn1QS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vtrn1q_s32(*v0, *v1); }
void Vtrn1QS64(int64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vtrn1q_s64(*v0, *v1); }
void Vtrn1QS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vtrn1q_s16(*v0, *v1); }
void Vtrn1U8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vtrn1_u8(*v0, *v1); }
void Vtrn1U32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vtrn1_u32(*v0, *v1); }
void Vtrn1U16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vtrn1_u16(*v0, *v1); }
void Vtrn1S8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vtrn1_s8(*v0, *v1); }
void Vtrn1F32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vtrn1_f32(*v0, *v1); }
void Vtrn1S32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vtrn1_s32(*v0, *v1); }
void Vtrn1S16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vtrn1_s16(*v0, *v1); }
void Vtrn2P8(poly8x8_t* r, poly8x8_t* v0, poly8x8_t* v1) { *r = vtrn2_p8(*v0, *v1); }
void Vtrn2P16(poly16x4_t* r, poly16x4_t* v0, poly16x4_t* v1) { *r = vtrn2_p16(*v0, *v1); }
void Vtrn2QP8(poly8x16_t* r, poly8x16_t* v0, poly8x16_t* v1) { *r = vtrn2q_p8(*v0, *v1); }
void Vtrn2QP64(poly64x2_t* r, poly64x2_t* v0, poly64x2_t* v1) { *r = vtrn2q_p64(*v0, *v1); }
void Vtrn2QP16(poly16x8_t* r, poly16x8_t* v0, poly16x8_t* v1) { *r = vtrn2q_p16(*v0, *v1); }
void Vtrn2QU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vtrn2q_u8(*v0, *v1); }
void Vtrn2QU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vtrn2q_u32(*v0, *v1); }
void Vtrn2QU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vtrn2q_u64(*v0, *v1); }
void Vtrn2QU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vtrn2q_u16(*v0, *v1); }
void Vtrn2QS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vtrn2q_s8(*v0, *v1); }
void Vtrn2QF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vtrn2q_f64(*v0, *v1); }
void Vtrn2QF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vtrn2q_f32(*v0, *v1); }
void Vtrn2QS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vtrn2q_s32(*v0, *v1); }
void Vtrn2QS64(int64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vtrn2q_s64(*v0, *v1); }
void Vtrn2QS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vtrn2q_s16(*v0, *v1); }
void Vtrn2U8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vtrn2_u8(*v0, *v1); }
void Vtrn2U32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vtrn2_u32(*v0, *v1); }
void Vtrn2U16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vtrn2_u16(*v0, *v1); }
void Vtrn2S8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vtrn2_s8(*v0, *v1); }
void Vtrn2F32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vtrn2_f32(*v0, *v1); }
void Vtrn2S32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vtrn2_s32(*v0, *v1); }
void Vtrn2S16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vtrn2_s16(*v0, *v1); }
void VtstP64(uint64x1_t* r, poly64x1_t* v0, poly64x1_t* v1) { *r = vtst_p64(*v0, *v1); }
void VtstqP64(uint64x2_t* r, poly64x2_t* v0, poly64x2_t* v1) { *r = vtstq_p64(*v0, *v1); }
void VtstqU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vtstq_u64(*v0, *v1); }
void VtstqS64(uint64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vtstq_s64(*v0, *v1); }
void VtstU64(uint64x1_t* r, uint64x1_t* v0, uint64x1_t* v1) { *r = vtst_u64(*v0, *v1); }
void VtstS64(uint64x1_t* r, int64x1_t* v0, int64x1_t* v1) { *r = vtst_s64(*v0, *v1); }
void VtstdU64(uint64_t* r, uint64_t* v0, uint64_t* v1) { *r = vtstd_u64(*v0, *v1); }
void VtstdS64(uint64_t* r, int64_t* v0, int64_t* v1) { *r = vtstd_s64(*v0, *v1); }
void VuqaddbS8(int8_t* r, int8_t* v0, uint8_t* v1) { *r = vuqaddb_s8(*v0, *v1); }
void VuqaddsS32(int32_t* r, int32_t* v0, uint32_t* v1) { *r = vuqadds_s32(*v0, *v1); }
void VuqadddS64(int64_t* r, int64_t* v0, uint64_t* v1) { *r = vuqaddd_s64(*v0, *v1); }
void VuqaddhS16(int16_t* r, int16_t* v0, uint16_t* v1) { *r = vuqaddh_s16(*v0, *v1); }
void VuqaddqS8(int8x16_t* r, int8x16_t* v0, uint8x16_t* v1) { *r = vuqaddq_s8(*v0, *v1); }
void VuqaddqS32(int32x4_t* r, int32x4_t* v0, uint32x4_t* v1) { *r = vuqaddq_s32(*v0, *v1); }
void VuqaddqS64(int64x2_t* r, int64x2_t* v0, uint64x2_t* v1) { *r = vuqaddq_s64(*v0, *v1); }
void VuqaddqS16(int16x8_t* r, int16x8_t* v0, uint16x8_t* v1) { *r = vuqaddq_s16(*v0, *v1); }
void VuqaddS8(int8x8_t* r, int8x8_t* v0, uint8x8_t* v1) { *r = vuqadd_s8(*v0, *v1); }
void VuqaddS32(int32x2_t* r, int32x2_t* v0, uint32x2_t* v1) { *r = vuqadd_s32(*v0, *v1); }
void VuqaddS64(int64x1_t* r, int64x1_t* v0, uint64x1_t* v1) { *r = vuqadd_s64(*v0, *v1); }
void VuqaddS16(int16x4_t* r, int16x4_t* v0, uint16x4_t* v1) { *r = vuqadd_s16(*v0, *v1); }
void Vuzp1P8(poly8x8_t* r, poly8x8_t* v0, poly8x8_t* v1) { *r = vuzp1_p8(*v0, *v1); }
void Vuzp1P16(poly16x4_t* r, poly16x4_t* v0, poly16x4_t* v1) { *r = vuzp1_p16(*v0, *v1); }
void Vuzp1QP8(poly8x16_t* r, poly8x16_t* v0, poly8x16_t* v1) { *r = vuzp1q_p8(*v0, *v1); }
void Vuzp1QP64(poly64x2_t* r, poly64x2_t* v0, poly64x2_t* v1) { *r = vuzp1q_p64(*v0, *v1); }
void Vuzp1QP16(poly16x8_t* r, poly16x8_t* v0, poly16x8_t* v1) { *r = vuzp1q_p16(*v0, *v1); }
void Vuzp1QU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vuzp1q_u8(*v0, *v1); }
void Vuzp1QU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vuzp1q_u32(*v0, *v1); }
void Vuzp1QU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vuzp1q_u64(*v0, *v1); }
void Vuzp1QU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vuzp1q_u16(*v0, *v1); }
void Vuzp1QS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vuzp1q_s8(*v0, *v1); }
void Vuzp1QF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vuzp1q_f64(*v0, *v1); }
void Vuzp1QF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vuzp1q_f32(*v0, *v1); }
void Vuzp1QS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vuzp1q_s32(*v0, *v1); }
void Vuzp1QS64(int64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vuzp1q_s64(*v0, *v1); }
void Vuzp1QS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vuzp1q_s16(*v0, *v1); }
void Vuzp1U8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vuzp1_u8(*v0, *v1); }
void Vuzp1U32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vuzp1_u32(*v0, *v1); }
void Vuzp1U16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vuzp1_u16(*v0, *v1); }
void Vuzp1S8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vuzp1_s8(*v0, *v1); }
void Vuzp1F32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vuzp1_f32(*v0, *v1); }
void Vuzp1S32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vuzp1_s32(*v0, *v1); }
void Vuzp1S16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vuzp1_s16(*v0, *v1); }
void Vuzp2P8(poly8x8_t* r, poly8x8_t* v0, poly8x8_t* v1) { *r = vuzp2_p8(*v0, *v1); }
void Vuzp2P16(poly16x4_t* r, poly16x4_t* v0, poly16x4_t* v1) { *r = vuzp2_p16(*v0, *v1); }
void Vuzp2QP8(poly8x16_t* r, poly8x16_t* v0, poly8x16_t* v1) { *r = vuzp2q_p8(*v0, *v1); }
void Vuzp2QP64(poly64x2_t* r, poly64x2_t* v0, poly64x2_t* v1) { *r = vuzp2q_p64(*v0, *v1); }
void Vuzp2QP16(poly16x8_t* r, poly16x8_t* v0, poly16x8_t* v1) { *r = vuzp2q_p16(*v0, *v1); }
void Vuzp2QU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vuzp2q_u8(*v0, *v1); }
void Vuzp2QU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vuzp2q_u32(*v0, *v1); }
void Vuzp2QU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vuzp2q_u64(*v0, *v1); }
void Vuzp2QU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vuzp2q_u16(*v0, *v1); }
void Vuzp2QS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vuzp2q_s8(*v0, *v1); }
void Vuzp2QF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vuzp2q_f64(*v0, *v1); }
void Vuzp2QF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vuzp2q_f32(*v0, *v1); }
void Vuzp2QS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vuzp2q_s32(*v0, *v1); }
void Vuzp2QS64(int64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vuzp2q_s64(*v0, *v1); }
void Vuzp2QS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vuzp2q_s16(*v0, *v1); }
void Vuzp2U8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vuzp2_u8(*v0, *v1); }
void Vuzp2U32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vuzp2_u32(*v0, *v1); }
void Vuzp2U16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vuzp2_u16(*v0, *v1); }
void Vuzp2S8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vuzp2_s8(*v0, *v1); }
void Vuzp2F32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vuzp2_f32(*v0, *v1); }
void Vuzp2S32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vuzp2_s32(*v0, *v1); }
void Vuzp2S16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vuzp2_s16(*v0, *v1); }
void Vzip1P8(poly8x8_t* r, poly8x8_t* v0, poly8x8_t* v1) { *r = vzip1_p8(*v0, *v1); }
void Vzip1P16(poly16x4_t* r, poly16x4_t* v0, poly16x4_t* v1) { *r = vzip1_p16(*v0, *v1); }
void Vzip1QP8(poly8x16_t* r, poly8x16_t* v0, poly8x16_t* v1) { *r = vzip1q_p8(*v0, *v1); }
void Vzip1QP64(poly64x2_t* r, poly64x2_t* v0, poly64x2_t* v1) { *r = vzip1q_p64(*v0, *v1); }
void Vzip1QP16(poly16x8_t* r, poly16x8_t* v0, poly16x8_t* v1) { *r = vzip1q_p16(*v0, *v1); }
void Vzip1QU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vzip1q_u8(*v0, *v1); }
void Vzip1QU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vzip1q_u32(*v0, *v1); }
void Vzip1QU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vzip1q_u64(*v0, *v1); }
void Vzip1QU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vzip1q_u16(*v0, *v1); }
void Vzip1QS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vzip1q_s8(*v0, *v1); }
void Vzip1QF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vzip1q_f64(*v0, *v1); }
void Vzip1QF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vzip1q_f32(*v0, *v1); }
void Vzip1QS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vzip1q_s32(*v0, *v1); }
void Vzip1QS64(int64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vzip1q_s64(*v0, *v1); }
void Vzip1QS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vzip1q_s16(*v0, *v1); }
void Vzip1U8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vzip1_u8(*v0, *v1); }
void Vzip1U32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vzip1_u32(*v0, *v1); }
void Vzip1U16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vzip1_u16(*v0, *v1); }
void Vzip1S8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vzip1_s8(*v0, *v1); }
void Vzip1F32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vzip1_f32(*v0, *v1); }
void Vzip1S32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vzip1_s32(*v0, *v1); }
void Vzip1S16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vzip1_s16(*v0, *v1); }
void Vzip2P8(poly8x8_t* r, poly8x8_t* v0, poly8x8_t* v1) { *r = vzip2_p8(*v0, *v1); }
void Vzip2P16(poly16x4_t* r, poly16x4_t* v0, poly16x4_t* v1) { *r = vzip2_p16(*v0, *v1); }
void Vzip2QP8(poly8x16_t* r, poly8x16_t* v0, poly8x16_t* v1) { *r = vzip2q_p8(*v0, *v1); }
void Vzip2QP64(poly64x2_t* r, poly64x2_t* v0, poly64x2_t* v1) { *r = vzip2q_p64(*v0, *v1); }
void Vzip2QP16(poly16x8_t* r, poly16x8_t* v0, poly16x8_t* v1) { *r = vzip2q_p16(*v0, *v1); }
void Vzip2QU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vzip2q_u8(*v0, *v1); }
void Vzip2QU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vzip2q_u32(*v0, *v1); }
void Vzip2QU64(uint64x2_t* r, uint64x2_t* v0, uint64x2_t* v1) { *r = vzip2q_u64(*v0, *v1); }
void Vzip2QU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vzip2q_u16(*v0, *v1); }
void Vzip2QS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vzip2q_s8(*v0, *v1); }
void Vzip2QF64(float64x2_t* r, float64x2_t* v0, float64x2_t* v1) { *r = vzip2q_f64(*v0, *v1); }
void Vzip2QF32(float32x4_t* r, float32x4_t* v0, float32x4_t* v1) { *r = vzip2q_f32(*v0, *v1); }
void Vzip2QS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vzip2q_s32(*v0, *v1); }
void Vzip2QS64(int64x2_t* r, int64x2_t* v0, int64x2_t* v1) { *r = vzip2q_s64(*v0, *v1); }
void Vzip2QS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vzip2q_s16(*v0, *v1); }
void Vzip2U8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vzip2_u8(*v0, *v1); }
void Vzip2U32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vzip2_u32(*v0, *v1); }
void Vzip2U16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vzip2_u16(*v0, *v1); }
void Vzip2S8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vzip2_s8(*v0, *v1); }
void Vzip2F32(float32x2_t* r, float32x2_t* v0, float32x2_t* v1) { *r = vzip2_f32(*v0, *v1); }
void Vzip2S32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vzip2_s32(*v0, *v1); }
void Vzip2S16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vzip2_s16(*v0, *v1); }
void VabaqU8(uint8x16_t* r, uint8x16_t* v0, uint8x16_t* v1, uint8x16_t* v2) { *r = vabaq_u8(*v0, *v1, *v2); }
void VabaqU32(uint32x4_t* r, uint32x4_t* v0, uint32x4_t* v1, uint32x4_t* v2) { *r = vabaq_u32(*v0, *v1, *v2); }
void VabaqU16(uint16x8_t* r, uint16x8_t* v0, uint16x8_t* v1, uint16x8_t* v2) { *r = vabaq_u16(*v0, *v1, *v2); }
void VabaqS8(int8x16_t* r, int8x16_t* v0, int8x16_t* v1, int8x16_t* v2) { *r = vabaq_s8(*v0, *v1, *v2); }
void VabaqS32(int32x4_t* r, int32x4_t* v0, int32x4_t* v1, int32x4_t* v2) { *r = vabaq_s32(*v0, *v1, *v2); }
void VabaqS16(int16x8_t* r, int16x8_t* v0, int16x8_t* v1, int16x8_t* v2) { *r = vabaq_s16(*v0, *v1, *v2); }
void VabaU8(uint8x8_t* r, uint8x8_t* v0, uint8x8_t* v1, uint8x8_t* v2) { *r = vaba_u8(*v0, *v1, *v2); }
void VabaU32(uint32x2_t* r, uint32x2_t* v0, uint32x2_t* v1, uint32x2_t* v2) { *r = vaba_u32(*v0, *v1, *v2); }
void VabaU16(uint16x4_t* r, uint16x4_t* v0, uint16x4_t* v1, uint16x4_t* v2) { *r = vaba_u16(*v0, *v1, *v2); }
void VabaS8(int8x8_t* r, int8x8_t* v0, int8x8_t* v1, int8x8_t* v2) { *r = vaba_s8(*v0, *v1, *v2); }
void VabaS32(int32x2_t* r, int32x2_t* v0, int32x2_t* v1, int32x2_t* v2) { *r = vaba_s32(*v0, *v1, *v2); }
void VabaS16(int16x4_t* r, int16x4_t* v0, int16x4_t* v1, int16x4_t* v2) { *r = vaba_s16(*v0, *v1, *v2); }
void VabdlU8(uint16x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vabdl_u8(*v0, *v1); }
void VabdlU32(uint64x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vabdl_u32(*v0, *v1); }
void VabdlU16(uint32x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vabdl_u16(*v0, *v1); }
void VabdlS8(int16x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vabdl_s8(*v0, *v1); }
void VabdlS32(int64x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vabdl_s32(*v0, *v1); }
void VabdlS16(int32x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vabdl_s16(*v0, *v1); }
void VaddlU8(uint16x8_t* r, uint8x8_t* v0, uint8x8_t* v1) { *r = vaddl_u8(*v0, *v1); }
void VaddlU32(uint64x2_t* r, uint32x2_t* v0, uint32x2_t* v1) { *r = vaddl_u32(*v0, *v1); }
void VaddlU16(uint32x4_t* r, uint16x4_t* v0, uint16x4_t* v1) { *r = vaddl_u16(*v0, *v1); }
void VaddlS8(int16x8_t* r, int8x8_t* v0, int8x8_t* v1) { *r = vaddl_s8(*v0, *v1); }
void VaddlS32(int64x2_t* r, int32x2_t* v0, int32x2_t* v1) { *r = vaddl_s32(*v0, *v1); }
void VaddlS16(int32x4_t* r, int16x4_t* v0, int16x4_t* v1) { *r = vaddl_s16(*v0, *v1); }
void VaddwU8(uint16x8_t* r, uint16x8_t* v0, uint8x8_t* v1) { *r = vaddw_u8(*v0, *v1); }
void VaddwU32(uint64x2_t* r, uint64x2_t* v0, uint32x2_t* v1) { *r = vaddw_u32(*v0, *v1); }
void VaddwU16(uint32x4_t* r, uint32x4_t* v0, uint16x4_t* v1) { *r = vaddw_u16(*v0, *v1); }
void VaddwS8(int16x8_t* r, int16x8_t* v0, int8x8_t* v1) { *r = vaddw_s8(*v0, *v1); }
void VaddwS32(int64x2_t* r, int64x2_t* v0, int32x2_t* v1) { *r = vaddw_s32(*v0, *v1); }
void VaddwS16(int32x4_t* r, int32x4_t* v0, int16x4_t* v1) { *r = vaddw_s16(*v0, *v1); }
void VmlalU8(uint16x8_t* r, uint16x8_t* v0, uint8x8_t* v1, uint8x8_t* v2) { *r = vmlal_u8(*v0, *v1, *v2); }
void VmlalU32(uint64x2_t* r, uint64x2_t* v0, uint32x2_t* v1, uint32x2_t* v2) { *r = vmlal_u32(*v0, *v1, *v2); }
void VmlalU16(uint32x4_t* r, uint32x4_t* v0, uint16x4_t* v1, uint16x4_t* v2) { *r = vmlal_u16(*v0, *v1, *v2); }
void VmlalS8(int16x8_t* r, int16x8_t* v0, int8x8_t* v1, int8x8_t* v2) { *r = vmlal_s8(*v0, *v1, *v2); }
void VmlalS32(int64x2_t* r, int64x2_t* v0, int32x2_t* v1, int32x2_t* v2) { *r = vmlal_s32(*v0, *v1, *v2); }
void VmlalS16(int32x4_t* r, int32x4_t* v0, int16x4_t* v1, int16x4_t* v2) { *r = vmlal_s16(*v0, *v1, *v2); }
void VmlalNU32(uint64x2_t* r, uint64x2_t* v0, uint32x2_t* v1, uint32_t* v2) { *r = vmlal_n_u32(*v0, *v1, *v2); }
void VmlalNU16(uint32x4_t* r, uint32x4_t* v0, uint16x4_t* v1, uint16_t* v2) { *r = vmlal_n_u16(*v0, *v1, *v2); }
void VmlalNS32(int64x2_t* r, int64x2_t* v0, int32x2_t* v1, int32_t* v2) { *r = vmlal_n_s32(*v0, *v1, *v2); }
void VmlalNS16(int32x4_t* r, int32x4_t* v0, int16x4_t* v1, int16_t* v2) { *r = vmlal_n_s16(*v0, *v1, *v2); }
void VmlslU8(uint16x8_t* r, uint16x8_t* v0, uint8x8_t* v1, uint8x8_t* v2) { *r = vmlsl_u8(*v0, *v1, *v2); }
void VmlslU32(uint64x2_t* r, uint64x2_t* v0, uint32x2_t* v1, uint32x2_t* v2) { *r = vmlsl_u32(*v0, *v1, *v2); }
void VmlslU16(uint32x4_t* r, uint32x4_t* v0, uint16x4_t* v1, uint16x4_t* v2) { *r = vmlsl_u16(*v0, *v1, *v2); }
void VmlslS8(int16x8_t* r, int16x8_t* v0, int8x8_t* v1, int8x8_t* v2) { *r = vmlsl_s8(*v0, *v1, *v2); }
void VmlslS32(int64x2_t* r, int64x2_t* v0, int32x2_t* v1, int32x2_t* v2) { *r = vmlsl_s32(*v0, *v1, *v2); }
void VmlslS16(int32x4_t* r, int32x4_t* v0, int16x4_t* v1, int16x4_t* v2) { *r = vmlsl_s16(*v0, *v1, *v2); }
void VmlslNU32(uint64x2_t* r, uint64x2_t* v0, uint32x2_t* v1, uint32_t* v2) { *r = vmlsl_n_u32(*v0, *v1, *v2); }
void VmlslNU16(uint32x4_t* r, uint32x4_t* v0, uint16x4_t* v1, uint16_t* v2) { *r = vmlsl_n_u16(*v0, *v1, *v2); }
void VmlslNS32(int64x2_t* r, int64x2_t* v0, int32x2_t* v1, int32_t* v2) { *r = vmlsl_n_s32(*v0, *v1, *v2); }
void VmlslNS16(int32x4_t* r, int32x4_t* v0, int16x4_t* v1, int16_t* v2) { *r = vmlsl_n_s16(*v0, *v1, *v2); }
void VqrdmlahsS32(int32_t* r, int32_t* v0, int32_t* v1, int32_t* v2) { *r = vqrdmlahs_s32(*v0, *v1, *v2); }
void VqrdmlahhS16(int16_t* r, int16_t* v0, int16_t* v1, int16_t* v2) { *r = vqrdmlahh_s16(*v0, *v1, *v2); }
void VqrdmlshsS32(int32_t* r, int32_t* v0, int32_t* v1, int32_t* v2) { *r = vqrdmlshs_s32(*v0, *v1, *v2); }
void VqrdmlshhS16(int16_t* r, int16_t* v0, int16_t* v1, int16_t* v2) { *r = vqrdmlshh_s16(*v0, *v1, *v2); }
void VabdlHighU8(uint16x8_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vabdl_high_u8(*v0, *v1); }
void VabdlHighU32(uint64x2_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vabdl_high_u32(*v0, *v1); }
void VabdlHighU16(uint32x4_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vabdl_high_u16(*v0, *v1); }
void VabdlHighS8(int16x8_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vabdl_high_s8(*v0, *v1); }
void VabdlHighS32(int64x2_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vabdl_high_s32(*v0, *v1); }
void VabdlHighS16(int32x4_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vabdl_high_s16(*v0, *v1); }
void VaddlHighU8(uint16x8_t* r, uint8x16_t* v0, uint8x16_t* v1) { *r = vaddl_high_u8(*v0, *v1); }
void VaddlHighU32(uint64x2_t* r, uint32x4_t* v0, uint32x4_t* v1) { *r = vaddl_high_u32(*v0, *v1); }
void VaddlHighU16(uint32x4_t* r, uint16x8_t* v0, uint16x8_t* v1) { *r = vaddl_high_u16(*v0, *v1); }
void VaddlHighS8(int16x8_t* r, int8x16_t* v0, int8x16_t* v1) { *r = vaddl_high_s8(*v0, *v1); }
void VaddlHighS32(int64x2_t* r, int32x4_t* v0, int32x4_t* v1) { *r = vaddl_high_s32(*v0, *v1); }
void VaddlHighS16(int32x4_t* r, int16x8_t* v0, int16x8_t* v1) { *r = vaddl_high_s16(*v0, *v1); }
void VaddwHighU8(uint16x8_t* r, uint16x8_t* v0, uint8x16_t* v1) { *r = vaddw_high_u8(*v0, *v1); }
void VaddwHighU32(uint64x2_t* r, uint64x2_t* v0, uint32x4_t* v1) { *r = vaddw_high_u32(*v0, *v1); }
void VaddwHighU16(uint32x4_t* r, uint32x4_t* v0, uint16x8_t* v1) { *r = vaddw_high_u16(*v0, *v1); }
void VaddwHighS8(int16x8_t* r, int16x8_t* v0, int8x16_t* v1) { *r = vaddw_high_s8(*v0, *v1); }
void VaddwHighS32(int64x2_t* r, int64x2_t* v0, int32x4_t* v1) { *r = vaddw_high_s32(*v0, *v1); }
void VaddwHighS16(int32x4_t* r, int32x4_t* v0, int16x8_t* v1) { *r = vaddw_high_s16(*v0, *v1); }
void VmlalHighU8(uint16x8_t* r, uint16x8_t* v0, uint8x16_t* v1, uint8x16_t* v2) { *r = vmlal_high_u8(*v0, *v1, *v2); }
void VmlalHighU32(uint64x2_t* r, uint64x2_t* v0, uint32x4_t* v1, uint32x4_t* v2) { *r = vmlal_high_u32(*v0, *v1, *v2); }
void VmlalHighU16(uint32x4_t* r, uint32x4_t* v0, uint16x8_t* v1, uint16x8_t* v2) { *r = vmlal_high_u16(*v0, *v1, *v2); }
void VmlalHighS8(int16x8_t* r, int16x8_t* v0, int8x16_t* v1, int8x16_t* v2) { *r = vmlal_high_s8(*v0, *v1, *v2); }
void VmlalHighS32(int64x2_t* r, int64x2_t* v0, int32x4_t* v1, int32x4_t* v2) { *r = vmlal_high_s32(*v0, *v1, *v2); }
void VmlalHighS16(int32x4_t* r, int32x4_t* v0, int16x8_t* v1, int16x8_t* v2) { *r = vmlal_high_s16(*v0, *v1, *v2); }
void VmlalHighNU32(uint64x2_t* r, uint64x2_t* v0, uint32x4_t* v1, uint32_t* v2) { *r = vmlal_high_n_u32(*v0, *v1, *v2); }
void VmlalHighNU16(uint32x4_t* r, uint32x4_t* v0, uint16x8_t* v1, uint16_t* v2) { *r = vmlal_high_n_u16(*v0, *v1, *v2); }
void VmlalHighNS32(int64x2_t* r, int64x2_t* v0, int32x4_t* v1, int32_t* v2) { *r = vmlal_high_n_s32(*v0, *v1, *v2); }
void VmlalHighNS16(int32x4_t* r, int32x4_t* v0, int16x8_t* v1, int16_t* v2) { *r = vmlal_high_n_s16(*v0, *v1, *v2); }
void VmlslHighU8(uint16x8_t* r, uint16x8_t* v0, uint8x16_t* v1, uint8x16_t* v2) { *r = vmlsl_high_u8(*v0, *v1, *v2); }
void VmlslHighU32(uint64x2_t* r, uint64x2_t* v0, uint32x4_t* v1, uint32x4_t* v2) { *r = vmlsl_high_u32(*v0, *v1, *v2); }
void VmlslHighU16(uint32x4_t* r, uint32x4_t* v0, uint16x8_t* v1, uint16x8_t* v2) { *r = vmlsl_high_u16(*v0, *v1, *v2); }
void VmlslHighS8(int16x8_t* r, int16x8_t* v0, int8x16_t* v1, int8x16_t* v2) { *r = vmlsl_high_s8(*v0, *v1, *v2); }
void VmlslHighS32(int64x2_t* r, int64x2_t* v0, int32x4_t* v1, int32x4_t* v2) { *r = vmlsl_high_s32(*v0, *v1, *v2); }
void VmlslHighS16(int32x4_t* r, int32x4_t* v0, int16x8_t* v1, int16x8_t* v2) { *r = vmlsl_high_s16(*v0, *v1, *v2); }
void VmlslHighNU32(uint64x2_t* r, uint64x2_t* v0, uint32x4_t* v1, uint32_t* v2) { *r = vmlsl_high_n_u32(*v0, *v1, *v2); }
void VmlslHighNU16(uint32x4_t* r, uint32x4_t* v0, uint16x8_t* v1, uint16_t* v2) { *r = vmlsl_high_n_u16(*v0, *v1, *v2); }
void VmlslHighNS32(int64x2_t* r, int64x2_t* v0, int32x4_t* v1, int32_t* v2) { *r = vmlsl_high_n_s32(*v0, *v1, *v2); }
void VmlslHighNS16(int32x4_t* r, int32x4_t* v0, int16x8_t* v1, int16_t* v2) { *r = vmlsl_high_n_s16(*v0, *v1, *v2); }
void VabalU8(uint16x8_t* r, uint16x8_t* v0, uint8x8_t* v1, uint8x8_t* v2) { *r = vabal_u8(*v0, *v1, *v2); }
void VabalU32(uint64x2_t* r, uint64x2_t* v0, uint32x2_t* v1, uint32x2_t* v2) { *r = vabal_u32(*v0, *v1, *v2); }
void VabalU16(uint32x4_t* r, uint32x4_t* v0, uint16x4_t* v1, uint16x4_t* v2) { *r = vabal_u16(*v0, *v1, *v2); }
void VabalS8(int16x8_t* r, int16x8_t* v0, int8x8_t* v1, int8x8_t* v2) { *r = vabal_s8(*v0, *v1, *v2); }
void VabalS32(int64x2_t* r, int64x2_t* v0, int32x2_t* v1, int32x2_t* v2) { *r = vabal_s32(*v0, *v1, *v2); }
void VabalS16(int32x4_t* r, int32x4_t* v0, int16x4_t* v1, int16x4_t* v2) { *r = vabal_s16(*v0, *v1, *v2); }
void VabalHighU8(uint16x8_t* r, uint16x8_t* v0, uint8x16_t* v1, uint8x16_t* v2) { *r = vabal_high_u8(*v0, *v1, *v2); }
void VabalHighU32(uint64x2_t* r, uint64x2_t* v0, uint32x4_t* v1, uint32x4_t* v2) { *r = vabal_high_u32(*v0, *v1, *v2); }
void VabalHighU16(uint32x4_t* r, uint32x4_t* v0, uint16x8_t* v1, uint16x8_t* v2) { *r = vabal_high_u16(*v0, *v1, *v2); }
void VabalHighS8(int16x8_t* r, int16x8_t* v0, int8x16_t* v1, int8x16_t* v2) { *r = vabal_high_s8(*v0, *v1, *v2); }
void VabalHighS32(int64x2_t* r, int64x2_t* v0, int32x4_t* v1, int32x4_t* v2) { *r = vabal_high_s32(*v0, *v1, *v2); }
void VabalHighS16(int32x4_t* r, int32x4_t* v0, int16x8_t* v1, int16x8_t* v2) { *r = vabal_high_s16(*v0, *v1, *v2); }

*/
import "C"

// Unsigned Absolute Difference (vector). This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, places the the absolute values of the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabdqU8 VabdqU8
//go:noescape
func VabdqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Unsigned Absolute Difference (vector). This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, places the the absolute values of the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabdqU32 VabdqU32
//go:noescape
func VabdqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Unsigned Absolute Difference (vector). This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, places the the absolute values of the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabdqU16 VabdqU16
//go:noescape
func VabdqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Signed Absolute Difference. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, places the the absolute values of the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabdqS8 VabdqS8
//go:noescape
func VabdqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Floating-point Absolute Difference (vector). This instruction subtracts the floating-point values in the elements of the second source SIMD&FP register, from the corresponding floating-point values in the elements of the first source SIMD&FP register, places the absolute value of each result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabdqF32 VabdqF32
//go:noescape
func VabdqF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Signed Absolute Difference. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, places the the absolute values of the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabdqS32 VabdqS32
//go:noescape
func VabdqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Signed Absolute Difference. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, places the the absolute values of the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabdqS16 VabdqS16
//go:noescape
func VabdqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Unsigned Absolute Difference (vector). This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, places the the absolute values of the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabdU8 VabdU8
//go:noescape
func VabdU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Unsigned Absolute Difference (vector). This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, places the the absolute values of the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabdU32 VabdU32
//go:noescape
func VabdU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Unsigned Absolute Difference (vector). This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, places the the absolute values of the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabdU16 VabdU16
//go:noescape
func VabdU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Signed Absolute Difference. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, places the the absolute values of the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabdS8 VabdS8
//go:noescape
func VabdS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Floating-point Absolute Difference (vector). This instruction subtracts the floating-point values in the elements of the second source SIMD&FP register, from the corresponding floating-point values in the elements of the first source SIMD&FP register, places the absolute value of each result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabdF32 VabdF32
//go:noescape
func VabdF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Signed Absolute Difference. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, places the the absolute values of the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabdS32 VabdS32
//go:noescape
func VabdS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Signed Absolute Difference. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, places the the absolute values of the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabdS16 VabdS16
//go:noescape
func VabdS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Absolute value (vector). This instruction calculates the absolute value of each vector element in the source SIMD&FP register, puts the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabsqS8 VabsqS8
//go:noescape
func VabsqS8(r *Int8X16, v0 *Int8X16)

// Floating-point Absolute value (vector). This instruction calculates the absolute value of each vector element in the source SIMD&FP register, writes the result to a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabsqF32 VabsqF32
//go:noescape
func VabsqF32(r *Float32X4, v0 *Float32X4)

// Absolute value (vector). This instruction calculates the absolute value of each vector element in the source SIMD&FP register, puts the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabsqS32 VabsqS32
//go:noescape
func VabsqS32(r *Int32X4, v0 *Int32X4)

// Absolute value (vector). This instruction calculates the absolute value of each vector element in the source SIMD&FP register, puts the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabsqS16 VabsqS16
//go:noescape
func VabsqS16(r *Int16X8, v0 *Int16X8)

// Absolute value (vector). This instruction calculates the absolute value of each vector element in the source SIMD&FP register, puts the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabsS8 VabsS8
//go:noescape
func VabsS8(r *Int8X8, v0 *Int8X8)

// Floating-point Absolute value (vector). This instruction calculates the absolute value of each vector element in the source SIMD&FP register, writes the result to a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabsF32 VabsF32
//go:noescape
func VabsF32(r *Float32X2, v0 *Float32X2)

// Absolute value (vector). This instruction calculates the absolute value of each vector element in the source SIMD&FP register, puts the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabsS32 VabsS32
//go:noescape
func VabsS32(r *Int32X2, v0 *Int32X2)

// Absolute value (vector). This instruction calculates the absolute value of each vector element in the source SIMD&FP register, puts the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabsS16 VabsS16
//go:noescape
func VabsS16(r *Int16X4, v0 *Int16X4)

// Add (vector). This instruction adds corresponding elements in the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VaddqU8 VaddqU8
//go:noescape
func VaddqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Add (vector). This instruction adds corresponding elements in the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VaddqU32 VaddqU32
//go:noescape
func VaddqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Add (vector). This instruction adds corresponding elements in the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VaddqU64 VaddqU64
//go:noescape
func VaddqU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// Add (vector). This instruction adds corresponding elements in the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VaddqU16 VaddqU16
//go:noescape
func VaddqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Add (vector). This instruction adds corresponding elements in the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VaddqS8 VaddqS8
//go:noescape
func VaddqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Floating-point Add (vector). This instruction adds corresponding vector elements in the two source SIMD&FP registers, writes the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VaddqF32 VaddqF32
//go:noescape
func VaddqF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Add (vector). This instruction adds corresponding elements in the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VaddqS32 VaddqS32
//go:noescape
func VaddqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Add (vector). This instruction adds corresponding elements in the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VaddqS64 VaddqS64
//go:noescape
func VaddqS64(r *Int64X2, v0 *Int64X2, v1 *Int64X2)

// Add (vector). This instruction adds corresponding elements in the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VaddqS16 VaddqS16
//go:noescape
func VaddqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Add (vector). This instruction adds corresponding elements in the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VaddU8 VaddU8
//go:noescape
func VaddU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Add (vector). This instruction adds corresponding elements in the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VaddU32 VaddU32
//go:noescape
func VaddU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Add (vector). This instruction adds corresponding elements in the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VaddU64 VaddU64
//go:noescape
func VaddU64(r *Uint64X1, v0 *Uint64X1, v1 *Uint64X1)

// Add (vector). This instruction adds corresponding elements in the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VaddU16 VaddU16
//go:noescape
func VaddU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Add (vector). This instruction adds corresponding elements in the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VaddS8 VaddS8
//go:noescape
func VaddS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Floating-point Add (vector). This instruction adds corresponding vector elements in the two source SIMD&FP registers, writes the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VaddF32 VaddF32
//go:noescape
func VaddF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Add (vector). This instruction adds corresponding elements in the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VaddS32 VaddS32
//go:noescape
func VaddS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Add (vector). This instruction adds corresponding elements in the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VaddS64 VaddS64
//go:noescape
func VaddS64(r *Int64X1, v0 *Int64X1, v1 *Int64X1)

// Add (vector). This instruction adds corresponding elements in the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VaddS16 VaddS16
//go:noescape
func VaddS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.
//
//go:linkname VaddP8 VaddP8
//go:noescape
func VaddP8(r *Poly8X8, v0 *Poly8X8, v1 *Poly8X8)

// Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.
//
//go:linkname VaddP64 VaddP64
//go:noescape
func VaddP64(r *Poly64X1, v0 *Poly64X1, v1 *Poly64X1)

// Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.
//
//go:linkname VaddP16 VaddP16
//go:noescape
func VaddP16(r *Poly16X4, v0 *Poly16X4, v1 *Poly16X4)

// Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.
//
//go:linkname VaddqP8 VaddqP8
//go:noescape
func VaddqP8(r *Poly8X16, v0 *Poly8X16, v1 *Poly8X16)

// Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.
//
//go:linkname VaddqP64 VaddqP64
//go:noescape
func VaddqP64(r *Poly64X2, v0 *Poly64X2, v1 *Poly64X2)

// Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.
//
//go:linkname VaddqP16 VaddqP16
//go:noescape
func VaddqP16(r *Poly16X8, v0 *Poly16X8, v1 *Poly16X8)

// Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VaddhnU32 VaddhnU32
//go:noescape
func VaddhnU32(r *Uint16X4, v0 *Uint32X4, v1 *Uint32X4)

// Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VaddhnU64 VaddhnU64
//go:noescape
func VaddhnU64(r *Uint32X2, v0 *Uint64X2, v1 *Uint64X2)

// Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VaddhnU16 VaddhnU16
//go:noescape
func VaddhnU16(r *Uint8X8, v0 *Uint16X8, v1 *Uint16X8)

// Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VaddhnS32 VaddhnS32
//go:noescape
func VaddhnS32(r *Int16X4, v0 *Int32X4, v1 *Int32X4)

// Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VaddhnS64 VaddhnS64
//go:noescape
func VaddhnS64(r *Int32X2, v0 *Int64X2, v1 *Int64X2)

// Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VaddhnS16 VaddhnS16
//go:noescape
func VaddhnS16(r *Int8X8, v0 *Int16X8, v1 *Int16X8)

// Bitwise AND (vector). This instruction performs a bitwise AND between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VandqU8 VandqU8
//go:noescape
func VandqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Bitwise AND (vector). This instruction performs a bitwise AND between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VandqU32 VandqU32
//go:noescape
func VandqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Bitwise AND (vector). This instruction performs a bitwise AND between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VandqU64 VandqU64
//go:noescape
func VandqU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// Bitwise AND (vector). This instruction performs a bitwise AND between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VandqU16 VandqU16
//go:noescape
func VandqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Bitwise AND (vector). This instruction performs a bitwise AND between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VandqS8 VandqS8
//go:noescape
func VandqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Bitwise AND (vector). This instruction performs a bitwise AND between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VandqS32 VandqS32
//go:noescape
func VandqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Bitwise AND (vector). This instruction performs a bitwise AND between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VandqS64 VandqS64
//go:noescape
func VandqS64(r *Int64X2, v0 *Int64X2, v1 *Int64X2)

// Bitwise AND (vector). This instruction performs a bitwise AND between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VandqS16 VandqS16
//go:noescape
func VandqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Bitwise AND (vector). This instruction performs a bitwise AND between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VandU8 VandU8
//go:noescape
func VandU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Bitwise AND (vector). This instruction performs a bitwise AND between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VandU32 VandU32
//go:noescape
func VandU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Bitwise AND (vector). This instruction performs a bitwise AND between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VandU64 VandU64
//go:noescape
func VandU64(r *Uint64X1, v0 *Uint64X1, v1 *Uint64X1)

// Bitwise AND (vector). This instruction performs a bitwise AND between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VandU16 VandU16
//go:noescape
func VandU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Bitwise AND (vector). This instruction performs a bitwise AND between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VandS8 VandS8
//go:noescape
func VandS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Bitwise AND (vector). This instruction performs a bitwise AND between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VandS32 VandS32
//go:noescape
func VandS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Bitwise AND (vector). This instruction performs a bitwise AND between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VandS64 VandS64
//go:noescape
func VandS64(r *Int64X1, v0 *Int64X1, v1 *Int64X1)

// Bitwise AND (vector). This instruction performs a bitwise AND between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VandS16 VandS16
//go:noescape
func VandS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Bitwise bit Clear (vector, register). This instruction performs a bitwise AND between the first source SIMD&FP register and the complement of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbicqU8 VbicqU8
//go:noescape
func VbicqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Bitwise bit Clear (vector, register). This instruction performs a bitwise AND between the first source SIMD&FP register and the complement of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbicqU32 VbicqU32
//go:noescape
func VbicqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Bitwise bit Clear (vector, register). This instruction performs a bitwise AND between the first source SIMD&FP register and the complement of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbicqU64 VbicqU64
//go:noescape
func VbicqU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// Bitwise bit Clear (vector, register). This instruction performs a bitwise AND between the first source SIMD&FP register and the complement of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbicqU16 VbicqU16
//go:noescape
func VbicqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Bitwise bit Clear (vector, register). This instruction performs a bitwise AND between the first source SIMD&FP register and the complement of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbicqS8 VbicqS8
//go:noescape
func VbicqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Bitwise bit Clear (vector, register). This instruction performs a bitwise AND between the first source SIMD&FP register and the complement of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbicqS32 VbicqS32
//go:noescape
func VbicqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Bitwise bit Clear (vector, register). This instruction performs a bitwise AND between the first source SIMD&FP register and the complement of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbicqS64 VbicqS64
//go:noescape
func VbicqS64(r *Int64X2, v0 *Int64X2, v1 *Int64X2)

// Bitwise bit Clear (vector, register). This instruction performs a bitwise AND between the first source SIMD&FP register and the complement of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbicqS16 VbicqS16
//go:noescape
func VbicqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Bitwise bit Clear (vector, register). This instruction performs a bitwise AND between the first source SIMD&FP register and the complement of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbicU8 VbicU8
//go:noescape
func VbicU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Bitwise bit Clear (vector, register). This instruction performs a bitwise AND between the first source SIMD&FP register and the complement of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbicU32 VbicU32
//go:noescape
func VbicU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Bitwise bit Clear (vector, register). This instruction performs a bitwise AND between the first source SIMD&FP register and the complement of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbicU64 VbicU64
//go:noescape
func VbicU64(r *Uint64X1, v0 *Uint64X1, v1 *Uint64X1)

// Bitwise bit Clear (vector, register). This instruction performs a bitwise AND between the first source SIMD&FP register and the complement of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbicU16 VbicU16
//go:noescape
func VbicU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Bitwise bit Clear (vector, register). This instruction performs a bitwise AND between the first source SIMD&FP register and the complement of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbicS8 VbicS8
//go:noescape
func VbicS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Bitwise bit Clear (vector, register). This instruction performs a bitwise AND between the first source SIMD&FP register and the complement of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbicS32 VbicS32
//go:noescape
func VbicS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Bitwise bit Clear (vector, register). This instruction performs a bitwise AND between the first source SIMD&FP register and the complement of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbicS64 VbicS64
//go:noescape
func VbicS64(r *Int64X1, v0 *Int64X1, v1 *Int64X1)

// Bitwise bit Clear (vector, register). This instruction performs a bitwise AND between the first source SIMD&FP register and the complement of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbicS16 VbicS16
//go:noescape
func VbicS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslP8 VbslP8
//go:noescape
func VbslP8(r *Poly8X8, v0 *Uint8X8, v1 *Poly8X8, v2 *Poly8X8)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslP16 VbslP16
//go:noescape
func VbslP16(r *Poly16X4, v0 *Uint16X4, v1 *Poly16X4, v2 *Poly16X4)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslqP8 VbslqP8
//go:noescape
func VbslqP8(r *Poly8X16, v0 *Uint8X16, v1 *Poly8X16, v2 *Poly8X16)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslqP16 VbslqP16
//go:noescape
func VbslqP16(r *Poly16X8, v0 *Uint16X8, v1 *Poly16X8, v2 *Poly16X8)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslqU8 VbslqU8
//go:noescape
func VbslqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16, v2 *Uint8X16)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslqU32 VbslqU32
//go:noescape
func VbslqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4, v2 *Uint32X4)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslqU64 VbslqU64
//go:noescape
func VbslqU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2, v2 *Uint64X2)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslqU16 VbslqU16
//go:noescape
func VbslqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8, v2 *Uint16X8)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslqS8 VbslqS8
//go:noescape
func VbslqS8(r *Int8X16, v0 *Uint8X16, v1 *Int8X16, v2 *Int8X16)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslqF32 VbslqF32
//go:noescape
func VbslqF32(r *Float32X4, v0 *Uint32X4, v1 *Float32X4, v2 *Float32X4)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslqS32 VbslqS32
//go:noescape
func VbslqS32(r *Int32X4, v0 *Uint32X4, v1 *Int32X4, v2 *Int32X4)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslqS64 VbslqS64
//go:noescape
func VbslqS64(r *Int64X2, v0 *Uint64X2, v1 *Int64X2, v2 *Int64X2)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslqS16 VbslqS16
//go:noescape
func VbslqS16(r *Int16X8, v0 *Uint16X8, v1 *Int16X8, v2 *Int16X8)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslU8 VbslU8
//go:noescape
func VbslU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8, v2 *Uint8X8)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslU32 VbslU32
//go:noescape
func VbslU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2, v2 *Uint32X2)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslU64 VbslU64
//go:noescape
func VbslU64(r *Uint64X1, v0 *Uint64X1, v1 *Uint64X1, v2 *Uint64X1)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslU16 VbslU16
//go:noescape
func VbslU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4, v2 *Uint16X4)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslS8 VbslS8
//go:noescape
func VbslS8(r *Int8X8, v0 *Uint8X8, v1 *Int8X8, v2 *Int8X8)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslF32 VbslF32
//go:noescape
func VbslF32(r *Float32X2, v0 *Uint32X2, v1 *Float32X2, v2 *Float32X2)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslS32 VbslS32
//go:noescape
func VbslS32(r *Int32X2, v0 *Uint32X2, v1 *Int32X2, v2 *Int32X2)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslS64 VbslS64
//go:noescape
func VbslS64(r *Int64X1, v0 *Uint64X1, v1 *Int64X1, v2 *Int64X1)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslS16 VbslS16
//go:noescape
func VbslS16(r *Int16X4, v0 *Uint16X4, v1 *Int16X4, v2 *Int16X4)

// Floating-point Absolute Compare Greater than or Equal (vector). This instruction compares the absolute value of each floating-point value in the first source SIMD&FP register with the absolute value of the corresponding floating-point value in the second source SIMD&FP register and if the first value is greater than or equal to the second value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcageqF32 VcageqF32
//go:noescape
func VcageqF32(r *Uint32X4, v0 *Float32X4, v1 *Float32X4)

// Floating-point Absolute Compare Greater than or Equal (vector). This instruction compares the absolute value of each floating-point value in the first source SIMD&FP register with the absolute value of the corresponding floating-point value in the second source SIMD&FP register and if the first value is greater than or equal to the second value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcageF32 VcageF32
//go:noescape
func VcageF32(r *Uint32X2, v0 *Float32X2, v1 *Float32X2)

// Floating-point Absolute Compare Greater than (vector). This instruction compares the absolute value of each vector element in the first source SIMD&FP register with the absolute value of the corresponding vector element in the second source SIMD&FP register and if the first value is greater than the second value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcagtqF32 VcagtqF32
//go:noescape
func VcagtqF32(r *Uint32X4, v0 *Float32X4, v1 *Float32X4)

// Floating-point Absolute Compare Greater than (vector). This instruction compares the absolute value of each vector element in the first source SIMD&FP register with the absolute value of the corresponding vector element in the second source SIMD&FP register and if the first value is greater than the second value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcagtF32 VcagtF32
//go:noescape
func VcagtF32(r *Uint32X2, v0 *Float32X2, v1 *Float32X2)

// Floating-point absolute compare less than or equal
//
//go:linkname VcaleqF32 VcaleqF32
//go:noescape
func VcaleqF32(r *Uint32X4, v0 *Float32X4, v1 *Float32X4)

// Floating-point absolute compare less than or equal
//
//go:linkname VcaleF32 VcaleF32
//go:noescape
func VcaleF32(r *Uint32X2, v0 *Float32X2, v1 *Float32X2)

// Floating-point absolute compare less than
//
//go:linkname VcaltqF32 VcaltqF32
//go:noescape
func VcaltqF32(r *Uint32X4, v0 *Float32X4, v1 *Float32X4)

// Floating-point absolute compare less than
//
//go:linkname VcaltF32 VcaltF32
//go:noescape
func VcaltF32(r *Uint32X2, v0 *Float32X2, v1 *Float32X2)

// Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqP8 VceqP8
//go:noescape
func VceqP8(r *Uint8X8, v0 *Poly8X8, v1 *Poly8X8)

// Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqqP8 VceqqP8
//go:noescape
func VceqqP8(r *Uint8X16, v0 *Poly8X16, v1 *Poly8X16)

// Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqqU8 VceqqU8
//go:noescape
func VceqqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqqU32 VceqqU32
//go:noescape
func VceqqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqqU16 VceqqU16
//go:noescape
func VceqqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqqS8 VceqqS8
//go:noescape
func VceqqS8(r *Uint8X16, v0 *Int8X16, v1 *Int8X16)

// Floating-point Compare Equal (vector). This instruction compares each floating-point value from the first source SIMD&FP register, with the corresponding floating-point value from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqqF32 VceqqF32
//go:noescape
func VceqqF32(r *Uint32X4, v0 *Float32X4, v1 *Float32X4)

// Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqqS32 VceqqS32
//go:noescape
func VceqqS32(r *Uint32X4, v0 *Int32X4, v1 *Int32X4)

// Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqqS16 VceqqS16
//go:noescape
func VceqqS16(r *Uint16X8, v0 *Int16X8, v1 *Int16X8)

// Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqU8 VceqU8
//go:noescape
func VceqU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqU32 VceqU32
//go:noescape
func VceqU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqU16 VceqU16
//go:noescape
func VceqU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqS8 VceqS8
//go:noescape
func VceqS8(r *Uint8X8, v0 *Int8X8, v1 *Int8X8)

// Floating-point Compare Equal (vector). This instruction compares each floating-point value from the first source SIMD&FP register, with the corresponding floating-point value from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqF32 VceqF32
//go:noescape
func VceqF32(r *Uint32X2, v0 *Float32X2, v1 *Float32X2)

// Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqS32 VceqS32
//go:noescape
func VceqS32(r *Uint32X2, v0 *Int32X2, v1 *Int32X2)

// Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqS16 VceqS16
//go:noescape
func VceqS16(r *Uint16X4, v0 *Int16X4, v1 *Int16X4)

// Compare unsigned Higher or Same (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than or equal to the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgeqU8 VcgeqU8
//go:noescape
func VcgeqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Compare unsigned Higher or Same (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than or equal to the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgeqU32 VcgeqU32
//go:noescape
func VcgeqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Compare unsigned Higher or Same (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than or equal to the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgeqU16 VcgeqU16
//go:noescape
func VcgeqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Compare signed Greater than or Equal (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than or equal to the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgeqS8 VcgeqS8
//go:noescape
func VcgeqS8(r *Uint8X16, v0 *Int8X16, v1 *Int8X16)

// Floating-point Compare Greater than or Equal (vector). This instruction reads each floating-point value in the first source SIMD&FP register and if the value is greater than or equal to the corresponding floating-point value in the second source SIMD&FP register sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgeqF32 VcgeqF32
//go:noescape
func VcgeqF32(r *Uint32X4, v0 *Float32X4, v1 *Float32X4)

// Compare signed Greater than or Equal (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than or equal to the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgeqS32 VcgeqS32
//go:noescape
func VcgeqS32(r *Uint32X4, v0 *Int32X4, v1 *Int32X4)

// Compare signed Greater than or Equal (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than or equal to the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgeqS16 VcgeqS16
//go:noescape
func VcgeqS16(r *Uint16X8, v0 *Int16X8, v1 *Int16X8)

// Compare unsigned Higher or Same (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than or equal to the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgeU8 VcgeU8
//go:noescape
func VcgeU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Compare unsigned Higher or Same (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than or equal to the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgeU32 VcgeU32
//go:noescape
func VcgeU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Compare unsigned Higher or Same (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than or equal to the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgeU16 VcgeU16
//go:noescape
func VcgeU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Compare signed Greater than or Equal (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than or equal to the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgeS8 VcgeS8
//go:noescape
func VcgeS8(r *Uint8X8, v0 *Int8X8, v1 *Int8X8)

// Floating-point Compare Greater than or Equal (vector). This instruction reads each floating-point value in the first source SIMD&FP register and if the value is greater than or equal to the corresponding floating-point value in the second source SIMD&FP register sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgeF32 VcgeF32
//go:noescape
func VcgeF32(r *Uint32X2, v0 *Float32X2, v1 *Float32X2)

// Compare signed Greater than or Equal (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than or equal to the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgeS32 VcgeS32
//go:noescape
func VcgeS32(r *Uint32X2, v0 *Int32X2, v1 *Int32X2)

// Compare signed Greater than or Equal (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than or equal to the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgeS16 VcgeS16
//go:noescape
func VcgeS16(r *Uint16X4, v0 *Int16X4, v1 *Int16X4)

// Compare unsigned Higher (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtqU8 VcgtqU8
//go:noescape
func VcgtqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Compare unsigned Higher (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtqU32 VcgtqU32
//go:noescape
func VcgtqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Compare unsigned Higher (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtqU16 VcgtqU16
//go:noescape
func VcgtqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Compare signed Greater than (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtqS8 VcgtqS8
//go:noescape
func VcgtqS8(r *Uint8X16, v0 *Int8X16, v1 *Int8X16)

// Floating-point Compare Greater than (vector). This instruction reads each floating-point value in the first source SIMD&FP register and if the value is greater than the corresponding floating-point value in the second source SIMD&FP register sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtqF32 VcgtqF32
//go:noescape
func VcgtqF32(r *Uint32X4, v0 *Float32X4, v1 *Float32X4)

// Compare signed Greater than (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtqS32 VcgtqS32
//go:noescape
func VcgtqS32(r *Uint32X4, v0 *Int32X4, v1 *Int32X4)

// Compare signed Greater than (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtqS16 VcgtqS16
//go:noescape
func VcgtqS16(r *Uint16X8, v0 *Int16X8, v1 *Int16X8)

// Compare unsigned Higher (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtU8 VcgtU8
//go:noescape
func VcgtU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Compare unsigned Higher (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtU32 VcgtU32
//go:noescape
func VcgtU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Compare unsigned Higher (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtU16 VcgtU16
//go:noescape
func VcgtU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Compare signed Greater than (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtS8 VcgtS8
//go:noescape
func VcgtS8(r *Uint8X8, v0 *Int8X8, v1 *Int8X8)

// Floating-point Compare Greater than (vector). This instruction reads each floating-point value in the first source SIMD&FP register and if the value is greater than the corresponding floating-point value in the second source SIMD&FP register sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtF32 VcgtF32
//go:noescape
func VcgtF32(r *Uint32X2, v0 *Float32X2, v1 *Float32X2)

// Compare signed Greater than (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtS32 VcgtS32
//go:noescape
func VcgtS32(r *Uint32X2, v0 *Int32X2, v1 *Int32X2)

// Compare signed Greater than (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtS16 VcgtS16
//go:noescape
func VcgtS16(r *Uint16X4, v0 *Int16X4, v1 *Int16X4)

// Compare unsigned less than or equal
//
//go:linkname VcleqU8 VcleqU8
//go:noescape
func VcleqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Compare unsigned less than or equal
//
//go:linkname VcleqU32 VcleqU32
//go:noescape
func VcleqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Compare unsigned less than or equal
//
//go:linkname VcleqU16 VcleqU16
//go:noescape
func VcleqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Compare signed less than or equal
//
//go:linkname VcleqS8 VcleqS8
//go:noescape
func VcleqS8(r *Uint8X16, v0 *Int8X16, v1 *Int8X16)

// Floating-point compare less than or equal
//
//go:linkname VcleqF32 VcleqF32
//go:noescape
func VcleqF32(r *Uint32X4, v0 *Float32X4, v1 *Float32X4)

// Compare signed less than or equal
//
//go:linkname VcleqS32 VcleqS32
//go:noescape
func VcleqS32(r *Uint32X4, v0 *Int32X4, v1 *Int32X4)

// Compare signed less than or equal
//
//go:linkname VcleqS16 VcleqS16
//go:noescape
func VcleqS16(r *Uint16X8, v0 *Int16X8, v1 *Int16X8)

// Compare unsigned less than or equal
//
//go:linkname VcleU8 VcleU8
//go:noescape
func VcleU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Compare unsigned less than or equal
//
//go:linkname VcleU32 VcleU32
//go:noescape
func VcleU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Compare unsigned less than or equal
//
//go:linkname VcleU16 VcleU16
//go:noescape
func VcleU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Compare signed less than or equal
//
//go:linkname VcleS8 VcleS8
//go:noescape
func VcleS8(r *Uint8X8, v0 *Int8X8, v1 *Int8X8)

// Floating-point compare less than or equal
//
//go:linkname VcleF32 VcleF32
//go:noescape
func VcleF32(r *Uint32X2, v0 *Float32X2, v1 *Float32X2)

// Compare signed less than or equal
//
//go:linkname VcleS32 VcleS32
//go:noescape
func VcleS32(r *Uint32X2, v0 *Int32X2, v1 *Int32X2)

// Compare signed less than or equal
//
//go:linkname VcleS16 VcleS16
//go:noescape
func VcleS16(r *Uint16X4, v0 *Int16X4, v1 *Int16X4)

// Count Leading Sign bits (vector). This instruction counts the number of consecutive bits following the most significant bit that are the same as the most significant bit in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The count does not include the most significant bit itself.
//
//go:linkname VclsqU8 VclsqU8
//go:noescape
func VclsqU8(r *Int8X16, v0 *Uint8X16)

// Count Leading Sign bits (vector). This instruction counts the number of consecutive bits following the most significant bit that are the same as the most significant bit in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The count does not include the most significant bit itself.
//
//go:linkname VclsqU32 VclsqU32
//go:noescape
func VclsqU32(r *Int32X4, v0 *Uint32X4)

// Count Leading Sign bits (vector). This instruction counts the number of consecutive bits following the most significant bit that are the same as the most significant bit in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The count does not include the most significant bit itself.
//
//go:linkname VclsqU16 VclsqU16
//go:noescape
func VclsqU16(r *Int16X8, v0 *Uint16X8)

// Count Leading Sign bits (vector). This instruction counts the number of consecutive bits following the most significant bit that are the same as the most significant bit in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The count does not include the most significant bit itself.
//
//go:linkname VclsqS8 VclsqS8
//go:noescape
func VclsqS8(r *Int8X16, v0 *Int8X16)

// Count Leading Sign bits (vector). This instruction counts the number of consecutive bits following the most significant bit that are the same as the most significant bit in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The count does not include the most significant bit itself.
//
//go:linkname VclsqS32 VclsqS32
//go:noescape
func VclsqS32(r *Int32X4, v0 *Int32X4)

// Count Leading Sign bits (vector). This instruction counts the number of consecutive bits following the most significant bit that are the same as the most significant bit in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The count does not include the most significant bit itself.
//
//go:linkname VclsqS16 VclsqS16
//go:noescape
func VclsqS16(r *Int16X8, v0 *Int16X8)

// Count Leading Sign bits (vector). This instruction counts the number of consecutive bits following the most significant bit that are the same as the most significant bit in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The count does not include the most significant bit itself.
//
//go:linkname VclsU8 VclsU8
//go:noescape
func VclsU8(r *Int8X8, v0 *Uint8X8)

// Count Leading Sign bits (vector). This instruction counts the number of consecutive bits following the most significant bit that are the same as the most significant bit in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The count does not include the most significant bit itself.
//
//go:linkname VclsU32 VclsU32
//go:noescape
func VclsU32(r *Int32X2, v0 *Uint32X2)

// Count Leading Sign bits (vector). This instruction counts the number of consecutive bits following the most significant bit that are the same as the most significant bit in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The count does not include the most significant bit itself.
//
//go:linkname VclsU16 VclsU16
//go:noescape
func VclsU16(r *Int16X4, v0 *Uint16X4)

// Count Leading Sign bits (vector). This instruction counts the number of consecutive bits following the most significant bit that are the same as the most significant bit in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The count does not include the most significant bit itself.
//
//go:linkname VclsS8 VclsS8
//go:noescape
func VclsS8(r *Int8X8, v0 *Int8X8)

// Count Leading Sign bits (vector). This instruction counts the number of consecutive bits following the most significant bit that are the same as the most significant bit in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The count does not include the most significant bit itself.
//
//go:linkname VclsS32 VclsS32
//go:noescape
func VclsS32(r *Int32X2, v0 *Int32X2)

// Count Leading Sign bits (vector). This instruction counts the number of consecutive bits following the most significant bit that are the same as the most significant bit in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The count does not include the most significant bit itself.
//
//go:linkname VclsS16 VclsS16
//go:noescape
func VclsS16(r *Int16X4, v0 *Int16X4)

// Compare unsigned less than
//
//go:linkname VcltqU8 VcltqU8
//go:noescape
func VcltqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Compare unsigned less than
//
//go:linkname VcltqU32 VcltqU32
//go:noescape
func VcltqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Compare unsigned less than
//
//go:linkname VcltqU16 VcltqU16
//go:noescape
func VcltqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Compare signed less than
//
//go:linkname VcltqS8 VcltqS8
//go:noescape
func VcltqS8(r *Uint8X16, v0 *Int8X16, v1 *Int8X16)

// Floating-point compare less than
//
//go:linkname VcltqF32 VcltqF32
//go:noescape
func VcltqF32(r *Uint32X4, v0 *Float32X4, v1 *Float32X4)

// Compare signed less than
//
//go:linkname VcltqS32 VcltqS32
//go:noescape
func VcltqS32(r *Uint32X4, v0 *Int32X4, v1 *Int32X4)

// Compare signed less than
//
//go:linkname VcltqS16 VcltqS16
//go:noescape
func VcltqS16(r *Uint16X8, v0 *Int16X8, v1 *Int16X8)

// Compare unsigned less than
//
//go:linkname VcltU8 VcltU8
//go:noescape
func VcltU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Compare unsigned less than
//
//go:linkname VcltU32 VcltU32
//go:noescape
func VcltU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Compare unsigned less than
//
//go:linkname VcltU16 VcltU16
//go:noescape
func VcltU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Compare signed less than
//
//go:linkname VcltS8 VcltS8
//go:noescape
func VcltS8(r *Uint8X8, v0 *Int8X8, v1 *Int8X8)

// Floating-point compare less than
//
//go:linkname VcltF32 VcltF32
//go:noescape
func VcltF32(r *Uint32X2, v0 *Float32X2, v1 *Float32X2)

// Compare signed less than
//
//go:linkname VcltS32 VcltS32
//go:noescape
func VcltS32(r *Uint32X2, v0 *Int32X2, v1 *Int32X2)

// Compare signed less than
//
//go:linkname VcltS16 VcltS16
//go:noescape
func VcltS16(r *Uint16X4, v0 *Int16X4, v1 *Int16X4)

// Count Leading Zero bits (vector). This instruction counts the number of consecutive zeros, starting from the most significant bit, in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VclzqU8 VclzqU8
//go:noescape
func VclzqU8(r *Uint8X16, v0 *Uint8X16)

// Count Leading Zero bits (vector). This instruction counts the number of consecutive zeros, starting from the most significant bit, in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VclzqU32 VclzqU32
//go:noescape
func VclzqU32(r *Uint32X4, v0 *Uint32X4)

// Count Leading Zero bits (vector). This instruction counts the number of consecutive zeros, starting from the most significant bit, in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VclzqU16 VclzqU16
//go:noescape
func VclzqU16(r *Uint16X8, v0 *Uint16X8)

// Count Leading Zero bits (vector). This instruction counts the number of consecutive zeros, starting from the most significant bit, in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VclzqS8 VclzqS8
//go:noescape
func VclzqS8(r *Int8X16, v0 *Int8X16)

// Count Leading Zero bits (vector). This instruction counts the number of consecutive zeros, starting from the most significant bit, in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VclzqS32 VclzqS32
//go:noescape
func VclzqS32(r *Int32X4, v0 *Int32X4)

// Count Leading Zero bits (vector). This instruction counts the number of consecutive zeros, starting from the most significant bit, in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VclzqS16 VclzqS16
//go:noescape
func VclzqS16(r *Int16X8, v0 *Int16X8)

// Count Leading Zero bits (vector). This instruction counts the number of consecutive zeros, starting from the most significant bit, in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VclzU8 VclzU8
//go:noescape
func VclzU8(r *Uint8X8, v0 *Uint8X8)

// Count Leading Zero bits (vector). This instruction counts the number of consecutive zeros, starting from the most significant bit, in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VclzU32 VclzU32
//go:noescape
func VclzU32(r *Uint32X2, v0 *Uint32X2)

// Count Leading Zero bits (vector). This instruction counts the number of consecutive zeros, starting from the most significant bit, in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VclzU16 VclzU16
//go:noescape
func VclzU16(r *Uint16X4, v0 *Uint16X4)

// Count Leading Zero bits (vector). This instruction counts the number of consecutive zeros, starting from the most significant bit, in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VclzS8 VclzS8
//go:noescape
func VclzS8(r *Int8X8, v0 *Int8X8)

// Count Leading Zero bits (vector). This instruction counts the number of consecutive zeros, starting from the most significant bit, in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VclzS32 VclzS32
//go:noescape
func VclzS32(r *Int32X2, v0 *Int32X2)

// Count Leading Zero bits (vector). This instruction counts the number of consecutive zeros, starting from the most significant bit, in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VclzS16 VclzS16
//go:noescape
func VclzS16(r *Int16X4, v0 *Int16X4)

// Population Count per byte. This instruction counts the number of bits that have a value of one in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VcntP8 VcntP8
//go:noescape
func VcntP8(r *Poly8X8, v0 *Poly8X8)

// Population Count per byte. This instruction counts the number of bits that have a value of one in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VcntqP8 VcntqP8
//go:noescape
func VcntqP8(r *Poly8X16, v0 *Poly8X16)

// Population Count per byte. This instruction counts the number of bits that have a value of one in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VcntqU8 VcntqU8
//go:noescape
func VcntqU8(r *Uint8X16, v0 *Uint8X16)

// Population Count per byte. This instruction counts the number of bits that have a value of one in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VcntqS8 VcntqS8
//go:noescape
func VcntqS8(r *Int8X16, v0 *Int8X16)

// Population Count per byte. This instruction counts the number of bits that have a value of one in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VcntU8 VcntU8
//go:noescape
func VcntU8(r *Uint8X8, v0 *Uint8X8)

// Population Count per byte. This instruction counts the number of bits that have a value of one in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VcntS8 VcntS8
//go:noescape
func VcntS8(r *Int8X8, v0 *Int8X8)

// Join two smaller vectors into a single larger vector
//
//go:linkname VcombineP8 VcombineP8
//go:noescape
func VcombineP8(r *Poly8X16, v0 *Poly8X8, v1 *Poly8X8)

// Join two smaller vectors into a single larger vector
//
//go:linkname VcombineP16 VcombineP16
//go:noescape
func VcombineP16(r *Poly16X8, v0 *Poly16X4, v1 *Poly16X4)

// Join two smaller vectors into a single larger vector
//
//go:linkname VcombineU8 VcombineU8
//go:noescape
func VcombineU8(r *Uint8X16, v0 *Uint8X8, v1 *Uint8X8)

// Join two smaller vectors into a single larger vector
//
//go:linkname VcombineU32 VcombineU32
//go:noescape
func VcombineU32(r *Uint32X4, v0 *Uint32X2, v1 *Uint32X2)

// Join two smaller vectors into a single larger vector
//
//go:linkname VcombineU64 VcombineU64
//go:noescape
func VcombineU64(r *Uint64X2, v0 *Uint64X1, v1 *Uint64X1)

// Join two smaller vectors into a single larger vector
//
//go:linkname VcombineU16 VcombineU16
//go:noescape
func VcombineU16(r *Uint16X8, v0 *Uint16X4, v1 *Uint16X4)

// Join two smaller vectors into a single larger vector
//
//go:linkname VcombineS8 VcombineS8
//go:noescape
func VcombineS8(r *Int8X16, v0 *Int8X8, v1 *Int8X8)

// Join two smaller vectors into a single larger vector
//
//go:linkname VcombineF32 VcombineF32
//go:noescape
func VcombineF32(r *Float32X4, v0 *Float32X2, v1 *Float32X2)

// Join two smaller vectors into a single larger vector
//
//go:linkname VcombineS32 VcombineS32
//go:noescape
func VcombineS32(r *Int32X4, v0 *Int32X2, v1 *Int32X2)

// Join two smaller vectors into a single larger vector
//
//go:linkname VcombineS64 VcombineS64
//go:noescape
func VcombineS64(r *Int64X2, v0 *Int64X1, v1 *Int64X1)

// Join two smaller vectors into a single larger vector
//
//go:linkname VcombineS16 VcombineS16
//go:noescape
func VcombineS16(r *Int16X8, v0 *Int16X4, v1 *Int16X4)

// Unsigned fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtqF32U32 VcvtqF32U32
//go:noescape
func VcvtqF32U32(r *Float32X4, v0 *Uint32X4)

// Signed fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtqF32S32 VcvtqF32S32
//go:noescape
func VcvtqF32S32(r *Float32X4, v0 *Int32X4)

// Unsigned fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtF32U32 VcvtF32U32
//go:noescape
func VcvtF32U32(r *Float32X2, v0 *Uint32X2)

// Signed fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtF32S32 VcvtF32S32
//go:noescape
func VcvtF32S32(r *Float32X2, v0 *Int32X2)

// Floating-point Convert to Signed fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point signed integer using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtqS32F32 VcvtqS32F32
//go:noescape
func VcvtqS32F32(r *Int32X4, v0 *Float32X4)

// Floating-point Convert to Signed fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point signed integer using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtS32F32 VcvtS32F32
//go:noescape
func VcvtS32F32(r *Int32X2, v0 *Float32X2)

// Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point unsigned integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.
//
//go:linkname VcvtqU32F32 VcvtqU32F32
//go:noescape
func VcvtqU32F32(r *Uint32X4, v0 *Float32X4)

// Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point unsigned integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.
//
//go:linkname VcvtU32F32 VcvtU32F32
//go:noescape
func VcvtU32F32(r *Uint32X2, v0 *Float32X2)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VdupNP8 VdupNP8
//go:noescape
func VdupNP8(r *Poly8X8, v0 *Poly8)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VdupNP16 VdupNP16
//go:noescape
func VdupNP16(r *Poly16X4, v0 *Poly16)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VdupqNP8 VdupqNP8
//go:noescape
func VdupqNP8(r *Poly8X16, v0 *Poly8)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VdupqNP16 VdupqNP16
//go:noescape
func VdupqNP16(r *Poly16X8, v0 *Poly16)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VdupqNU8 VdupqNU8
//go:noescape
func VdupqNU8(r *Uint8X16, v0 *Uint8)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VdupqNU32 VdupqNU32
//go:noescape
func VdupqNU32(r *Uint32X4, v0 *Uint32)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VdupqNU64 VdupqNU64
//go:noescape
func VdupqNU64(r *Uint64X2, v0 *Uint64)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VdupqNU16 VdupqNU16
//go:noescape
func VdupqNU16(r *Uint16X8, v0 *Uint16)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VdupqNS8 VdupqNS8
//go:noescape
func VdupqNS8(r *Int8X16, v0 *Int8)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VdupqNF32 VdupqNF32
//go:noescape
func VdupqNF32(r *Float32X4, v0 *Float32)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VdupqNS32 VdupqNS32
//go:noescape
func VdupqNS32(r *Int32X4, v0 *Int32)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VdupqNS64 VdupqNS64
//go:noescape
func VdupqNS64(r *Int64X2, v0 *Int64)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VdupqNS16 VdupqNS16
//go:noescape
func VdupqNS16(r *Int16X8, v0 *Int16)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VdupNU8 VdupNU8
//go:noescape
func VdupNU8(r *Uint8X8, v0 *Uint8)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VdupNU32 VdupNU32
//go:noescape
func VdupNU32(r *Uint32X2, v0 *Uint32)

// Insert vector element from another vector element. This instruction copies the vector element of the source SIMD&FP register to the specified vector element of the destination SIMD&FP register.
//
//go:linkname VdupNU64 VdupNU64
//go:noescape
func VdupNU64(r *Uint64X1, v0 *Uint64)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VdupNU16 VdupNU16
//go:noescape
func VdupNU16(r *Uint16X4, v0 *Uint16)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VdupNS8 VdupNS8
//go:noescape
func VdupNS8(r *Int8X8, v0 *Int8)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VdupNF32 VdupNF32
//go:noescape
func VdupNF32(r *Float32X2, v0 *Float32)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VdupNS32 VdupNS32
//go:noescape
func VdupNS32(r *Int32X2, v0 *Int32)

// Insert vector element from another vector element. This instruction copies the vector element of the source SIMD&FP register to the specified vector element of the destination SIMD&FP register.
//
//go:linkname VdupNS64 VdupNS64
//go:noescape
func VdupNS64(r *Int64X1, v0 *Int64)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VdupNS16 VdupNS16
//go:noescape
func VdupNS16(r *Int16X4, v0 *Int16)

// Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.
//
//go:linkname VeorqU8 VeorqU8
//go:noescape
func VeorqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.
//
//go:linkname VeorqU32 VeorqU32
//go:noescape
func VeorqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.
//
//go:linkname VeorqU64 VeorqU64
//go:noescape
func VeorqU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.
//
//go:linkname VeorqU16 VeorqU16
//go:noescape
func VeorqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.
//
//go:linkname VeorqS8 VeorqS8
//go:noescape
func VeorqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.
//
//go:linkname VeorqS32 VeorqS32
//go:noescape
func VeorqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.
//
//go:linkname VeorqS64 VeorqS64
//go:noescape
func VeorqS64(r *Int64X2, v0 *Int64X2, v1 *Int64X2)

// Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.
//
//go:linkname VeorqS16 VeorqS16
//go:noescape
func VeorqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.
//
//go:linkname VeorU8 VeorU8
//go:noescape
func VeorU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.
//
//go:linkname VeorU32 VeorU32
//go:noescape
func VeorU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.
//
//go:linkname VeorU64 VeorU64
//go:noescape
func VeorU64(r *Uint64X1, v0 *Uint64X1, v1 *Uint64X1)

// Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.
//
//go:linkname VeorU16 VeorU16
//go:noescape
func VeorU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.
//
//go:linkname VeorS8 VeorS8
//go:noescape
func VeorS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.
//
//go:linkname VeorS32 VeorS32
//go:noescape
func VeorS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.
//
//go:linkname VeorS64 VeorS64
//go:noescape
func VeorS64(r *Int64X1, v0 *Int64X1, v1 *Int64X1)

// Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.
//
//go:linkname VeorS16 VeorS16
//go:noescape
func VeorS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetHighP8 VgetHighP8
//go:noescape
func VgetHighP8(r *Poly8X8, v0 *Poly8X16)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetHighP16 VgetHighP16
//go:noescape
func VgetHighP16(r *Poly16X4, v0 *Poly16X8)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetHighU8 VgetHighU8
//go:noescape
func VgetHighU8(r *Uint8X8, v0 *Uint8X16)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetHighU32 VgetHighU32
//go:noescape
func VgetHighU32(r *Uint32X2, v0 *Uint32X4)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetHighU64 VgetHighU64
//go:noescape
func VgetHighU64(r *Uint64X1, v0 *Uint64X2)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetHighU16 VgetHighU16
//go:noescape
func VgetHighU16(r *Uint16X4, v0 *Uint16X8)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetHighS8 VgetHighS8
//go:noescape
func VgetHighS8(r *Int8X8, v0 *Int8X16)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetHighF32 VgetHighF32
//go:noescape
func VgetHighF32(r *Float32X2, v0 *Float32X4)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetHighS32 VgetHighS32
//go:noescape
func VgetHighS32(r *Int32X2, v0 *Int32X4)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetHighS64 VgetHighS64
//go:noescape
func VgetHighS64(r *Int64X1, v0 *Int64X2)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetHighS16 VgetHighS16
//go:noescape
func VgetHighS16(r *Int16X4, v0 *Int16X8)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetLowP8 VgetLowP8
//go:noescape
func VgetLowP8(r *Poly8X8, v0 *Poly8X16)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetLowP16 VgetLowP16
//go:noescape
func VgetLowP16(r *Poly16X4, v0 *Poly16X8)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetLowU8 VgetLowU8
//go:noescape
func VgetLowU8(r *Uint8X8, v0 *Uint8X16)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetLowU32 VgetLowU32
//go:noescape
func VgetLowU32(r *Uint32X2, v0 *Uint32X4)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetLowU64 VgetLowU64
//go:noescape
func VgetLowU64(r *Uint64X1, v0 *Uint64X2)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetLowU16 VgetLowU16
//go:noescape
func VgetLowU16(r *Uint16X4, v0 *Uint16X8)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetLowS8 VgetLowS8
//go:noescape
func VgetLowS8(r *Int8X8, v0 *Int8X16)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetLowF32 VgetLowF32
//go:noescape
func VgetLowF32(r *Float32X2, v0 *Float32X4)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetLowS32 VgetLowS32
//go:noescape
func VgetLowS32(r *Int32X2, v0 *Int32X4)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetLowS64 VgetLowS64
//go:noescape
func VgetLowS64(r *Int64X1, v0 *Int64X2)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetLowS16 VgetLowS16
//go:noescape
func VgetLowS16(r *Int16X4, v0 *Int16X8)

// Unsigned Halving Add. This instruction adds corresponding unsigned integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhaddqU8 VhaddqU8
//go:noescape
func VhaddqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Unsigned Halving Add. This instruction adds corresponding unsigned integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhaddqU32 VhaddqU32
//go:noescape
func VhaddqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Unsigned Halving Add. This instruction adds corresponding unsigned integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhaddqU16 VhaddqU16
//go:noescape
func VhaddqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Signed Halving Add. This instruction adds corresponding signed integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhaddqS8 VhaddqS8
//go:noescape
func VhaddqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Signed Halving Add. This instruction adds corresponding signed integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhaddqS32 VhaddqS32
//go:noescape
func VhaddqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Signed Halving Add. This instruction adds corresponding signed integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhaddqS16 VhaddqS16
//go:noescape
func VhaddqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Unsigned Halving Add. This instruction adds corresponding unsigned integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhaddU8 VhaddU8
//go:noescape
func VhaddU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Unsigned Halving Add. This instruction adds corresponding unsigned integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhaddU32 VhaddU32
//go:noescape
func VhaddU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Unsigned Halving Add. This instruction adds corresponding unsigned integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhaddU16 VhaddU16
//go:noescape
func VhaddU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Signed Halving Add. This instruction adds corresponding signed integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhaddS8 VhaddS8
//go:noescape
func VhaddS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Signed Halving Add. This instruction adds corresponding signed integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhaddS32 VhaddS32
//go:noescape
func VhaddS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Signed Halving Add. This instruction adds corresponding signed integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhaddS16 VhaddS16
//go:noescape
func VhaddS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Unsigned Halving Subtract. This instruction subtracts the vector elements in the second source SIMD&FP register from the corresponding vector elements in the first source SIMD&FP register, shifts each result right one bit, places each result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhsubqU8 VhsubqU8
//go:noescape
func VhsubqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Unsigned Halving Subtract. This instruction subtracts the vector elements in the second source SIMD&FP register from the corresponding vector elements in the first source SIMD&FP register, shifts each result right one bit, places each result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhsubqU32 VhsubqU32
//go:noescape
func VhsubqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Unsigned Halving Subtract. This instruction subtracts the vector elements in the second source SIMD&FP register from the corresponding vector elements in the first source SIMD&FP register, shifts each result right one bit, places each result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhsubqU16 VhsubqU16
//go:noescape
func VhsubqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Signed Halving Subtract. This instruction subtracts the elements in the vector in the second source SIMD&FP register from the corresponding elements in the vector in the first source SIMD&FP register, shifts each result right one bit, places each result into elements of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhsubqS8 VhsubqS8
//go:noescape
func VhsubqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Signed Halving Subtract. This instruction subtracts the elements in the vector in the second source SIMD&FP register from the corresponding elements in the vector in the first source SIMD&FP register, shifts each result right one bit, places each result into elements of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhsubqS32 VhsubqS32
//go:noescape
func VhsubqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Signed Halving Subtract. This instruction subtracts the elements in the vector in the second source SIMD&FP register from the corresponding elements in the vector in the first source SIMD&FP register, shifts each result right one bit, places each result into elements of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhsubqS16 VhsubqS16
//go:noescape
func VhsubqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Unsigned Halving Subtract. This instruction subtracts the vector elements in the second source SIMD&FP register from the corresponding vector elements in the first source SIMD&FP register, shifts each result right one bit, places each result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhsubU8 VhsubU8
//go:noescape
func VhsubU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Unsigned Halving Subtract. This instruction subtracts the vector elements in the second source SIMD&FP register from the corresponding vector elements in the first source SIMD&FP register, shifts each result right one bit, places each result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhsubU32 VhsubU32
//go:noescape
func VhsubU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Unsigned Halving Subtract. This instruction subtracts the vector elements in the second source SIMD&FP register from the corresponding vector elements in the first source SIMD&FP register, shifts each result right one bit, places each result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhsubU16 VhsubU16
//go:noescape
func VhsubU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Signed Halving Subtract. This instruction subtracts the elements in the vector in the second source SIMD&FP register from the corresponding elements in the vector in the first source SIMD&FP register, shifts each result right one bit, places each result into elements of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhsubS8 VhsubS8
//go:noescape
func VhsubS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Signed Halving Subtract. This instruction subtracts the elements in the vector in the second source SIMD&FP register from the corresponding elements in the vector in the first source SIMD&FP register, shifts each result right one bit, places each result into elements of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhsubS32 VhsubS32
//go:noescape
func VhsubS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Signed Halving Subtract. This instruction subtracts the elements in the vector in the second source SIMD&FP register from the corresponding elements in the vector in the first source SIMD&FP register, shifts each result right one bit, places each result into elements of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VhsubS16 VhsubS16
//go:noescape
func VhsubS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Unsigned Maximum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the larger of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmaxqU8 VmaxqU8
//go:noescape
func VmaxqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Unsigned Maximum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the larger of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmaxqU32 VmaxqU32
//go:noescape
func VmaxqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Unsigned Maximum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the larger of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmaxqU16 VmaxqU16
//go:noescape
func VmaxqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Signed Maximum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the larger of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmaxqS8 VmaxqS8
//go:noescape
func VmaxqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Floating-point Maximum (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, places the larger of each of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmaxqF32 VmaxqF32
//go:noescape
func VmaxqF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Signed Maximum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the larger of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmaxqS32 VmaxqS32
//go:noescape
func VmaxqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Signed Maximum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the larger of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmaxqS16 VmaxqS16
//go:noescape
func VmaxqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Unsigned Maximum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the larger of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmaxU8 VmaxU8
//go:noescape
func VmaxU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Unsigned Maximum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the larger of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmaxU32 VmaxU32
//go:noescape
func VmaxU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Unsigned Maximum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the larger of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmaxU16 VmaxU16
//go:noescape
func VmaxU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Signed Maximum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the larger of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmaxS8 VmaxS8
//go:noescape
func VmaxS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Floating-point Maximum (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, places the larger of each of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmaxF32 VmaxF32
//go:noescape
func VmaxF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Signed Maximum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the larger of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmaxS32 VmaxS32
//go:noescape
func VmaxS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Signed Maximum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the larger of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmaxS16 VmaxS16
//go:noescape
func VmaxS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Unsigned Minimum (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, places the smaller of each of the two unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VminqU8 VminqU8
//go:noescape
func VminqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Unsigned Minimum (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, places the smaller of each of the two unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VminqU32 VminqU32
//go:noescape
func VminqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Unsigned Minimum (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, places the smaller of each of the two unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VminqU16 VminqU16
//go:noescape
func VminqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Signed Minimum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the smaller of each of the two signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VminqS8 VminqS8
//go:noescape
func VminqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Floating-point minimum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the smaller of each of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VminqF32 VminqF32
//go:noescape
func VminqF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Signed Minimum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the smaller of each of the two signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VminqS32 VminqS32
//go:noescape
func VminqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Signed Minimum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the smaller of each of the two signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VminqS16 VminqS16
//go:noescape
func VminqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Unsigned Minimum (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, places the smaller of each of the two unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VminU8 VminU8
//go:noescape
func VminU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Unsigned Minimum (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, places the smaller of each of the two unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VminU32 VminU32
//go:noescape
func VminU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Unsigned Minimum (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, places the smaller of each of the two unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VminU16 VminU16
//go:noescape
func VminU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Signed Minimum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the smaller of each of the two signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VminS8 VminS8
//go:noescape
func VminS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Floating-point minimum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the smaller of each of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VminF32 VminF32
//go:noescape
func VminF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Signed Minimum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the smaller of each of the two signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VminS32 VminS32
//go:noescape
func VminS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Signed Minimum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the smaller of each of the two signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VminS16 VminS16
//go:noescape
func VminS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Multiply-Add to accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlaqU8 VmlaqU8
//go:noescape
func VmlaqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16, v2 *Uint8X16)

// Multiply-Add to accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlaqU32 VmlaqU32
//go:noescape
func VmlaqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4, v2 *Uint32X4)

// Multiply-Add to accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlaqU16 VmlaqU16
//go:noescape
func VmlaqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8, v2 *Uint16X8)

// Multiply-Add to accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlaqS8 VmlaqS8
//go:noescape
func VmlaqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16, v2 *Int8X16)

// Floating-point multiply-add to accumulator
//
//go:linkname VmlaqF32 VmlaqF32
//go:noescape
func VmlaqF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4, v2 *Float32X4)

// Multiply-Add to accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlaqS32 VmlaqS32
//go:noescape
func VmlaqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4, v2 *Int32X4)

// Multiply-Add to accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlaqS16 VmlaqS16
//go:noescape
func VmlaqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8, v2 *Int16X8)

// Multiply-Add to accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlaU8 VmlaU8
//go:noescape
func VmlaU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8, v2 *Uint8X8)

// Multiply-Add to accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlaU32 VmlaU32
//go:noescape
func VmlaU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2, v2 *Uint32X2)

// Multiply-Add to accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlaU16 VmlaU16
//go:noescape
func VmlaU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4, v2 *Uint16X4)

// Multiply-Add to accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlaS8 VmlaS8
//go:noescape
func VmlaS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8, v2 *Int8X8)

// Floating-point multiply-add to accumulator
//
//go:linkname VmlaF32 VmlaF32
//go:noescape
func VmlaF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2, v2 *Float32X2)

// Multiply-Add to accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlaS32 VmlaS32
//go:noescape
func VmlaS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2, v2 *Int32X2)

// Multiply-Add to accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlaS16 VmlaS16
//go:noescape
func VmlaS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4, v2 *Int16X4)

// Vector multiply accumulate with scalar
//
//go:linkname VmlaqNU32 VmlaqNU32
//go:noescape
func VmlaqNU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4, v2 *Uint32)

// Vector multiply accumulate with scalar
//
//go:linkname VmlaqNU16 VmlaqNU16
//go:noescape
func VmlaqNU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8, v2 *Uint16)

// Vector multiply accumulate with scalar
//
//go:linkname VmlaqNF32 VmlaqNF32
//go:noescape
func VmlaqNF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4, v2 *Float32)

// Vector multiply accumulate with scalar
//
//go:linkname VmlaqNS32 VmlaqNS32
//go:noescape
func VmlaqNS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4, v2 *Int32)

// Vector multiply accumulate with scalar
//
//go:linkname VmlaqNS16 VmlaqNS16
//go:noescape
func VmlaqNS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8, v2 *Int16)

// Vector multiply accumulate with scalar
//
//go:linkname VmlaNU32 VmlaNU32
//go:noescape
func VmlaNU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2, v2 *Uint32)

// Vector multiply accumulate with scalar
//
//go:linkname VmlaNU16 VmlaNU16
//go:noescape
func VmlaNU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4, v2 *Uint16)

// Vector multiply accumulate with scalar
//
//go:linkname VmlaNF32 VmlaNF32
//go:noescape
func VmlaNF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2, v2 *Float32)

// Vector multiply accumulate with scalar
//
//go:linkname VmlaNS32 VmlaNS32
//go:noescape
func VmlaNS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2, v2 *Int32)

// Vector multiply accumulate with scalar
//
//go:linkname VmlaNS16 VmlaNS16
//go:noescape
func VmlaNS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4, v2 *Int16)

// Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlsqU8 VmlsqU8
//go:noescape
func VmlsqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16, v2 *Uint8X16)

// Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlsqU32 VmlsqU32
//go:noescape
func VmlsqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4, v2 *Uint32X4)

// Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlsqU16 VmlsqU16
//go:noescape
func VmlsqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8, v2 *Uint16X8)

// Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlsqS8 VmlsqS8
//go:noescape
func VmlsqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16, v2 *Int8X16)

// Multiply-subtract from accumulator
//
//go:linkname VmlsqF32 VmlsqF32
//go:noescape
func VmlsqF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4, v2 *Float32X4)

// Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlsqS32 VmlsqS32
//go:noescape
func VmlsqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4, v2 *Int32X4)

// Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlsqS16 VmlsqS16
//go:noescape
func VmlsqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8, v2 *Int16X8)

// Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlsU8 VmlsU8
//go:noescape
func VmlsU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8, v2 *Uint8X8)

// Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlsU32 VmlsU32
//go:noescape
func VmlsU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2, v2 *Uint32X2)

// Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlsU16 VmlsU16
//go:noescape
func VmlsU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4, v2 *Uint16X4)

// Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlsS8 VmlsS8
//go:noescape
func VmlsS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8, v2 *Int8X8)

// Multiply-subtract from accumulator
//
//go:linkname VmlsF32 VmlsF32
//go:noescape
func VmlsF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2, v2 *Float32X2)

// Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlsS32 VmlsS32
//go:noescape
func VmlsS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2, v2 *Int32X2)

// Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register.
//
//go:linkname VmlsS16 VmlsS16
//go:noescape
func VmlsS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4, v2 *Int16X4)

// Vector multiply subtract with scalar
//
//go:linkname VmlsqNU32 VmlsqNU32
//go:noescape
func VmlsqNU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4, v2 *Uint32)

// Vector multiply subtract with scalar
//
//go:linkname VmlsqNU16 VmlsqNU16
//go:noescape
func VmlsqNU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8, v2 *Uint16)

// Vector multiply subtract with scalar
//
//go:linkname VmlsqNF32 VmlsqNF32
//go:noescape
func VmlsqNF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4, v2 *Float32)

// Vector multiply subtract with scalar
//
//go:linkname VmlsqNS32 VmlsqNS32
//go:noescape
func VmlsqNS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4, v2 *Int32)

// Vector multiply subtract with scalar
//
//go:linkname VmlsqNS16 VmlsqNS16
//go:noescape
func VmlsqNS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8, v2 *Int16)

// Vector multiply subtract with scalar
//
//go:linkname VmlsNU32 VmlsNU32
//go:noescape
func VmlsNU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2, v2 *Uint32)

// Vector multiply subtract with scalar
//
//go:linkname VmlsNU16 VmlsNU16
//go:noescape
func VmlsNU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4, v2 *Uint16)

// Vector multiply subtract with scalar
//
//go:linkname VmlsNF32 VmlsNF32
//go:noescape
func VmlsNF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2, v2 *Float32)

// Vector multiply subtract with scalar
//
//go:linkname VmlsNS32 VmlsNS32
//go:noescape
func VmlsNS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2, v2 *Int32)

// Vector multiply subtract with scalar
//
//go:linkname VmlsNS16 VmlsNS16
//go:noescape
func VmlsNS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4, v2 *Int16)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovNP8 VmovNP8
//go:noescape
func VmovNP8(r *Poly8X8, v0 *Poly8)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovNP16 VmovNP16
//go:noescape
func VmovNP16(r *Poly16X4, v0 *Poly16)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovqNP8 VmovqNP8
//go:noescape
func VmovqNP8(r *Poly8X16, v0 *Poly8)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovqNP16 VmovqNP16
//go:noescape
func VmovqNP16(r *Poly16X8, v0 *Poly16)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovqNU8 VmovqNU8
//go:noescape
func VmovqNU8(r *Uint8X16, v0 *Uint8)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovqNU32 VmovqNU32
//go:noescape
func VmovqNU32(r *Uint32X4, v0 *Uint32)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovqNU64 VmovqNU64
//go:noescape
func VmovqNU64(r *Uint64X2, v0 *Uint64)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovqNU16 VmovqNU16
//go:noescape
func VmovqNU16(r *Uint16X8, v0 *Uint16)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovqNS8 VmovqNS8
//go:noescape
func VmovqNS8(r *Int8X16, v0 *Int8)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovqNF32 VmovqNF32
//go:noescape
func VmovqNF32(r *Float32X4, v0 *Float32)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovqNS32 VmovqNS32
//go:noescape
func VmovqNS32(r *Int32X4, v0 *Int32)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovqNS64 VmovqNS64
//go:noescape
func VmovqNS64(r *Int64X2, v0 *Int64)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovqNS16 VmovqNS16
//go:noescape
func VmovqNS16(r *Int16X8, v0 *Int16)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovNU8 VmovNU8
//go:noescape
func VmovNU8(r *Uint8X8, v0 *Uint8)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovNU32 VmovNU32
//go:noescape
func VmovNU32(r *Uint32X2, v0 *Uint32)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovNU64 VmovNU64
//go:noescape
func VmovNU64(r *Uint64X1, v0 *Uint64)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovNU16 VmovNU16
//go:noescape
func VmovNU16(r *Uint16X4, v0 *Uint16)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovNS8 VmovNS8
//go:noescape
func VmovNS8(r *Int8X8, v0 *Int8)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovNF32 VmovNF32
//go:noescape
func VmovNF32(r *Float32X2, v0 *Float32)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovNS32 VmovNS32
//go:noescape
func VmovNS32(r *Int32X2, v0 *Int32)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovNS64 VmovNS64
//go:noescape
func VmovNS64(r *Int64X1, v0 *Int64)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovNS16 VmovNS16
//go:noescape
func VmovNS16(r *Int16X4, v0 *Int16)

// Vector move
//
//go:linkname VmovlU8 VmovlU8
//go:noescape
func VmovlU8(r *Uint16X8, v0 *Uint8X8)

// Vector move
//
//go:linkname VmovlU32 VmovlU32
//go:noescape
func VmovlU32(r *Uint64X2, v0 *Uint32X2)

// Vector move
//
//go:linkname VmovlU16 VmovlU16
//go:noescape
func VmovlU16(r *Uint32X4, v0 *Uint16X4)

// Vector move
//
//go:linkname VmovlS8 VmovlS8
//go:noescape
func VmovlS8(r *Int16X8, v0 *Int8X8)

// Vector move
//
//go:linkname VmovlS32 VmovlS32
//go:noescape
func VmovlS32(r *Int64X2, v0 *Int32X2)

// Vector move
//
//go:linkname VmovlS16 VmovlS16
//go:noescape
func VmovlS16(r *Int32X4, v0 *Int16X4)

// Extract Narrow. This instruction reads each vector element from the source SIMD&FP register, narrows each value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.
//
//go:linkname VmovnU32 VmovnU32
//go:noescape
func VmovnU32(r *Uint16X4, v0 *Uint32X4)

// Extract Narrow. This instruction reads each vector element from the source SIMD&FP register, narrows each value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.
//
//go:linkname VmovnU64 VmovnU64
//go:noescape
func VmovnU64(r *Uint32X2, v0 *Uint64X2)

// Extract Narrow. This instruction reads each vector element from the source SIMD&FP register, narrows each value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.
//
//go:linkname VmovnU16 VmovnU16
//go:noescape
func VmovnU16(r *Uint8X8, v0 *Uint16X8)

// Extract Narrow. This instruction reads each vector element from the source SIMD&FP register, narrows each value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.
//
//go:linkname VmovnS32 VmovnS32
//go:noescape
func VmovnS32(r *Int16X4, v0 *Int32X4)

// Extract Narrow. This instruction reads each vector element from the source SIMD&FP register, narrows each value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.
//
//go:linkname VmovnS64 VmovnS64
//go:noescape
func VmovnS64(r *Int32X2, v0 *Int64X2)

// Extract Narrow. This instruction reads each vector element from the source SIMD&FP register, narrows each value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.
//
//go:linkname VmovnS16 VmovnS16
//go:noescape
func VmovnS16(r *Int8X8, v0 *Int16X8)

// Multiply (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulqU8 VmulqU8
//go:noescape
func VmulqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Multiply (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulqU32 VmulqU32
//go:noescape
func VmulqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Multiply (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulqU16 VmulqU16
//go:noescape
func VmulqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Multiply (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulqS8 VmulqS8
//go:noescape
func VmulqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Floating-point Multiply (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulqF32 VmulqF32
//go:noescape
func VmulqF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Multiply (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulqS32 VmulqS32
//go:noescape
func VmulqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Multiply (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulqS16 VmulqS16
//go:noescape
func VmulqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Multiply (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulU8 VmulU8
//go:noescape
func VmulU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Multiply (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulU32 VmulU32
//go:noescape
func VmulU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Multiply (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulU16 VmulU16
//go:noescape
func VmulU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Multiply (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulS8 VmulS8
//go:noescape
func VmulS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Floating-point Multiply (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulF32 VmulF32
//go:noescape
func VmulF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Multiply (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulS32 VmulS32
//go:noescape
func VmulS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Multiply (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulS16 VmulS16
//go:noescape
func VmulS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Polynomial Multiply. This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulP8 VmulP8
//go:noescape
func VmulP8(r *Poly8X8, v0 *Poly8X8, v1 *Poly8X8)

// Polynomial Multiply. This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulqP8 VmulqP8
//go:noescape
func VmulqP8(r *Poly8X16, v0 *Poly8X16, v1 *Poly8X16)

// Vector multiply by scalar
//
//go:linkname VmulqNU32 VmulqNU32
//go:noescape
func VmulqNU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32)

// Vector multiply by scalar
//
//go:linkname VmulqNU16 VmulqNU16
//go:noescape
func VmulqNU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16)

// Vector multiply by scalar
//
//go:linkname VmulqNF32 VmulqNF32
//go:noescape
func VmulqNF32(r *Float32X4, v0 *Float32X4, v1 *Float32)

// Vector multiply by scalar
//
//go:linkname VmulqNS32 VmulqNS32
//go:noescape
func VmulqNS32(r *Int32X4, v0 *Int32X4, v1 *Int32)

// Vector multiply by scalar
//
//go:linkname VmulqNS16 VmulqNS16
//go:noescape
func VmulqNS16(r *Int16X8, v0 *Int16X8, v1 *Int16)

// Vector multiply by scalar
//
//go:linkname VmulNU32 VmulNU32
//go:noescape
func VmulNU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32)

// Vector multiply by scalar
//
//go:linkname VmulNU16 VmulNU16
//go:noescape
func VmulNU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16)

// Vector multiply by scalar
//
//go:linkname VmulNF32 VmulNF32
//go:noescape
func VmulNF32(r *Float32X2, v0 *Float32X2, v1 *Float32)

// Vector multiply by scalar
//
//go:linkname VmulNS32 VmulNS32
//go:noescape
func VmulNS32(r *Int32X2, v0 *Int32X2, v1 *Int32)

// Vector multiply by scalar
//
//go:linkname VmulNS16 VmulNS16
//go:noescape
func VmulNS16(r *Int16X4, v0 *Int16X4, v1 *Int16)

// Polynomial Multiply Long. This instruction multiplies corresponding elements in the lower or upper half of the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmullP8 VmullP8
//go:noescape
func VmullP8(r *Poly16X8, v0 *Poly8X8, v1 *Poly8X8)

// Unsigned Multiply long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.
//
//go:linkname VmullU8 VmullU8
//go:noescape
func VmullU8(r *Uint16X8, v0 *Uint8X8, v1 *Uint8X8)

// Unsigned Multiply long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.
//
//go:linkname VmullU32 VmullU32
//go:noescape
func VmullU32(r *Uint64X2, v0 *Uint32X2, v1 *Uint32X2)

// Unsigned Multiply long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.
//
//go:linkname VmullU16 VmullU16
//go:noescape
func VmullU16(r *Uint32X4, v0 *Uint16X4, v1 *Uint16X4)

// Signed Multiply Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmullS8 VmullS8
//go:noescape
func VmullS8(r *Int16X8, v0 *Int8X8, v1 *Int8X8)

// Signed Multiply Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmullS32 VmullS32
//go:noescape
func VmullS32(r *Int64X2, v0 *Int32X2, v1 *Int32X2)

// Signed Multiply Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmullS16 VmullS16
//go:noescape
func VmullS16(r *Int32X4, v0 *Int16X4, v1 *Int16X4)

// Vector long multiply with scalar
//
//go:linkname VmullNU32 VmullNU32
//go:noescape
func VmullNU32(r *Uint64X2, v0 *Uint32X2, v1 *Uint32)

// Vector long multiply with scalar
//
//go:linkname VmullNU16 VmullNU16
//go:noescape
func VmullNU16(r *Uint32X4, v0 *Uint16X4, v1 *Uint16)

// Vector long multiply with scalar
//
//go:linkname VmullNS32 VmullNS32
//go:noescape
func VmullNS32(r *Int64X2, v0 *Int32X2, v1 *Int32)

// Vector long multiply with scalar
//
//go:linkname VmullNS16 VmullNS16
//go:noescape
func VmullNS16(r *Int32X4, v0 *Int16X4, v1 *Int16)

// Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmvnP8 VmvnP8
//go:noescape
func VmvnP8(r *Poly8X8, v0 *Poly8X8)

// Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmvnqP8 VmvnqP8
//go:noescape
func VmvnqP8(r *Poly8X16, v0 *Poly8X16)

// Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmvnqU8 VmvnqU8
//go:noescape
func VmvnqU8(r *Uint8X16, v0 *Uint8X16)

// Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmvnqU32 VmvnqU32
//go:noescape
func VmvnqU32(r *Uint32X4, v0 *Uint32X4)

// Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmvnqU16 VmvnqU16
//go:noescape
func VmvnqU16(r *Uint16X8, v0 *Uint16X8)

// Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmvnqS8 VmvnqS8
//go:noescape
func VmvnqS8(r *Int8X16, v0 *Int8X16)

// Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmvnqS32 VmvnqS32
//go:noescape
func VmvnqS32(r *Int32X4, v0 *Int32X4)

// Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmvnqS16 VmvnqS16
//go:noescape
func VmvnqS16(r *Int16X8, v0 *Int16X8)

// Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmvnU8 VmvnU8
//go:noescape
func VmvnU8(r *Uint8X8, v0 *Uint8X8)

// Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmvnU32 VmvnU32
//go:noescape
func VmvnU32(r *Uint32X2, v0 *Uint32X2)

// Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmvnU16 VmvnU16
//go:noescape
func VmvnU16(r *Uint16X4, v0 *Uint16X4)

// Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmvnS8 VmvnS8
//go:noescape
func VmvnS8(r *Int8X8, v0 *Int8X8)

// Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmvnS32 VmvnS32
//go:noescape
func VmvnS32(r *Int32X2, v0 *Int32X2)

// Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmvnS16 VmvnS16
//go:noescape
func VmvnS16(r *Int16X4, v0 *Int16X4)

// Negate (vector). This instruction reads each vector element from the source SIMD&FP register, negates each value, puts the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VnegqS8 VnegqS8
//go:noescape
func VnegqS8(r *Int8X16, v0 *Int8X16)

// Floating-point Negate (vector). This instruction negates the value of each vector element in the source SIMD&FP register, writes the result to a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VnegqF32 VnegqF32
//go:noescape
func VnegqF32(r *Float32X4, v0 *Float32X4)

// Negate (vector). This instruction reads each vector element from the source SIMD&FP register, negates each value, puts the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VnegqS32 VnegqS32
//go:noescape
func VnegqS32(r *Int32X4, v0 *Int32X4)

// Negate (vector). This instruction reads each vector element from the source SIMD&FP register, negates each value, puts the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VnegqS16 VnegqS16
//go:noescape
func VnegqS16(r *Int16X8, v0 *Int16X8)

// Negate (vector). This instruction reads each vector element from the source SIMD&FP register, negates each value, puts the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VnegS8 VnegS8
//go:noescape
func VnegS8(r *Int8X8, v0 *Int8X8)

// Floating-point Negate (vector). This instruction negates the value of each vector element in the source SIMD&FP register, writes the result to a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VnegF32 VnegF32
//go:noescape
func VnegF32(r *Float32X2, v0 *Float32X2)

// Negate (vector). This instruction reads each vector element from the source SIMD&FP register, negates each value, puts the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VnegS32 VnegS32
//go:noescape
func VnegS32(r *Int32X2, v0 *Int32X2)

// Negate (vector). This instruction reads each vector element from the source SIMD&FP register, negates each value, puts the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VnegS16 VnegS16
//go:noescape
func VnegS16(r *Int16X4, v0 *Int16X4)

// Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VornqU8 VornqU8
//go:noescape
func VornqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VornqU32 VornqU32
//go:noescape
func VornqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VornqU64 VornqU64
//go:noescape
func VornqU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VornqU16 VornqU16
//go:noescape
func VornqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VornqS8 VornqS8
//go:noescape
func VornqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VornqS32 VornqS32
//go:noescape
func VornqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VornqS64 VornqS64
//go:noescape
func VornqS64(r *Int64X2, v0 *Int64X2, v1 *Int64X2)

// Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VornqS16 VornqS16
//go:noescape
func VornqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VornU8 VornU8
//go:noescape
func VornU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VornU32 VornU32
//go:noescape
func VornU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VornU64 VornU64
//go:noescape
func VornU64(r *Uint64X1, v0 *Uint64X1, v1 *Uint64X1)

// Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VornU16 VornU16
//go:noescape
func VornU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VornS8 VornS8
//go:noescape
func VornS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VornS32 VornS32
//go:noescape
func VornS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VornS64 VornS64
//go:noescape
func VornS64(r *Int64X1, v0 *Int64X1, v1 *Int64X1)

// Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VornS16 VornS16
//go:noescape
func VornS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Bitwise inclusive OR (vector, register). This instruction performs a bitwise OR between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VorrqU8 VorrqU8
//go:noescape
func VorrqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Bitwise inclusive OR (vector, register). This instruction performs a bitwise OR between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VorrqU32 VorrqU32
//go:noescape
func VorrqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Bitwise inclusive OR (vector, register). This instruction performs a bitwise OR between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VorrqU64 VorrqU64
//go:noescape
func VorrqU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// Bitwise inclusive OR (vector, register). This instruction performs a bitwise OR between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VorrqU16 VorrqU16
//go:noescape
func VorrqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Bitwise inclusive OR (vector, register). This instruction performs a bitwise OR between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VorrqS8 VorrqS8
//go:noescape
func VorrqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Bitwise inclusive OR (vector, register). This instruction performs a bitwise OR between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VorrqS32 VorrqS32
//go:noescape
func VorrqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Bitwise inclusive OR (vector, register). This instruction performs a bitwise OR between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VorrqS64 VorrqS64
//go:noescape
func VorrqS64(r *Int64X2, v0 *Int64X2, v1 *Int64X2)

// Bitwise inclusive OR (vector, register). This instruction performs a bitwise OR between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VorrqS16 VorrqS16
//go:noescape
func VorrqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Bitwise inclusive OR (vector, register). This instruction performs a bitwise OR between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VorrU8 VorrU8
//go:noescape
func VorrU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Bitwise inclusive OR (vector, register). This instruction performs a bitwise OR between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VorrU32 VorrU32
//go:noescape
func VorrU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Bitwise inclusive OR (vector, register). This instruction performs a bitwise OR between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VorrU64 VorrU64
//go:noescape
func VorrU64(r *Uint64X1, v0 *Uint64X1, v1 *Uint64X1)

// Bitwise inclusive OR (vector, register). This instruction performs a bitwise OR between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VorrU16 VorrU16
//go:noescape
func VorrU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Bitwise inclusive OR (vector, register). This instruction performs a bitwise OR between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VorrS8 VorrS8
//go:noescape
func VorrS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Bitwise inclusive OR (vector, register). This instruction performs a bitwise OR between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VorrS32 VorrS32
//go:noescape
func VorrS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Bitwise inclusive OR (vector, register). This instruction performs a bitwise OR between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VorrS64 VorrS64
//go:noescape
func VorrS64(r *Int64X1, v0 *Int64X1, v1 *Int64X1)

// Bitwise inclusive OR (vector, register). This instruction performs a bitwise OR between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname VorrS16 VorrS16
//go:noescape
func VorrS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Unsigned Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&FP register and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpadalqU8 VpadalqU8
//go:noescape
func VpadalqU8(r *Uint16X8, v0 *Uint16X8, v1 *Uint8X16)

// Unsigned Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&FP register and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpadalqU32 VpadalqU32
//go:noescape
func VpadalqU32(r *Uint64X2, v0 *Uint64X2, v1 *Uint32X4)

// Unsigned Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&FP register and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpadalqU16 VpadalqU16
//go:noescape
func VpadalqU16(r *Uint32X4, v0 *Uint32X4, v1 *Uint16X8)

// Signed Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&FP register and accumulates the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpadalqS8 VpadalqS8
//go:noescape
func VpadalqS8(r *Int16X8, v0 *Int16X8, v1 *Int8X16)

// Signed Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&FP register and accumulates the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpadalqS32 VpadalqS32
//go:noescape
func VpadalqS32(r *Int64X2, v0 *Int64X2, v1 *Int32X4)

// Signed Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&FP register and accumulates the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpadalqS16 VpadalqS16
//go:noescape
func VpadalqS16(r *Int32X4, v0 *Int32X4, v1 *Int16X8)

// Unsigned Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&FP register and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpadalU8 VpadalU8
//go:noescape
func VpadalU8(r *Uint16X4, v0 *Uint16X4, v1 *Uint8X8)

// Unsigned Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&FP register and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpadalU32 VpadalU32
//go:noescape
func VpadalU32(r *Uint64X1, v0 *Uint64X1, v1 *Uint32X2)

// Unsigned Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&FP register and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpadalU16 VpadalU16
//go:noescape
func VpadalU16(r *Uint32X2, v0 *Uint32X2, v1 *Uint16X4)

// Signed Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&FP register and accumulates the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpadalS8 VpadalS8
//go:noescape
func VpadalS8(r *Int16X4, v0 *Int16X4, v1 *Int8X8)

// Signed Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&FP register and accumulates the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpadalS32 VpadalS32
//go:noescape
func VpadalS32(r *Int64X1, v0 *Int64X1, v1 *Int32X2)

// Signed Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&FP register and accumulates the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpadalS16 VpadalS16
//go:noescape
func VpadalS16(r *Int32X2, v0 *Int32X2, v1 *Int16X4)

// Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpaddU8 VpaddU8
//go:noescape
func VpaddU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpaddU32 VpaddU32
//go:noescape
func VpaddU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpaddU16 VpaddU16
//go:noescape
func VpaddU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpaddS8 VpaddS8
//go:noescape
func VpaddS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Floating-point Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpaddF32 VpaddF32
//go:noescape
func VpaddF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpaddS32 VpaddS32
//go:noescape
func VpaddS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpaddS16 VpaddS16
//go:noescape
func VpaddS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Unsigned Add Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpaddlqU8 VpaddlqU8
//go:noescape
func VpaddlqU8(r *Uint16X8, v0 *Uint8X16)

// Unsigned Add Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpaddlqU32 VpaddlqU32
//go:noescape
func VpaddlqU32(r *Uint64X2, v0 *Uint32X4)

// Unsigned Add Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpaddlqU16 VpaddlqU16
//go:noescape
func VpaddlqU16(r *Uint32X4, v0 *Uint16X8)

// Signed Add Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpaddlqS8 VpaddlqS8
//go:noescape
func VpaddlqS8(r *Int16X8, v0 *Int8X16)

// Signed Add Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpaddlqS32 VpaddlqS32
//go:noescape
func VpaddlqS32(r *Int64X2, v0 *Int32X4)

// Signed Add Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpaddlqS16 VpaddlqS16
//go:noescape
func VpaddlqS16(r *Int32X4, v0 *Int16X8)

// Unsigned Add Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpaddlU8 VpaddlU8
//go:noescape
func VpaddlU8(r *Uint16X4, v0 *Uint8X8)

// Unsigned Add Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpaddlU32 VpaddlU32
//go:noescape
func VpaddlU32(r *Uint64X1, v0 *Uint32X2)

// Unsigned Add Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpaddlU16 VpaddlU16
//go:noescape
func VpaddlU16(r *Uint32X2, v0 *Uint16X4)

// Signed Add Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpaddlS8 VpaddlS8
//go:noescape
func VpaddlS8(r *Int16X4, v0 *Int8X8)

// Signed Add Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpaddlS32 VpaddlS32
//go:noescape
func VpaddlS32(r *Int64X1, v0 *Int32X2)

// Signed Add Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VpaddlS16 VpaddlS16
//go:noescape
func VpaddlS16(r *Int32X2, v0 *Int16X4)

// Unsigned Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpmaxU8 VpmaxU8
//go:noescape
func VpmaxU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Unsigned Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpmaxU32 VpmaxU32
//go:noescape
func VpmaxU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Unsigned Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpmaxU16 VpmaxU16
//go:noescape
func VpmaxU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Signed Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpmaxS8 VpmaxS8
//go:noescape
func VpmaxS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Floating-point Maximum Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the larger of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpmaxF32 VpmaxF32
//go:noescape
func VpmaxF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Signed Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpmaxS32 VpmaxS32
//go:noescape
func VpmaxS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Signed Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpmaxS16 VpmaxS16
//go:noescape
func VpmaxS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Unsigned Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpminU8 VpminU8
//go:noescape
func VpminU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Unsigned Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpminU32 VpminU32
//go:noescape
func VpminU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Unsigned Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpminU16 VpminU16
//go:noescape
func VpminU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Signed Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpminS8 VpminS8
//go:noescape
func VpminS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Floating-point Minimum Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the smaller of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpminF32 VpminF32
//go:noescape
func VpminF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Signed Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpminS32 VpminS32
//go:noescape
func VpminS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Signed Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpminS16 VpminS16
//go:noescape
func VpminS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Signed saturating Absolute value. This instruction reads each vector element from the source SIMD&FP register, puts the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqabsqS8 VqabsqS8
//go:noescape
func VqabsqS8(r *Int8X16, v0 *Int8X16)

// Signed saturating Absolute value. This instruction reads each vector element from the source SIMD&FP register, puts the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqabsqS32 VqabsqS32
//go:noescape
func VqabsqS32(r *Int32X4, v0 *Int32X4)

// Signed saturating Absolute value. This instruction reads each vector element from the source SIMD&FP register, puts the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqabsqS16 VqabsqS16
//go:noescape
func VqabsqS16(r *Int16X8, v0 *Int16X8)

// Signed saturating Absolute value. This instruction reads each vector element from the source SIMD&FP register, puts the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqabsS8 VqabsS8
//go:noescape
func VqabsS8(r *Int8X8, v0 *Int8X8)

// Signed saturating Absolute value. This instruction reads each vector element from the source SIMD&FP register, puts the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqabsS32 VqabsS32
//go:noescape
func VqabsS32(r *Int32X2, v0 *Int32X2)

// Signed saturating Absolute value. This instruction reads each vector element from the source SIMD&FP register, puts the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqabsS16 VqabsS16
//go:noescape
func VqabsS16(r *Int16X4, v0 *Int16X4)

// Unsigned saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqaddqU8 VqaddqU8
//go:noescape
func VqaddqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Unsigned saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqaddqU32 VqaddqU32
//go:noescape
func VqaddqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Unsigned saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqaddqU64 VqaddqU64
//go:noescape
func VqaddqU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// Unsigned saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqaddqU16 VqaddqU16
//go:noescape
func VqaddqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Signed saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqaddqS8 VqaddqS8
//go:noescape
func VqaddqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Signed saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqaddqS32 VqaddqS32
//go:noescape
func VqaddqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Signed saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqaddqS64 VqaddqS64
//go:noescape
func VqaddqS64(r *Int64X2, v0 *Int64X2, v1 *Int64X2)

// Signed saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqaddqS16 VqaddqS16
//go:noescape
func VqaddqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Unsigned saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqaddU8 VqaddU8
//go:noescape
func VqaddU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Unsigned saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqaddU32 VqaddU32
//go:noescape
func VqaddU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Unsigned saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqaddU64 VqaddU64
//go:noescape
func VqaddU64(r *Uint64X1, v0 *Uint64X1, v1 *Uint64X1)

// Unsigned saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqaddU16 VqaddU16
//go:noescape
func VqaddU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Signed saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqaddS8 VqaddS8
//go:noescape
func VqaddS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Signed saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqaddS32 VqaddS32
//go:noescape
func VqaddS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Signed saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqaddS64 VqaddS64
//go:noescape
func VqaddS64(r *Int64X1, v0 *Int64X1, v1 *Int64X1)

// Signed saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqaddS16 VqaddS16
//go:noescape
func VqaddS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Signed saturating Doubling Multiply-Add Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and accumulates the final results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VqdmlalS32 VqdmlalS32
//go:noescape
func VqdmlalS32(r *Int64X2, v0 *Int64X2, v1 *Int32X2, v2 *Int32X2)

// Signed saturating Doubling Multiply-Add Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and accumulates the final results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VqdmlalS16 VqdmlalS16
//go:noescape
func VqdmlalS16(r *Int32X4, v0 *Int32X4, v1 *Int16X4, v2 *Int16X4)

// Vector widening saturating doubling multiply accumulate with scalar
//
//go:linkname VqdmlalNS32 VqdmlalNS32
//go:noescape
func VqdmlalNS32(r *Int64X2, v0 *Int64X2, v1 *Int32X2, v2 *Int32)

// Vector widening saturating doubling multiply accumulate with scalar
//
//go:linkname VqdmlalNS16 VqdmlalNS16
//go:noescape
func VqdmlalNS16(r *Int32X4, v0 *Int32X4, v1 *Int16X4, v2 *Int16)

// Signed saturating Doubling Multiply-Subtract Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and subtracts the final results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VqdmlslS32 VqdmlslS32
//go:noescape
func VqdmlslS32(r *Int64X2, v0 *Int64X2, v1 *Int32X2, v2 *Int32X2)

// Signed saturating Doubling Multiply-Subtract Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and subtracts the final results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VqdmlslS16 VqdmlslS16
//go:noescape
func VqdmlslS16(r *Int32X4, v0 *Int32X4, v1 *Int16X4, v2 *Int16X4)

// Vector widening saturating doubling multiply subtract with scalar
//
//go:linkname VqdmlslNS32 VqdmlslNS32
//go:noescape
func VqdmlslNS32(r *Int64X2, v0 *Int64X2, v1 *Int32X2, v2 *Int32)

// Vector widening saturating doubling multiply subtract with scalar
//
//go:linkname VqdmlslNS16 VqdmlslNS16
//go:noescape
func VqdmlslNS16(r *Int32X4, v0 *Int32X4, v1 *Int16X4, v2 *Int16)

// Signed saturating Doubling Multiply returning High half. This instruction multiplies the values of corresponding elements of the two source SIMD&FP registers, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqdmulhqS32 VqdmulhqS32
//go:noescape
func VqdmulhqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Signed saturating Doubling Multiply returning High half. This instruction multiplies the values of corresponding elements of the two source SIMD&FP registers, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqdmulhqS16 VqdmulhqS16
//go:noescape
func VqdmulhqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Signed saturating Doubling Multiply returning High half. This instruction multiplies the values of corresponding elements of the two source SIMD&FP registers, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqdmulhS32 VqdmulhS32
//go:noescape
func VqdmulhS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Signed saturating Doubling Multiply returning High half. This instruction multiplies the values of corresponding elements of the two source SIMD&FP registers, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqdmulhS16 VqdmulhS16
//go:noescape
func VqdmulhS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Vector saturating doubling multiply high with scalar
//
//go:linkname VqdmulhqNS32 VqdmulhqNS32
//go:noescape
func VqdmulhqNS32(r *Int32X4, v0 *Int32X4, v1 *Int32)

// Vector saturating doubling multiply high with scalar
//
//go:linkname VqdmulhqNS16 VqdmulhqNS16
//go:noescape
func VqdmulhqNS16(r *Int16X8, v0 *Int16X8, v1 *Int16)

// Vector saturating doubling multiply high with scalar
//
//go:linkname VqdmulhNS32 VqdmulhNS32
//go:noescape
func VqdmulhNS32(r *Int32X2, v0 *Int32X2, v1 *Int32)

// Vector saturating doubling multiply high with scalar
//
//go:linkname VqdmulhNS16 VqdmulhNS16
//go:noescape
func VqdmulhNS16(r *Int16X4, v0 *Int16X4, v1 *Int16)

// Signed saturating Doubling Multiply Long. This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, doubles the results, places the final results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqdmullS32 VqdmullS32
//go:noescape
func VqdmullS32(r *Int64X2, v0 *Int32X2, v1 *Int32X2)

// Signed saturating Doubling Multiply Long. This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, doubles the results, places the final results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqdmullS16 VqdmullS16
//go:noescape
func VqdmullS16(r *Int32X4, v0 *Int16X4, v1 *Int16X4)

// Vector saturating doubling long multiply with scalar
//
//go:linkname VqdmullNS32 VqdmullNS32
//go:noescape
func VqdmullNS32(r *Int64X2, v0 *Int32X2, v1 *Int32)

// Vector saturating doubling long multiply with scalar
//
//go:linkname VqdmullNS16 VqdmullNS16
//go:noescape
func VqdmullNS16(r *Int32X4, v0 *Int16X4, v1 *Int16)

// Unsigned saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates each value to half the original width, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
//
//go:linkname VqmovnU32 VqmovnU32
//go:noescape
func VqmovnU32(r *Uint16X4, v0 *Uint32X4)

// Unsigned saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates each value to half the original width, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
//
//go:linkname VqmovnU64 VqmovnU64
//go:noescape
func VqmovnU64(r *Uint32X2, v0 *Uint64X2)

// Unsigned saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates each value to half the original width, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
//
//go:linkname VqmovnU16 VqmovnU16
//go:noescape
func VqmovnU16(r *Uint8X8, v0 *Uint16X8)

// Signed saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates the value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. All the values in this instruction are signed integer values.
//
//go:linkname VqmovnS32 VqmovnS32
//go:noescape
func VqmovnS32(r *Int16X4, v0 *Int32X4)

// Signed saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates the value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. All the values in this instruction are signed integer values.
//
//go:linkname VqmovnS64 VqmovnS64
//go:noescape
func VqmovnS64(r *Int32X2, v0 *Int64X2)

// Signed saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates the value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. All the values in this instruction are signed integer values.
//
//go:linkname VqmovnS16 VqmovnS16
//go:noescape
func VqmovnS16(r *Int8X8, v0 *Int16X8)

// Signed saturating extract Unsigned Narrow. This instruction reads each signed integer value in the vector of the source SIMD&FP register, saturates the value to an unsigned integer value that is half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.
//
//go:linkname VqmovunS32 VqmovunS32
//go:noescape
func VqmovunS32(r *Uint16X4, v0 *Int32X4)

// Signed saturating extract Unsigned Narrow. This instruction reads each signed integer value in the vector of the source SIMD&FP register, saturates the value to an unsigned integer value that is half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.
//
//go:linkname VqmovunS64 VqmovunS64
//go:noescape
func VqmovunS64(r *Uint32X2, v0 *Int64X2)

// Signed saturating extract Unsigned Narrow. This instruction reads each signed integer value in the vector of the source SIMD&FP register, saturates the value to an unsigned integer value that is half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.
//
//go:linkname VqmovunS16 VqmovunS16
//go:noescape
func VqmovunS16(r *Uint8X8, v0 *Int16X8)

// Signed saturating Negate. This instruction reads each vector element from the source SIMD&FP register, negates each value, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqnegqS8 VqnegqS8
//go:noescape
func VqnegqS8(r *Int8X16, v0 *Int8X16)

// Signed saturating Negate. This instruction reads each vector element from the source SIMD&FP register, negates each value, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqnegqS32 VqnegqS32
//go:noescape
func VqnegqS32(r *Int32X4, v0 *Int32X4)

// Signed saturating Negate. This instruction reads each vector element from the source SIMD&FP register, negates each value, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqnegqS16 VqnegqS16
//go:noescape
func VqnegqS16(r *Int16X8, v0 *Int16X8)

// Signed saturating Negate. This instruction reads each vector element from the source SIMD&FP register, negates each value, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqnegS8 VqnegS8
//go:noescape
func VqnegS8(r *Int8X8, v0 *Int8X8)

// Signed saturating Negate. This instruction reads each vector element from the source SIMD&FP register, negates each value, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqnegS32 VqnegS32
//go:noescape
func VqnegS32(r *Int32X2, v0 *Int32X2)

// Signed saturating Negate. This instruction reads each vector element from the source SIMD&FP register, negates each value, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqnegS16 VqnegS16
//go:noescape
func VqnegS16(r *Int16X4, v0 *Int16X4)

// Signed saturating Rounding Doubling Multiply returning High half. This instruction multiplies the values of corresponding elements of the two source SIMD&FP registers, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrdmulhqS32 VqrdmulhqS32
//go:noescape
func VqrdmulhqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Signed saturating Rounding Doubling Multiply returning High half. This instruction multiplies the values of corresponding elements of the two source SIMD&FP registers, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrdmulhqS16 VqrdmulhqS16
//go:noescape
func VqrdmulhqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Signed saturating Rounding Doubling Multiply returning High half. This instruction multiplies the values of corresponding elements of the two source SIMD&FP registers, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrdmulhS32 VqrdmulhS32
//go:noescape
func VqrdmulhS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Signed saturating Rounding Doubling Multiply returning High half. This instruction multiplies the values of corresponding elements of the two source SIMD&FP registers, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrdmulhS16 VqrdmulhS16
//go:noescape
func VqrdmulhS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Vector saturating rounding doubling multiply high with scalar
//
//go:linkname VqrdmulhqNS32 VqrdmulhqNS32
//go:noescape
func VqrdmulhqNS32(r *Int32X4, v0 *Int32X4, v1 *Int32)

// Vector saturating rounding doubling multiply high with scalar
//
//go:linkname VqrdmulhqNS16 VqrdmulhqNS16
//go:noescape
func VqrdmulhqNS16(r *Int16X8, v0 *Int16X8, v1 *Int16)

// Vector saturating rounding doubling multiply high with scalar
//
//go:linkname VqrdmulhNS32 VqrdmulhNS32
//go:noescape
func VqrdmulhNS32(r *Int32X2, v0 *Int32X2, v1 *Int32)

// Vector saturating rounding doubling multiply high with scalar
//
//go:linkname VqrdmulhNS16 VqrdmulhNS16
//go:noescape
func VqrdmulhNS16(r *Int16X4, v0 *Int16X4, v1 *Int16)

// Unsigned saturating Rounding Shift Left (register). This instruction takes each vector element of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshlqU8 VqrshlqU8
//go:noescape
func VqrshlqU8(r *Uint8X16, v0 *Uint8X16, v1 *Int8X16)

// Unsigned saturating Rounding Shift Left (register). This instruction takes each vector element of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshlqU32 VqrshlqU32
//go:noescape
func VqrshlqU32(r *Uint32X4, v0 *Uint32X4, v1 *Int32X4)

// Unsigned saturating Rounding Shift Left (register). This instruction takes each vector element of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshlqU64 VqrshlqU64
//go:noescape
func VqrshlqU64(r *Uint64X2, v0 *Uint64X2, v1 *Int64X2)

// Unsigned saturating Rounding Shift Left (register). This instruction takes each vector element of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshlqU16 VqrshlqU16
//go:noescape
func VqrshlqU16(r *Uint16X8, v0 *Uint16X8, v1 *Int16X8)

// Signed saturating Rounding Shift Left (register). This instruction takes each vector element in the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshlqS8 VqrshlqS8
//go:noescape
func VqrshlqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Signed saturating Rounding Shift Left (register). This instruction takes each vector element in the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshlqS32 VqrshlqS32
//go:noescape
func VqrshlqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Signed saturating Rounding Shift Left (register). This instruction takes each vector element in the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshlqS64 VqrshlqS64
//go:noescape
func VqrshlqS64(r *Int64X2, v0 *Int64X2, v1 *Int64X2)

// Signed saturating Rounding Shift Left (register). This instruction takes each vector element in the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshlqS16 VqrshlqS16
//go:noescape
func VqrshlqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Unsigned saturating Rounding Shift Left (register). This instruction takes each vector element of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshlU8 VqrshlU8
//go:noescape
func VqrshlU8(r *Uint8X8, v0 *Uint8X8, v1 *Int8X8)

// Unsigned saturating Rounding Shift Left (register). This instruction takes each vector element of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshlU32 VqrshlU32
//go:noescape
func VqrshlU32(r *Uint32X2, v0 *Uint32X2, v1 *Int32X2)

// Unsigned saturating Rounding Shift Left (register). This instruction takes each vector element of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshlU64 VqrshlU64
//go:noescape
func VqrshlU64(r *Uint64X1, v0 *Uint64X1, v1 *Int64X1)

// Unsigned saturating Rounding Shift Left (register). This instruction takes each vector element of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshlU16 VqrshlU16
//go:noescape
func VqrshlU16(r *Uint16X4, v0 *Uint16X4, v1 *Int16X4)

// Signed saturating Rounding Shift Left (register). This instruction takes each vector element in the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshlS8 VqrshlS8
//go:noescape
func VqrshlS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Signed saturating Rounding Shift Left (register). This instruction takes each vector element in the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshlS32 VqrshlS32
//go:noescape
func VqrshlS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Signed saturating Rounding Shift Left (register). This instruction takes each vector element in the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshlS64 VqrshlS64
//go:noescape
func VqrshlS64(r *Int64X1, v0 *Int64X1, v1 *Int64X1)

// Signed saturating Rounding Shift Left (register). This instruction takes each vector element in the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshlS16 VqrshlS16
//go:noescape
func VqrshlS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Unsigned saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshlqU8 VqshlqU8
//go:noescape
func VqshlqU8(r *Uint8X16, v0 *Uint8X16, v1 *Int8X16)

// Unsigned saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshlqU32 VqshlqU32
//go:noescape
func VqshlqU32(r *Uint32X4, v0 *Uint32X4, v1 *Int32X4)

// Unsigned saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshlqU64 VqshlqU64
//go:noescape
func VqshlqU64(r *Uint64X2, v0 *Uint64X2, v1 *Int64X2)

// Unsigned saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshlqU16 VqshlqU16
//go:noescape
func VqshlqU16(r *Uint16X8, v0 *Uint16X8, v1 *Int16X8)

// Signed saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshlqS8 VqshlqS8
//go:noescape
func VqshlqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Signed saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshlqS32 VqshlqS32
//go:noescape
func VqshlqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Signed saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshlqS64 VqshlqS64
//go:noescape
func VqshlqS64(r *Int64X2, v0 *Int64X2, v1 *Int64X2)

// Signed saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshlqS16 VqshlqS16
//go:noescape
func VqshlqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Unsigned saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshlU8 VqshlU8
//go:noescape
func VqshlU8(r *Uint8X8, v0 *Uint8X8, v1 *Int8X8)

// Unsigned saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshlU32 VqshlU32
//go:noescape
func VqshlU32(r *Uint32X2, v0 *Uint32X2, v1 *Int32X2)

// Unsigned saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshlU64 VqshlU64
//go:noescape
func VqshlU64(r *Uint64X1, v0 *Uint64X1, v1 *Int64X1)

// Unsigned saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshlU16 VqshlU16
//go:noescape
func VqshlU16(r *Uint16X4, v0 *Uint16X4, v1 *Int16X4)

// Signed saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshlS8 VqshlS8
//go:noescape
func VqshlS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Signed saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshlS32 VqshlS32
//go:noescape
func VqshlS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Signed saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshlS64 VqshlS64
//go:noescape
func VqshlS64(r *Int64X1, v0 *Int64X1, v1 *Int64X1)

// Signed saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshlS16 VqshlS16
//go:noescape
func VqshlS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Unsigned saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubqU8 VqsubqU8
//go:noescape
func VqsubqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Unsigned saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubqU32 VqsubqU32
//go:noescape
func VqsubqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Unsigned saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubqU64 VqsubqU64
//go:noescape
func VqsubqU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// Unsigned saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubqU16 VqsubqU16
//go:noescape
func VqsubqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Signed saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubqS8 VqsubqS8
//go:noescape
func VqsubqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Signed saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubqS32 VqsubqS32
//go:noescape
func VqsubqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Signed saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubqS64 VqsubqS64
//go:noescape
func VqsubqS64(r *Int64X2, v0 *Int64X2, v1 *Int64X2)

// Signed saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubqS16 VqsubqS16
//go:noescape
func VqsubqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Unsigned saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubU8 VqsubU8
//go:noescape
func VqsubU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Unsigned saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubU32 VqsubU32
//go:noescape
func VqsubU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Unsigned saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubU64 VqsubU64
//go:noescape
func VqsubU64(r *Uint64X1, v0 *Uint64X1, v1 *Uint64X1)

// Unsigned saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubU16 VqsubU16
//go:noescape
func VqsubU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Signed saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubS8 VqsubS8
//go:noescape
func VqsubS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Signed saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubS32 VqsubS32
//go:noescape
func VqsubS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Signed saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubS64 VqsubS64
//go:noescape
func VqsubS64(r *Int64X1, v0 *Int64X1, v1 *Int64X1)

// Signed saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubS16 VqsubS16
//go:noescape
func VqsubS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Rounding Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VraddhnU32 VraddhnU32
//go:noescape
func VraddhnU32(r *Uint16X4, v0 *Uint32X4, v1 *Uint32X4)

// Rounding Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VraddhnU64 VraddhnU64
//go:noescape
func VraddhnU64(r *Uint32X2, v0 *Uint64X2, v1 *Uint64X2)

// Rounding Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VraddhnU16 VraddhnU16
//go:noescape
func VraddhnU16(r *Uint8X8, v0 *Uint16X8, v1 *Uint16X8)

// Rounding Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VraddhnS32 VraddhnS32
//go:noescape
func VraddhnS32(r *Int16X4, v0 *Int32X4, v1 *Int32X4)

// Rounding Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VraddhnS64 VraddhnS64
//go:noescape
func VraddhnS64(r *Int32X2, v0 *Int64X2, v1 *Int64X2)

// Rounding Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VraddhnS16 VraddhnS16
//go:noescape
func VraddhnS16(r *Int8X8, v0 *Int16X8, v1 *Int16X8)

// Unsigned Reciprocal Estimate. This instruction reads each vector element from the source SIMD&FP register, calculates an approximate inverse for the unsigned integer value, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrecpeqU32 VrecpeqU32
//go:noescape
func VrecpeqU32(r *Uint32X4, v0 *Uint32X4)

// Floating-point Reciprocal Estimate. This instruction finds an approximate reciprocal estimate for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrecpeqF32 VrecpeqF32
//go:noescape
func VrecpeqF32(r *Float32X4, v0 *Float32X4)

// Unsigned Reciprocal Estimate. This instruction reads each vector element from the source SIMD&FP register, calculates an approximate inverse for the unsigned integer value, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrecpeU32 VrecpeU32
//go:noescape
func VrecpeU32(r *Uint32X2, v0 *Uint32X2)

// Floating-point Reciprocal Estimate. This instruction finds an approximate reciprocal estimate for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrecpeF32 VrecpeF32
//go:noescape
func VrecpeF32(r *Float32X2, v0 *Float32X2)

// Floating-point Reciprocal Step. This instruction multiplies the corresponding floating-point values in the vectors of the two source SIMD&FP registers, subtracts each of the products from 2.0, places the resulting floating-point values in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrecpsqF32 VrecpsqF32
//go:noescape
func VrecpsqF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Floating-point Reciprocal Step. This instruction multiplies the corresponding floating-point values in the vectors of the two source SIMD&FP registers, subtracts each of the products from 2.0, places the resulting floating-point values in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrecpsF32 VrecpsF32
//go:noescape
func VrecpsF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Reverse elements in 16-bit halfwords (vector). This instruction reverses the order of 8-bit elements in each halfword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev16P8 Vrev16P8
//go:noescape
func Vrev16P8(r *Poly8X8, v0 *Poly8X8)

// Reverse elements in 16-bit halfwords (vector). This instruction reverses the order of 8-bit elements in each halfword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev16QP8 Vrev16QP8
//go:noescape
func Vrev16QP8(r *Poly8X16, v0 *Poly8X16)

// Reverse elements in 16-bit halfwords (vector). This instruction reverses the order of 8-bit elements in each halfword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev16QU8 Vrev16QU8
//go:noescape
func Vrev16QU8(r *Uint8X16, v0 *Uint8X16)

// Reverse elements in 16-bit halfwords (vector). This instruction reverses the order of 8-bit elements in each halfword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev16QS8 Vrev16QS8
//go:noescape
func Vrev16QS8(r *Int8X16, v0 *Int8X16)

// Reverse elements in 16-bit halfwords (vector). This instruction reverses the order of 8-bit elements in each halfword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev16U8 Vrev16U8
//go:noescape
func Vrev16U8(r *Uint8X8, v0 *Uint8X8)

// Reverse elements in 16-bit halfwords (vector). This instruction reverses the order of 8-bit elements in each halfword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev16S8 Vrev16S8
//go:noescape
func Vrev16S8(r *Int8X8, v0 *Int8X8)

// Reverse elements in 32-bit words (vector). This instruction reverses the order of 8-bit or 16-bit elements in each word of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev32P8 Vrev32P8
//go:noescape
func Vrev32P8(r *Poly8X8, v0 *Poly8X8)

// Reverse elements in 32-bit words (vector). This instruction reverses the order of 8-bit or 16-bit elements in each word of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev32P16 Vrev32P16
//go:noescape
func Vrev32P16(r *Poly16X4, v0 *Poly16X4)

// Reverse elements in 32-bit words (vector). This instruction reverses the order of 8-bit or 16-bit elements in each word of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev32QP8 Vrev32QP8
//go:noescape
func Vrev32QP8(r *Poly8X16, v0 *Poly8X16)

// Reverse elements in 32-bit words (vector). This instruction reverses the order of 8-bit or 16-bit elements in each word of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev32QP16 Vrev32QP16
//go:noescape
func Vrev32QP16(r *Poly16X8, v0 *Poly16X8)

// Reverse elements in 32-bit words (vector). This instruction reverses the order of 8-bit or 16-bit elements in each word of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev32QU8 Vrev32QU8
//go:noescape
func Vrev32QU8(r *Uint8X16, v0 *Uint8X16)

// Reverse elements in 32-bit words (vector). This instruction reverses the order of 8-bit or 16-bit elements in each word of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev32QU16 Vrev32QU16
//go:noescape
func Vrev32QU16(r *Uint16X8, v0 *Uint16X8)

// Reverse elements in 32-bit words (vector). This instruction reverses the order of 8-bit or 16-bit elements in each word of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev32QS8 Vrev32QS8
//go:noescape
func Vrev32QS8(r *Int8X16, v0 *Int8X16)

// Reverse elements in 32-bit words (vector). This instruction reverses the order of 8-bit or 16-bit elements in each word of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev32QS16 Vrev32QS16
//go:noescape
func Vrev32QS16(r *Int16X8, v0 *Int16X8)

// Reverse elements in 32-bit words (vector). This instruction reverses the order of 8-bit or 16-bit elements in each word of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev32U8 Vrev32U8
//go:noescape
func Vrev32U8(r *Uint8X8, v0 *Uint8X8)

// Reverse elements in 32-bit words (vector). This instruction reverses the order of 8-bit or 16-bit elements in each word of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev32U16 Vrev32U16
//go:noescape
func Vrev32U16(r *Uint16X4, v0 *Uint16X4)

// Reverse elements in 32-bit words (vector). This instruction reverses the order of 8-bit or 16-bit elements in each word of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev32S8 Vrev32S8
//go:noescape
func Vrev32S8(r *Int8X8, v0 *Int8X8)

// Reverse elements in 32-bit words (vector). This instruction reverses the order of 8-bit or 16-bit elements in each word of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev32S16 Vrev32S16
//go:noescape
func Vrev32S16(r *Int16X4, v0 *Int16X4)

// Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev64P8 Vrev64P8
//go:noescape
func Vrev64P8(r *Poly8X8, v0 *Poly8X8)

// Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev64P16 Vrev64P16
//go:noescape
func Vrev64P16(r *Poly16X4, v0 *Poly16X4)

// Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev64QP8 Vrev64QP8
//go:noescape
func Vrev64QP8(r *Poly8X16, v0 *Poly8X16)

// Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev64QP16 Vrev64QP16
//go:noescape
func Vrev64QP16(r *Poly16X8, v0 *Poly16X8)

// Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev64QU8 Vrev64QU8
//go:noescape
func Vrev64QU8(r *Uint8X16, v0 *Uint8X16)

// Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev64QU32 Vrev64QU32
//go:noescape
func Vrev64QU32(r *Uint32X4, v0 *Uint32X4)

// Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev64QU16 Vrev64QU16
//go:noescape
func Vrev64QU16(r *Uint16X8, v0 *Uint16X8)

// Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev64QS8 Vrev64QS8
//go:noescape
func Vrev64QS8(r *Int8X16, v0 *Int8X16)

// Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev64QF32 Vrev64QF32
//go:noescape
func Vrev64QF32(r *Float32X4, v0 *Float32X4)

// Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev64QS32 Vrev64QS32
//go:noescape
func Vrev64QS32(r *Int32X4, v0 *Int32X4)

// Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev64QS16 Vrev64QS16
//go:noescape
func Vrev64QS16(r *Int16X8, v0 *Int16X8)

// Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev64U8 Vrev64U8
//go:noescape
func Vrev64U8(r *Uint8X8, v0 *Uint8X8)

// Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev64U32 Vrev64U32
//go:noescape
func Vrev64U32(r *Uint32X2, v0 *Uint32X2)

// Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev64U16 Vrev64U16
//go:noescape
func Vrev64U16(r *Uint16X4, v0 *Uint16X4)

// Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev64S8 Vrev64S8
//go:noescape
func Vrev64S8(r *Int8X8, v0 *Int8X8)

// Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev64F32 Vrev64F32
//go:noescape
func Vrev64F32(r *Float32X2, v0 *Float32X2)

// Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev64S32 Vrev64S32
//go:noescape
func Vrev64S32(r *Int32X2, v0 *Int32X2)

// Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vrev64S16 Vrev64S16
//go:noescape
func Vrev64S16(r *Int16X4, v0 *Int16X4)

// Unsigned Rounding Halving Add. This instruction adds corresponding unsigned integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrhaddqU8 VrhaddqU8
//go:noescape
func VrhaddqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Unsigned Rounding Halving Add. This instruction adds corresponding unsigned integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrhaddqU32 VrhaddqU32
//go:noescape
func VrhaddqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Unsigned Rounding Halving Add. This instruction adds corresponding unsigned integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrhaddqU16 VrhaddqU16
//go:noescape
func VrhaddqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Signed Rounding Halving Add. This instruction adds corresponding signed integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrhaddqS8 VrhaddqS8
//go:noescape
func VrhaddqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Signed Rounding Halving Add. This instruction adds corresponding signed integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrhaddqS32 VrhaddqS32
//go:noescape
func VrhaddqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Signed Rounding Halving Add. This instruction adds corresponding signed integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrhaddqS16 VrhaddqS16
//go:noescape
func VrhaddqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Unsigned Rounding Halving Add. This instruction adds corresponding unsigned integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrhaddU8 VrhaddU8
//go:noescape
func VrhaddU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Unsigned Rounding Halving Add. This instruction adds corresponding unsigned integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrhaddU32 VrhaddU32
//go:noescape
func VrhaddU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Unsigned Rounding Halving Add. This instruction adds corresponding unsigned integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrhaddU16 VrhaddU16
//go:noescape
func VrhaddU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Signed Rounding Halving Add. This instruction adds corresponding signed integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrhaddS8 VrhaddS8
//go:noescape
func VrhaddS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Signed Rounding Halving Add. This instruction adds corresponding signed integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrhaddS32 VrhaddS32
//go:noescape
func VrhaddS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Signed Rounding Halving Add. This instruction adds corresponding signed integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrhaddS16 VrhaddS16
//go:noescape
func VrhaddS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Unsigned Rounding Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrshlqU8 VrshlqU8
//go:noescape
func VrshlqU8(r *Uint8X16, v0 *Uint8X16, v1 *Int8X16)

// Unsigned Rounding Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrshlqU32 VrshlqU32
//go:noescape
func VrshlqU32(r *Uint32X4, v0 *Uint32X4, v1 *Int32X4)

// Unsigned Rounding Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrshlqU64 VrshlqU64
//go:noescape
func VrshlqU64(r *Uint64X2, v0 *Uint64X2, v1 *Int64X2)

// Unsigned Rounding Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrshlqU16 VrshlqU16
//go:noescape
func VrshlqU16(r *Uint16X8, v0 *Uint16X8, v1 *Int16X8)

// Signed Rounding Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrshlqS8 VrshlqS8
//go:noescape
func VrshlqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Signed Rounding Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrshlqS32 VrshlqS32
//go:noescape
func VrshlqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Signed Rounding Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrshlqS64 VrshlqS64
//go:noescape
func VrshlqS64(r *Int64X2, v0 *Int64X2, v1 *Int64X2)

// Signed Rounding Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrshlqS16 VrshlqS16
//go:noescape
func VrshlqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Unsigned Rounding Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrshlU8 VrshlU8
//go:noescape
func VrshlU8(r *Uint8X8, v0 *Uint8X8, v1 *Int8X8)

// Unsigned Rounding Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrshlU32 VrshlU32
//go:noescape
func VrshlU32(r *Uint32X2, v0 *Uint32X2, v1 *Int32X2)

// Unsigned Rounding Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrshlU64 VrshlU64
//go:noescape
func VrshlU64(r *Uint64X1, v0 *Uint64X1, v1 *Int64X1)

// Unsigned Rounding Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrshlU16 VrshlU16
//go:noescape
func VrshlU16(r *Uint16X4, v0 *Uint16X4, v1 *Int16X4)

// Signed Rounding Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrshlS8 VrshlS8
//go:noescape
func VrshlS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Signed Rounding Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrshlS32 VrshlS32
//go:noescape
func VrshlS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Signed Rounding Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrshlS64 VrshlS64
//go:noescape
func VrshlS64(r *Int64X1, v0 *Int64X1, v1 *Int64X1)

// Signed Rounding Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrshlS16 VrshlS16
//go:noescape
func VrshlS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Unsigned Reciprocal Square Root Estimate. This instruction reads each vector element from the source SIMD&FP register, calculates an approximate inverse square root for each value, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
//
//go:linkname VrsqrteqU32 VrsqrteqU32
//go:noescape
func VrsqrteqU32(r *Uint32X4, v0 *Uint32X4)

// Floating-point Reciprocal Square Root Estimate. This instruction calculates an approximate square root for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrsqrteqF32 VrsqrteqF32
//go:noescape
func VrsqrteqF32(r *Float32X4, v0 *Float32X4)

// Unsigned Reciprocal Square Root Estimate. This instruction reads each vector element from the source SIMD&FP register, calculates an approximate inverse square root for each value, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
//
//go:linkname VrsqrteU32 VrsqrteU32
//go:noescape
func VrsqrteU32(r *Uint32X2, v0 *Uint32X2)

// Floating-point Reciprocal Square Root Estimate. This instruction calculates an approximate square root for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrsqrteF32 VrsqrteF32
//go:noescape
func VrsqrteF32(r *Float32X2, v0 *Float32X2)

// Floating-point Reciprocal Square Root Step. This instruction multiplies corresponding floating-point values in the vectors of the two source SIMD&FP registers, subtracts each of the products from 3.0, divides these results by 2.0, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrsqrtsqF32 VrsqrtsqF32
//go:noescape
func VrsqrtsqF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Floating-point Reciprocal Square Root Step. This instruction multiplies corresponding floating-point values in the vectors of the two source SIMD&FP registers, subtracts each of the products from 3.0, divides these results by 2.0, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrsqrtsF32 VrsqrtsF32
//go:noescape
func VrsqrtsF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Rounding Subtract returning High Narrow. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VrsubhnU32 VrsubhnU32
//go:noescape
func VrsubhnU32(r *Uint16X4, v0 *Uint32X4, v1 *Uint32X4)

// Rounding Subtract returning High Narrow. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VrsubhnU64 VrsubhnU64
//go:noescape
func VrsubhnU64(r *Uint32X2, v0 *Uint64X2, v1 *Uint64X2)

// Rounding Subtract returning High Narrow. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VrsubhnU16 VrsubhnU16
//go:noescape
func VrsubhnU16(r *Uint8X8, v0 *Uint16X8, v1 *Uint16X8)

// Rounding Subtract returning High Narrow. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VrsubhnS32 VrsubhnS32
//go:noescape
func VrsubhnS32(r *Int16X4, v0 *Int32X4, v1 *Int32X4)

// Rounding Subtract returning High Narrow. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VrsubhnS64 VrsubhnS64
//go:noescape
func VrsubhnS64(r *Int32X2, v0 *Int64X2, v1 *Int64X2)

// Rounding Subtract returning High Narrow. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VrsubhnS16 VrsubhnS16
//go:noescape
func VrsubhnS16(r *Int8X8, v0 *Int16X8, v1 *Int16X8)

// Unsigned Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VshlqU8 VshlqU8
//go:noescape
func VshlqU8(r *Uint8X16, v0 *Uint8X16, v1 *Int8X16)

// Unsigned Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VshlqU32 VshlqU32
//go:noescape
func VshlqU32(r *Uint32X4, v0 *Uint32X4, v1 *Int32X4)

// Unsigned Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VshlqU64 VshlqU64
//go:noescape
func VshlqU64(r *Uint64X2, v0 *Uint64X2, v1 *Int64X2)

// Unsigned Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VshlqU16 VshlqU16
//go:noescape
func VshlqU16(r *Uint16X8, v0 *Uint16X8, v1 *Int16X8)

// Signed Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts each value by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VshlqS8 VshlqS8
//go:noescape
func VshlqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Signed Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts each value by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VshlqS32 VshlqS32
//go:noescape
func VshlqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Signed Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts each value by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VshlqS64 VshlqS64
//go:noescape
func VshlqS64(r *Int64X2, v0 *Int64X2, v1 *Int64X2)

// Signed Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts each value by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VshlqS16 VshlqS16
//go:noescape
func VshlqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Unsigned Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VshlU8 VshlU8
//go:noescape
func VshlU8(r *Uint8X8, v0 *Uint8X8, v1 *Int8X8)

// Unsigned Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VshlU32 VshlU32
//go:noescape
func VshlU32(r *Uint32X2, v0 *Uint32X2, v1 *Int32X2)

// Unsigned Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VshlU64 VshlU64
//go:noescape
func VshlU64(r *Uint64X1, v0 *Uint64X1, v1 *Int64X1)

// Unsigned Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VshlU16 VshlU16
//go:noescape
func VshlU16(r *Uint16X4, v0 *Uint16X4, v1 *Int16X4)

// Signed Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts each value by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VshlS8 VshlS8
//go:noescape
func VshlS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Signed Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts each value by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VshlS32 VshlS32
//go:noescape
func VshlS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Signed Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts each value by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VshlS64 VshlS64
//go:noescape
func VshlS64(r *Int64X1, v0 *Int64X1, v1 *Int64X1)

// Signed Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts each value by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VshlS16 VshlS16
//go:noescape
func VshlS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Subtract (vector). This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsubqU8 VsubqU8
//go:noescape
func VsubqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Subtract (vector). This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsubqU32 VsubqU32
//go:noescape
func VsubqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Subtract (vector). This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsubqU64 VsubqU64
//go:noescape
func VsubqU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// Subtract (vector). This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsubqU16 VsubqU16
//go:noescape
func VsubqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Subtract (vector). This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsubqS8 VsubqS8
//go:noescape
func VsubqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Floating-point Subtract (vector). This instruction subtracts the elements in the vector in the second source SIMD&FP register, from the corresponding elements in the vector in the first source SIMD&FP register, places each result into elements of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsubqF32 VsubqF32
//go:noescape
func VsubqF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Subtract (vector). This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsubqS32 VsubqS32
//go:noescape
func VsubqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Subtract (vector). This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsubqS64 VsubqS64
//go:noescape
func VsubqS64(r *Int64X2, v0 *Int64X2, v1 *Int64X2)

// Subtract (vector). This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsubqS16 VsubqS16
//go:noescape
func VsubqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Subtract (vector). This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsubU8 VsubU8
//go:noescape
func VsubU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Subtract (vector). This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsubU32 VsubU32
//go:noescape
func VsubU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Subtract (vector). This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsubU64 VsubU64
//go:noescape
func VsubU64(r *Uint64X1, v0 *Uint64X1, v1 *Uint64X1)

// Subtract (vector). This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsubU16 VsubU16
//go:noescape
func VsubU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Subtract (vector). This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsubS8 VsubS8
//go:noescape
func VsubS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Floating-point Subtract (vector). This instruction subtracts the elements in the vector in the second source SIMD&FP register, from the corresponding elements in the vector in the first source SIMD&FP register, places each result into elements of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsubF32 VsubF32
//go:noescape
func VsubF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Subtract (vector). This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsubS32 VsubS32
//go:noescape
func VsubS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Subtract (vector). This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsubS64 VsubS64
//go:noescape
func VsubS64(r *Int64X1, v0 *Int64X1, v1 *Int64X1)

// Subtract (vector). This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsubS16 VsubS16
//go:noescape
func VsubS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Subtract returning High Narrow. This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VsubhnU32 VsubhnU32
//go:noescape
func VsubhnU32(r *Uint16X4, v0 *Uint32X4, v1 *Uint32X4)

// Subtract returning High Narrow. This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VsubhnU64 VsubhnU64
//go:noescape
func VsubhnU64(r *Uint32X2, v0 *Uint64X2, v1 *Uint64X2)

// Subtract returning High Narrow. This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VsubhnU16 VsubhnU16
//go:noescape
func VsubhnU16(r *Uint8X8, v0 *Uint16X8, v1 *Uint16X8)

// Subtract returning High Narrow. This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VsubhnS32 VsubhnS32
//go:noescape
func VsubhnS32(r *Int16X4, v0 *Int32X4, v1 *Int32X4)

// Subtract returning High Narrow. This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VsubhnS64 VsubhnS64
//go:noescape
func VsubhnS64(r *Int32X2, v0 *Int64X2, v1 *Int64X2)

// Subtract returning High Narrow. This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VsubhnS16 VsubhnS16
//go:noescape
func VsubhnS16(r *Int8X8, v0 *Int16X8, v1 *Int16X8)

// Unsigned Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VsublU8 VsublU8
//go:noescape
func VsublU8(r *Uint16X8, v0 *Uint8X8, v1 *Uint8X8)

// Unsigned Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VsublU32 VsublU32
//go:noescape
func VsublU32(r *Uint64X2, v0 *Uint32X2, v1 *Uint32X2)

// Unsigned Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VsublU16 VsublU16
//go:noescape
func VsublU16(r *Uint32X4, v0 *Uint16X4, v1 *Uint16X4)

// Signed Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VsublS8 VsublS8
//go:noescape
func VsublS8(r *Int16X8, v0 *Int8X8, v1 *Int8X8)

// Signed Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VsublS32 VsublS32
//go:noescape
func VsublS32(r *Int64X2, v0 *Int32X2, v1 *Int32X2)

// Signed Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VsublS16 VsublS16
//go:noescape
func VsublS16(r *Int32X4, v0 *Int16X4, v1 *Int16X4)

// Unsigned Subtract Wide. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element in the lower or upper half of the first source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. All the values in this instruction are signed integer values.
//
//go:linkname VsubwU8 VsubwU8
//go:noescape
func VsubwU8(r *Uint16X8, v0 *Uint16X8, v1 *Uint8X8)

// Unsigned Subtract Wide. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element in the lower or upper half of the first source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. All the values in this instruction are signed integer values.
//
//go:linkname VsubwU32 VsubwU32
//go:noescape
func VsubwU32(r *Uint64X2, v0 *Uint64X2, v1 *Uint32X2)

// Unsigned Subtract Wide. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element in the lower or upper half of the first source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. All the values in this instruction are signed integer values.
//
//go:linkname VsubwU16 VsubwU16
//go:noescape
func VsubwU16(r *Uint32X4, v0 *Uint32X4, v1 *Uint16X4)

// Signed Subtract Wide. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. All the values in this instruction are signed integer values.
//
//go:linkname VsubwS8 VsubwS8
//go:noescape
func VsubwS8(r *Int16X8, v0 *Int16X8, v1 *Int8X8)

// Signed Subtract Wide. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. All the values in this instruction are signed integer values.
//
//go:linkname VsubwS32 VsubwS32
//go:noescape
func VsubwS32(r *Int64X2, v0 *Int64X2, v1 *Int32X2)

// Signed Subtract Wide. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. All the values in this instruction are signed integer values.
//
//go:linkname VsubwS16 VsubwS16
//go:noescape
func VsubwS16(r *Int32X4, v0 *Int32X4, v1 *Int16X4)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vtbl1P8 Vtbl1P8
//go:noescape
func Vtbl1P8(r *Poly8X8, v0 *Poly8X8, v1 *Uint8X8)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vtbl1U8 Vtbl1U8
//go:noescape
func Vtbl1U8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vtbl1S8 Vtbl1S8
//go:noescape
func Vtbl1S8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vtbl2P8 Vtbl2P8
//go:noescape
func Vtbl2P8(r *Poly8X8, v0 *Poly8X8X2, v1 *Uint8X8)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vtbl2U8 Vtbl2U8
//go:noescape
func Vtbl2U8(r *Uint8X8, v0 *Uint8X8X2, v1 *Uint8X8)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vtbl2S8 Vtbl2S8
//go:noescape
func Vtbl2S8(r *Int8X8, v0 *Int8X8X2, v1 *Int8X8)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vtbl3P8 Vtbl3P8
//go:noescape
func Vtbl3P8(r *Poly8X8, v0 *Poly8X8X3, v1 *Uint8X8)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vtbl3U8 Vtbl3U8
//go:noescape
func Vtbl3U8(r *Uint8X8, v0 *Uint8X8X3, v1 *Uint8X8)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vtbl3S8 Vtbl3S8
//go:noescape
func Vtbl3S8(r *Int8X8, v0 *Int8X8X3, v1 *Int8X8)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vtbl4P8 Vtbl4P8
//go:noescape
func Vtbl4P8(r *Poly8X8, v0 *Poly8X8X4, v1 *Uint8X8)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vtbl4U8 Vtbl4U8
//go:noescape
func Vtbl4U8(r *Uint8X8, v0 *Uint8X8X4, v1 *Uint8X8)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vtbl4S8 Vtbl4S8
//go:noescape
func Vtbl4S8(r *Int8X8, v0 *Int8X8X4, v1 *Int8X8)

// Table vector lookup extension
//
//go:linkname Vtbx1P8 Vtbx1P8
//go:noescape
func Vtbx1P8(r *Poly8X8, v0 *Poly8X8, v1 *Poly8X8, v2 *Uint8X8)

// Table vector lookup extension
//
//go:linkname Vtbx1U8 Vtbx1U8
//go:noescape
func Vtbx1U8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8, v2 *Uint8X8)

// Table vector lookup extension
//
//go:linkname Vtbx1S8 Vtbx1S8
//go:noescape
func Vtbx1S8(r *Int8X8, v0 *Int8X8, v1 *Int8X8, v2 *Int8X8)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vtbx2P8 Vtbx2P8
//go:noescape
func Vtbx2P8(r *Poly8X8, v0 *Poly8X8, v1 *Poly8X8X2, v2 *Uint8X8)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vtbx2U8 Vtbx2U8
//go:noescape
func Vtbx2U8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8X2, v2 *Uint8X8)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vtbx2S8 Vtbx2S8
//go:noescape
func Vtbx2S8(r *Int8X8, v0 *Int8X8, v1 *Int8X8X2, v2 *Int8X8)

// Table vector lookup extension
//
//go:linkname Vtbx3P8 Vtbx3P8
//go:noescape
func Vtbx3P8(r *Poly8X8, v0 *Poly8X8, v1 *Poly8X8X3, v2 *Uint8X8)

// Table vector lookup extension
//
//go:linkname Vtbx3U8 Vtbx3U8
//go:noescape
func Vtbx3U8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8X3, v2 *Uint8X8)

// Table vector lookup extension
//
//go:linkname Vtbx3S8 Vtbx3S8
//go:noescape
func Vtbx3S8(r *Int8X8, v0 *Int8X8, v1 *Int8X8X3, v2 *Int8X8)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vtbx4P8 Vtbx4P8
//go:noescape
func Vtbx4P8(r *Poly8X8, v0 *Poly8X8, v1 *Poly8X8X4, v2 *Uint8X8)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vtbx4U8 Vtbx4U8
//go:noescape
func Vtbx4U8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8X4, v2 *Uint8X8)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vtbx4S8 Vtbx4S8
//go:noescape
func Vtbx4S8(r *Int8X8, v0 *Int8X8, v1 *Int8X8X4, v2 *Int8X8)

// Transpose elements
//
//go:linkname VtrnP8 VtrnP8
//go:noescape
func VtrnP8(r *Poly8X8X2, v0 *Poly8X8, v1 *Poly8X8)

// Transpose elements
//
//go:linkname VtrnP16 VtrnP16
//go:noescape
func VtrnP16(r *Poly16X4X2, v0 *Poly16X4, v1 *Poly16X4)

// Transpose elements
//
//go:linkname VtrnqP8 VtrnqP8
//go:noescape
func VtrnqP8(r *Poly8X16X2, v0 *Poly8X16, v1 *Poly8X16)

// Transpose elements
//
//go:linkname VtrnqP16 VtrnqP16
//go:noescape
func VtrnqP16(r *Poly16X8X2, v0 *Poly16X8, v1 *Poly16X8)

// Transpose elements
//
//go:linkname VtrnqU8 VtrnqU8
//go:noescape
func VtrnqU8(r *Uint8X16X2, v0 *Uint8X16, v1 *Uint8X16)

// Transpose elements
//
//go:linkname VtrnqU32 VtrnqU32
//go:noescape
func VtrnqU32(r *Uint32X4X2, v0 *Uint32X4, v1 *Uint32X4)

// Transpose elements
//
//go:linkname VtrnqU16 VtrnqU16
//go:noescape
func VtrnqU16(r *Uint16X8X2, v0 *Uint16X8, v1 *Uint16X8)

// Transpose elements
//
//go:linkname VtrnqS8 VtrnqS8
//go:noescape
func VtrnqS8(r *Int8X16X2, v0 *Int8X16, v1 *Int8X16)

// Transpose elements
//
//go:linkname VtrnqF32 VtrnqF32
//go:noescape
func VtrnqF32(r *Float32X4X2, v0 *Float32X4, v1 *Float32X4)

// Transpose elements
//
//go:linkname VtrnqS32 VtrnqS32
//go:noescape
func VtrnqS32(r *Int32X4X2, v0 *Int32X4, v1 *Int32X4)

// Transpose elements
//
//go:linkname VtrnqS16 VtrnqS16
//go:noescape
func VtrnqS16(r *Int16X8X2, v0 *Int16X8, v1 *Int16X8)

// Transpose elements
//
//go:linkname VtrnU8 VtrnU8
//go:noescape
func VtrnU8(r *Uint8X8X2, v0 *Uint8X8, v1 *Uint8X8)

// Transpose elements
//
//go:linkname VtrnU32 VtrnU32
//go:noescape
func VtrnU32(r *Uint32X2X2, v0 *Uint32X2, v1 *Uint32X2)

// Transpose elements
//
//go:linkname VtrnU16 VtrnU16
//go:noescape
func VtrnU16(r *Uint16X4X2, v0 *Uint16X4, v1 *Uint16X4)

// Transpose elements
//
//go:linkname VtrnS8 VtrnS8
//go:noescape
func VtrnS8(r *Int8X8X2, v0 *Int8X8, v1 *Int8X8)

// Transpose elements
//
//go:linkname VtrnF32 VtrnF32
//go:noescape
func VtrnF32(r *Float32X2X2, v0 *Float32X2, v1 *Float32X2)

// Transpose elements
//
//go:linkname VtrnS32 VtrnS32
//go:noescape
func VtrnS32(r *Int32X2X2, v0 *Int32X2, v1 *Int32X2)

// Transpose elements
//
//go:linkname VtrnS16 VtrnS16
//go:noescape
func VtrnS16(r *Int16X4X2, v0 *Int16X4, v1 *Int16X4)

// Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VtstP8 VtstP8
//go:noescape
func VtstP8(r *Uint8X8, v0 *Poly8X8, v1 *Poly8X8)

// vtst_p16
//
//go:linkname VtstP16 VtstP16
//go:noescape
func VtstP16(r *Uint16X4, v0 *Poly16X4, v1 *Poly16X4)

// Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VtstqP8 VtstqP8
//go:noescape
func VtstqP8(r *Uint8X16, v0 *Poly8X16, v1 *Poly8X16)

// vtstq_p16
//
//go:linkname VtstqP16 VtstqP16
//go:noescape
func VtstqP16(r *Uint16X8, v0 *Poly16X8, v1 *Poly16X8)

// Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VtstqU8 VtstqU8
//go:noescape
func VtstqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VtstqU32 VtstqU32
//go:noescape
func VtstqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VtstqU16 VtstqU16
//go:noescape
func VtstqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VtstqS8 VtstqS8
//go:noescape
func VtstqS8(r *Uint8X16, v0 *Int8X16, v1 *Int8X16)

// Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VtstqS32 VtstqS32
//go:noescape
func VtstqS32(r *Uint32X4, v0 *Int32X4, v1 *Int32X4)

// Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VtstqS16 VtstqS16
//go:noescape
func VtstqS16(r *Uint16X8, v0 *Int16X8, v1 *Int16X8)

// Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VtstU8 VtstU8
//go:noescape
func VtstU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VtstU32 VtstU32
//go:noescape
func VtstU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VtstU16 VtstU16
//go:noescape
func VtstU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VtstS8 VtstS8
//go:noescape
func VtstS8(r *Uint8X8, v0 *Int8X8, v1 *Int8X8)

// Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VtstS32 VtstS32
//go:noescape
func VtstS32(r *Uint32X2, v0 *Int32X2, v1 *Int32X2)

// Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VtstS16 VtstS16
//go:noescape
func VtstS16(r *Uint16X4, v0 *Int16X4, v1 *Int16X4)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VuzpP8 VuzpP8
//go:noescape
func VuzpP8(r *Poly8X8X2, v0 *Poly8X8, v1 *Poly8X8)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VuzpP16 VuzpP16
//go:noescape
func VuzpP16(r *Poly16X4X2, v0 *Poly16X4, v1 *Poly16X4)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VuzpqP8 VuzpqP8
//go:noescape
func VuzpqP8(r *Poly8X16X2, v0 *Poly8X16, v1 *Poly8X16)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VuzpqP16 VuzpqP16
//go:noescape
func VuzpqP16(r *Poly16X8X2, v0 *Poly16X8, v1 *Poly16X8)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VuzpqU8 VuzpqU8
//go:noescape
func VuzpqU8(r *Uint8X16X2, v0 *Uint8X16, v1 *Uint8X16)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VuzpqU32 VuzpqU32
//go:noescape
func VuzpqU32(r *Uint32X4X2, v0 *Uint32X4, v1 *Uint32X4)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VuzpqU16 VuzpqU16
//go:noescape
func VuzpqU16(r *Uint16X8X2, v0 *Uint16X8, v1 *Uint16X8)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VuzpqS8 VuzpqS8
//go:noescape
func VuzpqS8(r *Int8X16X2, v0 *Int8X16, v1 *Int8X16)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VuzpqF32 VuzpqF32
//go:noescape
func VuzpqF32(r *Float32X4X2, v0 *Float32X4, v1 *Float32X4)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VuzpqS32 VuzpqS32
//go:noescape
func VuzpqS32(r *Int32X4X2, v0 *Int32X4, v1 *Int32X4)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VuzpqS16 VuzpqS16
//go:noescape
func VuzpqS16(r *Int16X8X2, v0 *Int16X8, v1 *Int16X8)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VuzpU8 VuzpU8
//go:noescape
func VuzpU8(r *Uint8X8X2, v0 *Uint8X8, v1 *Uint8X8)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VuzpU32 VuzpU32
//go:noescape
func VuzpU32(r *Uint32X2X2, v0 *Uint32X2, v1 *Uint32X2)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VuzpU16 VuzpU16
//go:noescape
func VuzpU16(r *Uint16X4X2, v0 *Uint16X4, v1 *Uint16X4)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VuzpS8 VuzpS8
//go:noescape
func VuzpS8(r *Int8X8X2, v0 *Int8X8, v1 *Int8X8)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VuzpF32 VuzpF32
//go:noescape
func VuzpF32(r *Float32X2X2, v0 *Float32X2, v1 *Float32X2)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VuzpS32 VuzpS32
//go:noescape
func VuzpS32(r *Int32X2X2, v0 *Int32X2, v1 *Int32X2)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VuzpS16 VuzpS16
//go:noescape
func VuzpS16(r *Int16X4X2, v0 *Int16X4, v1 *Int16X4)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname VzipP8 VzipP8
//go:noescape
func VzipP8(r *Poly8X8X2, v0 *Poly8X8, v1 *Poly8X8)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname VzipP16 VzipP16
//go:noescape
func VzipP16(r *Poly16X4X2, v0 *Poly16X4, v1 *Poly16X4)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname VzipqP8 VzipqP8
//go:noescape
func VzipqP8(r *Poly8X16X2, v0 *Poly8X16, v1 *Poly8X16)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname VzipqP16 VzipqP16
//go:noescape
func VzipqP16(r *Poly16X8X2, v0 *Poly16X8, v1 *Poly16X8)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname VzipqU8 VzipqU8
//go:noescape
func VzipqU8(r *Uint8X16X2, v0 *Uint8X16, v1 *Uint8X16)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname VzipqU32 VzipqU32
//go:noescape
func VzipqU32(r *Uint32X4X2, v0 *Uint32X4, v1 *Uint32X4)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname VzipqU16 VzipqU16
//go:noescape
func VzipqU16(r *Uint16X8X2, v0 *Uint16X8, v1 *Uint16X8)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname VzipqS8 VzipqS8
//go:noescape
func VzipqS8(r *Int8X16X2, v0 *Int8X16, v1 *Int8X16)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname VzipqF32 VzipqF32
//go:noescape
func VzipqF32(r *Float32X4X2, v0 *Float32X4, v1 *Float32X4)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname VzipqS32 VzipqS32
//go:noescape
func VzipqS32(r *Int32X4X2, v0 *Int32X4, v1 *Int32X4)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname VzipqS16 VzipqS16
//go:noescape
func VzipqS16(r *Int16X8X2, v0 *Int16X8, v1 *Int16X8)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname VzipU8 VzipU8
//go:noescape
func VzipU8(r *Uint8X8X2, v0 *Uint8X8, v1 *Uint8X8)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname VzipU32 VzipU32
//go:noescape
func VzipU32(r *Uint32X2X2, v0 *Uint32X2, v1 *Uint32X2)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname VzipU16 VzipU16
//go:noescape
func VzipU16(r *Uint16X4X2, v0 *Uint16X4, v1 *Uint16X4)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname VzipS8 VzipS8
//go:noescape
func VzipS8(r *Int8X8X2, v0 *Int8X8, v1 *Int8X8)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname VzipF32 VzipF32
//go:noescape
func VzipF32(r *Float32X2X2, v0 *Float32X2, v1 *Float32X2)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname VzipS32 VzipS32
//go:noescape
func VzipS32(r *Int32X2X2, v0 *Int32X2, v1 *Int32X2)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname VzipS16 VzipS16
//go:noescape
func VzipS16(r *Int16X4X2, v0 *Int16X4, v1 *Int16X4)

// Floating-point Convert to Signed integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to a signed integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtaqS32F32 VcvtaqS32F32
//go:noescape
func VcvtaqS32F32(r *Int32X4, v0 *Float32X4)

// Floating-point Convert to Signed integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to a signed integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtaS32F32 VcvtaS32F32
//go:noescape
func VcvtaS32F32(r *Int32X2, v0 *Float32X2)

// Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtaqU32F32 VcvtaqU32F32
//go:noescape
func VcvtaqU32F32(r *Uint32X4, v0 *Float32X4)

// Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtaU32F32 VcvtaU32F32
//go:noescape
func VcvtaU32F32(r *Uint32X2, v0 *Float32X2)

// Floating-point Convert to Signed integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtmqS32F32 VcvtmqS32F32
//go:noescape
func VcvtmqS32F32(r *Int32X4, v0 *Float32X4)

// Floating-point Convert to Signed integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtmS32F32 VcvtmS32F32
//go:noescape
func VcvtmS32F32(r *Int32X2, v0 *Float32X2)

// Floating-point Convert to Unsigned integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtmqU32F32 VcvtmqU32F32
//go:noescape
func VcvtmqU32F32(r *Uint32X4, v0 *Float32X4)

// Floating-point Convert to Unsigned integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtmU32F32 VcvtmU32F32
//go:noescape
func VcvtmU32F32(r *Uint32X2, v0 *Float32X2)

// Floating-point Convert to Signed integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtnqS32F32 VcvtnqS32F32
//go:noescape
func VcvtnqS32F32(r *Int32X4, v0 *Float32X4)

// Floating-point Convert to Signed integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtnS32F32 VcvtnS32F32
//go:noescape
func VcvtnS32F32(r *Int32X2, v0 *Float32X2)

// Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtnqU32F32 VcvtnqU32F32
//go:noescape
func VcvtnqU32F32(r *Uint32X4, v0 *Float32X4)

// Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtnU32F32 VcvtnU32F32
//go:noescape
func VcvtnU32F32(r *Uint32X2, v0 *Float32X2)

// Floating-point Convert to Signed integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtpqS32F32 VcvtpqS32F32
//go:noescape
func VcvtpqS32F32(r *Int32X4, v0 *Float32X4)

// Floating-point Convert to Signed integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtpS32F32 VcvtpS32F32
//go:noescape
func VcvtpS32F32(r *Int32X2, v0 *Float32X2)

// Floating-point Convert to Unsigned integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtpqU32F32 VcvtpqU32F32
//go:noescape
func VcvtpqU32F32(r *Uint32X4, v0 *Float32X4)

// Floating-point Convert to Unsigned integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtpU32F32 VcvtpU32F32
//go:noescape
func VcvtpU32F32(r *Uint32X2, v0 *Float32X2)

// AES single round decryption.
//
//go:linkname VaesdqU8 VaesdqU8
//go:noescape
func VaesdqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// AES single round encryption.
//
//go:linkname VaeseqU8 VaeseqU8
//go:noescape
func VaeseqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// AES inverse mix columns.
//
//go:linkname VaesimcqU8 VaesimcqU8
//go:noescape
func VaesimcqU8(r *Uint8X16, v0 *Uint8X16)

// AES mix columns.
//
//go:linkname VaesmcqU8 VaesmcqU8
//go:noescape
func VaesmcqU8(r *Uint8X16, v0 *Uint8X16)

// Floating-point Round to Integral, toward Zero (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndqF32 VrndqF32
//go:noescape
func VrndqF32(r *Float32X4, v0 *Float32X4)

// Floating-point Round to Integral, toward Zero (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndF32 VrndF32
//go:noescape
func VrndF32(r *Float32X2, v0 *Float32X2)

// Floating-point Round to Integral, to nearest with ties to Away (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round to Nearest with Ties to Away rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndaqF32 VrndaqF32
//go:noescape
func VrndaqF32(r *Float32X4, v0 *Float32X4)

// Floating-point Round to Integral, to nearest with ties to Away (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round to Nearest with Ties to Away rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndaF32 VrndaF32
//go:noescape
func VrndaF32(r *Float32X2, v0 *Float32X2)

// Floating-point Round to Integral, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndiqF32 VrndiqF32
//go:noescape
func VrndiqF32(r *Float32X4, v0 *Float32X4)

// Floating-point Round to Integral, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndiF32 VrndiF32
//go:noescape
func VrndiF32(r *Float32X2, v0 *Float32X2)

// Floating-point Round to Integral, toward Minus infinity (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndmqF32 VrndmqF32
//go:noescape
func VrndmqF32(r *Float32X4, v0 *Float32X4)

// Floating-point Round to Integral, toward Minus infinity (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndmF32 VrndmF32
//go:noescape
func VrndmF32(r *Float32X2, v0 *Float32X2)

// Floating-point Round to Integral, to nearest with ties to even (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndnqF32 VrndnqF32
//go:noescape
func VrndnqF32(r *Float32X4, v0 *Float32X4)

// Floating-point Round to Integral, to nearest with ties to even (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndnF32 VrndnF32
//go:noescape
func VrndnF32(r *Float32X2, v0 *Float32X2)

// Floating-point Round to Integral, to nearest with ties to even (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndnsF32 VrndnsF32
//go:noescape
func VrndnsF32(r *Float32, v0 *Float32)

// Floating-point Round to Integral, toward Plus infinity (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndpqF32 VrndpqF32
//go:noescape
func VrndpqF32(r *Float32X4, v0 *Float32X4)

// Floating-point Round to Integral, toward Plus infinity (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndpF32 VrndpF32
//go:noescape
func VrndpF32(r *Float32X2, v0 *Float32X2)

// Floating-point Round to Integral exact, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndxqF32 VrndxqF32
//go:noescape
func VrndxqF32(r *Float32X4, v0 *Float32X4)

// Floating-point Round to Integral exact, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndxF32 VrndxF32
//go:noescape
func VrndxF32(r *Float32X2, v0 *Float32X2)

// Floating-point Maximum Number (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, writes the larger of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmaxnmqF32 VmaxnmqF32
//go:noescape
func VmaxnmqF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Floating-point Maximum Number (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, writes the larger of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmaxnmF32 VmaxnmF32
//go:noescape
func VmaxnmF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Floating-point Minimum Number (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, writes the smaller of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VminnmqF32 VminnmqF32
//go:noescape
func VminnmqF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Floating-point Minimum Number (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, writes the smaller of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VminnmF32 VminnmF32
//go:noescape
func VminnmF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// SHA1 hash update (choose).
//
//go:linkname Vsha1CqU32 Vsha1CqU32
//go:noescape
func Vsha1CqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32, v2 *Uint32X4)

// SHA1 fixed rotate.
//
//go:linkname Vsha1HU32 Vsha1HU32
//go:noescape
func Vsha1HU32(r *Uint32, v0 *Uint32)

// SHA1 hash update (majority).
//
//go:linkname Vsha1MqU32 Vsha1MqU32
//go:noescape
func Vsha1MqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32, v2 *Uint32X4)

// SHA1 hash update (parity).
//
//go:linkname Vsha1PqU32 Vsha1PqU32
//go:noescape
func Vsha1PqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32, v2 *Uint32X4)

// SHA1 schedule update 0.
//
//go:linkname Vsha1Su0QU32 Vsha1Su0QU32
//go:noescape
func Vsha1Su0QU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4, v2 *Uint32X4)

// SHA1 schedule update 1.
//
//go:linkname Vsha1Su1QU32 Vsha1Su1QU32
//go:noescape
func Vsha1Su1QU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// SHA256 hash update (part 1).
//
//go:linkname Vsha256HqU32 Vsha256HqU32
//go:noescape
func Vsha256HqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4, v2 *Uint32X4)

// SHA256 hash update (part 2).
//
//go:linkname Vsha256H2QU32 Vsha256H2QU32
//go:noescape
func Vsha256H2QU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4, v2 *Uint32X4)

// SHA256 schedule update 0.
//
//go:linkname Vsha256Su0QU32 Vsha256Su0QU32
//go:noescape
func Vsha256Su0QU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// SHA256 schedule update 1.
//
//go:linkname Vsha256Su1QU32 Vsha256Su1QU32
//go:noescape
func Vsha256Su1QU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4, v2 *Uint32X4)

// Bit Clear and Exclusive OR performs a bitwise AND of the 128-bit vector in a source SIMD&FP register and the complement of the vector in another source SIMD&FP register, then performs a bitwise exclusive OR of the resulting vector and the vector in a third source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbcaxqU8 VbcaxqU8
//go:noescape
func VbcaxqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16, v2 *Uint8X16)

// Bit Clear and Exclusive OR performs a bitwise AND of the 128-bit vector in a source SIMD&FP register and the complement of the vector in another source SIMD&FP register, then performs a bitwise exclusive OR of the resulting vector and the vector in a third source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbcaxqU32 VbcaxqU32
//go:noescape
func VbcaxqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4, v2 *Uint32X4)

// Bit Clear and Exclusive OR performs a bitwise AND of the 128-bit vector in a source SIMD&FP register and the complement of the vector in another source SIMD&FP register, then performs a bitwise exclusive OR of the resulting vector and the vector in a third source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbcaxqU64 VbcaxqU64
//go:noescape
func VbcaxqU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2, v2 *Uint64X2)

// Bit Clear and Exclusive OR performs a bitwise AND of the 128-bit vector in a source SIMD&FP register and the complement of the vector in another source SIMD&FP register, then performs a bitwise exclusive OR of the resulting vector and the vector in a third source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbcaxqU16 VbcaxqU16
//go:noescape
func VbcaxqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8, v2 *Uint16X8)

// Bit Clear and Exclusive OR performs a bitwise AND of the 128-bit vector in a source SIMD&FP register and the complement of the vector in another source SIMD&FP register, then performs a bitwise exclusive OR of the resulting vector and the vector in a third source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbcaxqS8 VbcaxqS8
//go:noescape
func VbcaxqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16, v2 *Int8X16)

// Bit Clear and Exclusive OR performs a bitwise AND of the 128-bit vector in a source SIMD&FP register and the complement of the vector in another source SIMD&FP register, then performs a bitwise exclusive OR of the resulting vector and the vector in a third source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbcaxqS32 VbcaxqS32
//go:noescape
func VbcaxqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4, v2 *Int32X4)

// Bit Clear and Exclusive OR performs a bitwise AND of the 128-bit vector in a source SIMD&FP register and the complement of the vector in another source SIMD&FP register, then performs a bitwise exclusive OR of the resulting vector and the vector in a third source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbcaxqS64 VbcaxqS64
//go:noescape
func VbcaxqS64(r *Int64X2, v0 *Int64X2, v1 *Int64X2, v2 *Int64X2)

// Bit Clear and Exclusive OR performs a bitwise AND of the 128-bit vector in a source SIMD&FP register and the complement of the vector in another source SIMD&FP register, then performs a bitwise exclusive OR of the resulting vector and the vector in a third source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VbcaxqS16 VbcaxqS16
//go:noescape
func VbcaxqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8, v2 *Int16X8)

// Three-way Exclusive OR performs a three-way exclusive OR of the values in the three source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname Veor3QU8 Veor3QU8
//go:noescape
func Veor3QU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16, v2 *Uint8X16)

// Three-way Exclusive OR performs a three-way exclusive OR of the values in the three source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname Veor3QU32 Veor3QU32
//go:noescape
func Veor3QU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4, v2 *Uint32X4)

// Three-way Exclusive OR performs a three-way exclusive OR of the values in the three source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname Veor3QU64 Veor3QU64
//go:noescape
func Veor3QU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2, v2 *Uint64X2)

// Three-way Exclusive OR performs a three-way exclusive OR of the values in the three source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname Veor3QU16 Veor3QU16
//go:noescape
func Veor3QU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8, v2 *Uint16X8)

// Three-way Exclusive OR performs a three-way exclusive OR of the values in the three source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname Veor3QS8 Veor3QS8
//go:noescape
func Veor3QS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16, v2 *Int8X16)

// Three-way Exclusive OR performs a three-way exclusive OR of the values in the three source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname Veor3QS32 Veor3QS32
//go:noescape
func Veor3QS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4, v2 *Int32X4)

// Three-way Exclusive OR performs a three-way exclusive OR of the values in the three source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname Veor3QS64 Veor3QS64
//go:noescape
func Veor3QS64(r *Int64X2, v0 *Int64X2, v1 *Int64X2, v2 *Int64X2)

// Three-way Exclusive OR performs a three-way exclusive OR of the values in the three source SIMD&FP registers, and writes the result to the destination SIMD&FP register.
//
//go:linkname Veor3QS16 Veor3QS16
//go:noescape
func Veor3QS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8, v2 *Int16X8)

// Rotate and Exclusive OR rotates each 64-bit element of the 128-bit vector in a source SIMD&FP register left by 1, performs a bitwise exclusive OR of the resulting 128-bit vector and the vector in another source SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname Vrax1QU64 Vrax1QU64
//go:noescape
func Vrax1QU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// SHA512 Hash update part 1 takes the values from the three 128-bit source SIMD&FP registers and produces a 128-bit output value that combines the sigma1 and chi functions of two iterations of the SHA512 computation. It returns this value to the destination SIMD&FP register.
//
//go:linkname Vsha512HqU64 Vsha512HqU64
//go:noescape
func Vsha512HqU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2, v2 *Uint64X2)

// SHA512 Hash update part 2 takes the values from the three 128-bit source SIMD&FP registers and produces a 128-bit output value that combines the sigma0 and majority functions of two iterations of the SHA512 computation. It returns this value to the destination SIMD&FP register.
//
//go:linkname Vsha512H2QU64 Vsha512H2QU64
//go:noescape
func Vsha512H2QU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2, v2 *Uint64X2)

// SHA512 Schedule Update 0 takes the values from the two 128-bit source SIMD&FP registers and produces a 128-bit output value that combines the gamma0 functions of two iterations of the SHA512 schedule update that are performed after the first 16 iterations within a block. It returns this value to the destination SIMD&FP register.
//
//go:linkname Vsha512Su0QU64 Vsha512Su0QU64
//go:noescape
func Vsha512Su0QU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// SHA512 Schedule Update 1 takes the values from the three source SIMD&FP registers and produces a 128-bit output value that combines the gamma1 functions of two iterations of the SHA512 schedule update that are performed after the first 16 iterations within a block. It returns this value to the destination SIMD&FP register.
//
//go:linkname Vsha512Su1QU64 Vsha512Su1QU64
//go:noescape
func Vsha512Su1QU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2, v2 *Uint64X2)

// SM3PARTW1 takes three 128-bit vectors from the three source SIMD&FP registers and returns a 128-bit result in the destination SIMD&FP register. The result is obtained by a three-way exclusive OR of the elements within the input vectors with some fixed rotations, see the Operation pseudocode for more information.
//
//go:linkname Vsm3Partw1QU32 Vsm3Partw1QU32
//go:noescape
func Vsm3Partw1QU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4, v2 *Uint32X4)

// SM3PARTW2 takes three 128-bit vectors from three source SIMD&FP registers and returns a 128-bit result in the destination SIMD&FP register. The result is obtained by a three-way exclusive OR of the elements within the input vectors with some fixed rotations, see the Operation pseudocode for more information.
//
//go:linkname Vsm3Partw2QU32 Vsm3Partw2QU32
//go:noescape
func Vsm3Partw2QU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4, v2 *Uint32X4)

// SM3SS1 rotates the top 32 bits of the 128-bit vector in the first source SIMD&FP register by 12, and adds that 32-bit value to the two other 32-bit values held in the top 32 bits of each of the 128-bit vectors in the second and third source SIMD&FP registers, rotating this result left by 7 and writing the final result into the top 32 bits of the vector in the destination SIMD&FP register, with the bottom 96 bits of the vector being written to 0.
//
//go:linkname Vsm3Ss1QU32 Vsm3Ss1QU32
//go:noescape
func Vsm3Ss1QU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4, v2 *Uint32X4)

// SM4 Encode takes input data as a 128-bit vector from the first source SIMD&FP register, and four iterations of the round key held as the elements of the 128-bit vector in the second source SIMD&FP register. It encrypts the data by four rounds, in accordance with the SM4 standard, returning the 128-bit result to the destination SIMD&FP register.
//
//go:linkname Vsm4EqU32 Vsm4EqU32
//go:noescape
func Vsm4EqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// SM4 Key takes an input as a 128-bit vector from the first source SIMD&FP register and a 128-bit constant from the second SIMD&FP register. It derives four iterations of the output key, in accordance with the SM4 standard, returning the 128-bit result to the destination SIMD&FP register.
//
//go:linkname Vsm4EkeyqU32 Vsm4EkeyqU32
//go:noescape
func Vsm4EkeyqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Floating-point Convert to Signed integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to a signed integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtaqS64F64 VcvtaqS64F64
//go:noescape
func VcvtaqS64F64(r *Int64X2, v0 *Float64X2)

// Floating-point Convert to Signed integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to a signed integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtaS64F64 VcvtaS64F64
//go:noescape
func VcvtaS64F64(r *Int64X1, v0 *Float64X1)

// Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtaqU64F64 VcvtaqU64F64
//go:noescape
func VcvtaqU64F64(r *Uint64X2, v0 *Float64X2)

// Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtaU64F64 VcvtaU64F64
//go:noescape
func VcvtaU64F64(r *Uint64X1, v0 *Float64X1)

// Floating-point Convert to Signed integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtmqS64F64 VcvtmqS64F64
//go:noescape
func VcvtmqS64F64(r *Int64X2, v0 *Float64X2)

// Floating-point Convert to Signed integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtmS64F64 VcvtmS64F64
//go:noescape
func VcvtmS64F64(r *Int64X1, v0 *Float64X1)

// Floating-point Convert to Unsigned integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtmqU64F64 VcvtmqU64F64
//go:noescape
func VcvtmqU64F64(r *Uint64X2, v0 *Float64X2)

// Floating-point Convert to Unsigned integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtmU64F64 VcvtmU64F64
//go:noescape
func VcvtmU64F64(r *Uint64X1, v0 *Float64X1)

// Floating-point Convert to Signed integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtnqS64F64 VcvtnqS64F64
//go:noescape
func VcvtnqS64F64(r *Int64X2, v0 *Float64X2)

// Floating-point Convert to Signed integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtnS64F64 VcvtnS64F64
//go:noescape
func VcvtnS64F64(r *Int64X1, v0 *Float64X1)

// Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtnqU64F64 VcvtnqU64F64
//go:noescape
func VcvtnqU64F64(r *Uint64X2, v0 *Float64X2)

// Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtnU64F64 VcvtnU64F64
//go:noescape
func VcvtnU64F64(r *Uint64X1, v0 *Float64X1)

// Floating-point Convert to Signed integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtpqS64F64 VcvtpqS64F64
//go:noescape
func VcvtpqS64F64(r *Int64X2, v0 *Float64X2)

// Floating-point Convert to Signed integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtpS64F64 VcvtpS64F64
//go:noescape
func VcvtpS64F64(r *Int64X1, v0 *Float64X1)

// Floating-point Convert to Unsigned integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtpqU64F64 VcvtpqU64F64
//go:noescape
func VcvtpqU64F64(r *Uint64X2, v0 *Float64X2)

// Floating-point Convert to Unsigned integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtpU64F64 VcvtpU64F64
//go:noescape
func VcvtpU64F64(r *Uint64X1, v0 *Float64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP8P64 VreinterpretP8P64
//go:noescape
func VreinterpretP8P64(r *Poly8X8, v0 *Poly64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP8P16 VreinterpretP8P16
//go:noescape
func VreinterpretP8P16(r *Poly8X8, v0 *Poly16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP8U8 VreinterpretP8U8
//go:noescape
func VreinterpretP8U8(r *Poly8X8, v0 *Uint8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP8U32 VreinterpretP8U32
//go:noescape
func VreinterpretP8U32(r *Poly8X8, v0 *Uint32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP8U64 VreinterpretP8U64
//go:noescape
func VreinterpretP8U64(r *Poly8X8, v0 *Uint64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP8U16 VreinterpretP8U16
//go:noescape
func VreinterpretP8U16(r *Poly8X8, v0 *Uint16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP8S8 VreinterpretP8S8
//go:noescape
func VreinterpretP8S8(r *Poly8X8, v0 *Int8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP8F64 VreinterpretP8F64
//go:noescape
func VreinterpretP8F64(r *Poly8X8, v0 *Float64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP8F32 VreinterpretP8F32
//go:noescape
func VreinterpretP8F32(r *Poly8X8, v0 *Float32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP8S32 VreinterpretP8S32
//go:noescape
func VreinterpretP8S32(r *Poly8X8, v0 *Int32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP8S64 VreinterpretP8S64
//go:noescape
func VreinterpretP8S64(r *Poly8X8, v0 *Int64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP8S16 VreinterpretP8S16
//go:noescape
func VreinterpretP8S16(r *Poly8X8, v0 *Int16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP64P8 VreinterpretP64P8
//go:noescape
func VreinterpretP64P8(r *Poly64X1, v0 *Poly8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP64P16 VreinterpretP64P16
//go:noescape
func VreinterpretP64P16(r *Poly64X1, v0 *Poly16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP64U8 VreinterpretP64U8
//go:noescape
func VreinterpretP64U8(r *Poly64X1, v0 *Uint8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP64U32 VreinterpretP64U32
//go:noescape
func VreinterpretP64U32(r *Poly64X1, v0 *Uint32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP64U64 VreinterpretP64U64
//go:noescape
func VreinterpretP64U64(r *Poly64X1, v0 *Uint64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP64U16 VreinterpretP64U16
//go:noescape
func VreinterpretP64U16(r *Poly64X1, v0 *Uint16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP64S8 VreinterpretP64S8
//go:noescape
func VreinterpretP64S8(r *Poly64X1, v0 *Int8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP64F64 VreinterpretP64F64
//go:noescape
func VreinterpretP64F64(r *Poly64X1, v0 *Float64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP64F32 VreinterpretP64F32
//go:noescape
func VreinterpretP64F32(r *Poly64X1, v0 *Float32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP64S32 VreinterpretP64S32
//go:noescape
func VreinterpretP64S32(r *Poly64X1, v0 *Int32X2)

// vreinterpret_p64_s64
//
//go:linkname VreinterpretP64S64 VreinterpretP64S64
//go:noescape
func VreinterpretP64S64(r *Poly64X1, v0 *Int64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP64S16 VreinterpretP64S16
//go:noescape
func VreinterpretP64S16(r *Poly64X1, v0 *Int16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP16P8 VreinterpretP16P8
//go:noescape
func VreinterpretP16P8(r *Poly16X4, v0 *Poly8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP16P64 VreinterpretP16P64
//go:noescape
func VreinterpretP16P64(r *Poly16X4, v0 *Poly64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP16U8 VreinterpretP16U8
//go:noescape
func VreinterpretP16U8(r *Poly16X4, v0 *Uint8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP16U32 VreinterpretP16U32
//go:noescape
func VreinterpretP16U32(r *Poly16X4, v0 *Uint32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP16U64 VreinterpretP16U64
//go:noescape
func VreinterpretP16U64(r *Poly16X4, v0 *Uint64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP16U16 VreinterpretP16U16
//go:noescape
func VreinterpretP16U16(r *Poly16X4, v0 *Uint16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP16S8 VreinterpretP16S8
//go:noescape
func VreinterpretP16S8(r *Poly16X4, v0 *Int8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP16F64 VreinterpretP16F64
//go:noescape
func VreinterpretP16F64(r *Poly16X4, v0 *Float64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP16F32 VreinterpretP16F32
//go:noescape
func VreinterpretP16F32(r *Poly16X4, v0 *Float32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP16S32 VreinterpretP16S32
//go:noescape
func VreinterpretP16S32(r *Poly16X4, v0 *Int32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP16S64 VreinterpretP16S64
//go:noescape
func VreinterpretP16S64(r *Poly16X4, v0 *Int64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretP16S16 VreinterpretP16S16
//go:noescape
func VreinterpretP16S16(r *Poly16X4, v0 *Int16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP8P128 VreinterpretqP8P128
//go:noescape
func VreinterpretqP8P128(r *Poly8X16, v0 *Poly128)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP8P64 VreinterpretqP8P64
//go:noescape
func VreinterpretqP8P64(r *Poly8X16, v0 *Poly64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP8P16 VreinterpretqP8P16
//go:noescape
func VreinterpretqP8P16(r *Poly8X16, v0 *Poly16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP8U8 VreinterpretqP8U8
//go:noescape
func VreinterpretqP8U8(r *Poly8X16, v0 *Uint8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP8U32 VreinterpretqP8U32
//go:noescape
func VreinterpretqP8U32(r *Poly8X16, v0 *Uint32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP8U64 VreinterpretqP8U64
//go:noescape
func VreinterpretqP8U64(r *Poly8X16, v0 *Uint64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP8U16 VreinterpretqP8U16
//go:noescape
func VreinterpretqP8U16(r *Poly8X16, v0 *Uint16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP8S8 VreinterpretqP8S8
//go:noescape
func VreinterpretqP8S8(r *Poly8X16, v0 *Int8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP8F64 VreinterpretqP8F64
//go:noescape
func VreinterpretqP8F64(r *Poly8X16, v0 *Float64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP8F32 VreinterpretqP8F32
//go:noescape
func VreinterpretqP8F32(r *Poly8X16, v0 *Float32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP8S32 VreinterpretqP8S32
//go:noescape
func VreinterpretqP8S32(r *Poly8X16, v0 *Int32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP8S64 VreinterpretqP8S64
//go:noescape
func VreinterpretqP8S64(r *Poly8X16, v0 *Int64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP8S16 VreinterpretqP8S16
//go:noescape
func VreinterpretqP8S16(r *Poly8X16, v0 *Int16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP128P8 VreinterpretqP128P8
//go:noescape
func VreinterpretqP128P8(r *Poly128, v0 *Poly8X16)

// vreinterpretq_p128_p64
//
//go:linkname VreinterpretqP128P64 VreinterpretqP128P64
//go:noescape
func VreinterpretqP128P64(r *Poly128, v0 *Poly64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP128P16 VreinterpretqP128P16
//go:noescape
func VreinterpretqP128P16(r *Poly128, v0 *Poly16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP128U8 VreinterpretqP128U8
//go:noescape
func VreinterpretqP128U8(r *Poly128, v0 *Uint8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP128U32 VreinterpretqP128U32
//go:noescape
func VreinterpretqP128U32(r *Poly128, v0 *Uint32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP128U64 VreinterpretqP128U64
//go:noescape
func VreinterpretqP128U64(r *Poly128, v0 *Uint64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP128U16 VreinterpretqP128U16
//go:noescape
func VreinterpretqP128U16(r *Poly128, v0 *Uint16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP128S8 VreinterpretqP128S8
//go:noescape
func VreinterpretqP128S8(r *Poly128, v0 *Int8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP128F64 VreinterpretqP128F64
//go:noescape
func VreinterpretqP128F64(r *Poly128, v0 *Float64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP128F32 VreinterpretqP128F32
//go:noescape
func VreinterpretqP128F32(r *Poly128, v0 *Float32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP128S32 VreinterpretqP128S32
//go:noescape
func VreinterpretqP128S32(r *Poly128, v0 *Int32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP128S64 VreinterpretqP128S64
//go:noescape
func VreinterpretqP128S64(r *Poly128, v0 *Int64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP128S16 VreinterpretqP128S16
//go:noescape
func VreinterpretqP128S16(r *Poly128, v0 *Int16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP64P8 VreinterpretqP64P8
//go:noescape
func VreinterpretqP64P8(r *Poly64X2, v0 *Poly8X16)

// vreinterpretq_p64_p128
//
//go:linkname VreinterpretqP64P128 VreinterpretqP64P128
//go:noescape
func VreinterpretqP64P128(r *Poly64X2, v0 *Poly128)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP64P16 VreinterpretqP64P16
//go:noescape
func VreinterpretqP64P16(r *Poly64X2, v0 *Poly16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP64U8 VreinterpretqP64U8
//go:noescape
func VreinterpretqP64U8(r *Poly64X2, v0 *Uint8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP64U32 VreinterpretqP64U32
//go:noescape
func VreinterpretqP64U32(r *Poly64X2, v0 *Uint32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP64U64 VreinterpretqP64U64
//go:noescape
func VreinterpretqP64U64(r *Poly64X2, v0 *Uint64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP64U16 VreinterpretqP64U16
//go:noescape
func VreinterpretqP64U16(r *Poly64X2, v0 *Uint16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP64S8 VreinterpretqP64S8
//go:noescape
func VreinterpretqP64S8(r *Poly64X2, v0 *Int8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP64F64 VreinterpretqP64F64
//go:noescape
func VreinterpretqP64F64(r *Poly64X2, v0 *Float64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP64F32 VreinterpretqP64F32
//go:noescape
func VreinterpretqP64F32(r *Poly64X2, v0 *Float32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP64S32 VreinterpretqP64S32
//go:noescape
func VreinterpretqP64S32(r *Poly64X2, v0 *Int32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP64S64 VreinterpretqP64S64
//go:noescape
func VreinterpretqP64S64(r *Poly64X2, v0 *Int64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP64S16 VreinterpretqP64S16
//go:noescape
func VreinterpretqP64S16(r *Poly64X2, v0 *Int16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP16P8 VreinterpretqP16P8
//go:noescape
func VreinterpretqP16P8(r *Poly16X8, v0 *Poly8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP16P128 VreinterpretqP16P128
//go:noescape
func VreinterpretqP16P128(r *Poly16X8, v0 *Poly128)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP16P64 VreinterpretqP16P64
//go:noescape
func VreinterpretqP16P64(r *Poly16X8, v0 *Poly64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP16U8 VreinterpretqP16U8
//go:noescape
func VreinterpretqP16U8(r *Poly16X8, v0 *Uint8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP16U32 VreinterpretqP16U32
//go:noescape
func VreinterpretqP16U32(r *Poly16X8, v0 *Uint32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP16U64 VreinterpretqP16U64
//go:noescape
func VreinterpretqP16U64(r *Poly16X8, v0 *Uint64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP16U16 VreinterpretqP16U16
//go:noescape
func VreinterpretqP16U16(r *Poly16X8, v0 *Uint16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP16S8 VreinterpretqP16S8
//go:noescape
func VreinterpretqP16S8(r *Poly16X8, v0 *Int8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP16F64 VreinterpretqP16F64
//go:noescape
func VreinterpretqP16F64(r *Poly16X8, v0 *Float64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP16F32 VreinterpretqP16F32
//go:noescape
func VreinterpretqP16F32(r *Poly16X8, v0 *Float32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP16S32 VreinterpretqP16S32
//go:noescape
func VreinterpretqP16S32(r *Poly16X8, v0 *Int32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP16S64 VreinterpretqP16S64
//go:noescape
func VreinterpretqP16S64(r *Poly16X8, v0 *Int64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqP16S16 VreinterpretqP16S16
//go:noescape
func VreinterpretqP16S16(r *Poly16X8, v0 *Int16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU8P8 VreinterpretqU8P8
//go:noescape
func VreinterpretqU8P8(r *Uint8X16, v0 *Poly8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU8P128 VreinterpretqU8P128
//go:noescape
func VreinterpretqU8P128(r *Uint8X16, v0 *Poly128)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU8P64 VreinterpretqU8P64
//go:noescape
func VreinterpretqU8P64(r *Uint8X16, v0 *Poly64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU8P16 VreinterpretqU8P16
//go:noescape
func VreinterpretqU8P16(r *Uint8X16, v0 *Poly16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU8U32 VreinterpretqU8U32
//go:noescape
func VreinterpretqU8U32(r *Uint8X16, v0 *Uint32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU8U64 VreinterpretqU8U64
//go:noescape
func VreinterpretqU8U64(r *Uint8X16, v0 *Uint64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU8U16 VreinterpretqU8U16
//go:noescape
func VreinterpretqU8U16(r *Uint8X16, v0 *Uint16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU8S8 VreinterpretqU8S8
//go:noescape
func VreinterpretqU8S8(r *Uint8X16, v0 *Int8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU8F64 VreinterpretqU8F64
//go:noescape
func VreinterpretqU8F64(r *Uint8X16, v0 *Float64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU8F32 VreinterpretqU8F32
//go:noescape
func VreinterpretqU8F32(r *Uint8X16, v0 *Float32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU8S32 VreinterpretqU8S32
//go:noescape
func VreinterpretqU8S32(r *Uint8X16, v0 *Int32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU8S64 VreinterpretqU8S64
//go:noescape
func VreinterpretqU8S64(r *Uint8X16, v0 *Int64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU8S16 VreinterpretqU8S16
//go:noescape
func VreinterpretqU8S16(r *Uint8X16, v0 *Int16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU32P8 VreinterpretqU32P8
//go:noescape
func VreinterpretqU32P8(r *Uint32X4, v0 *Poly8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU32P128 VreinterpretqU32P128
//go:noescape
func VreinterpretqU32P128(r *Uint32X4, v0 *Poly128)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU32P64 VreinterpretqU32P64
//go:noescape
func VreinterpretqU32P64(r *Uint32X4, v0 *Poly64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU32P16 VreinterpretqU32P16
//go:noescape
func VreinterpretqU32P16(r *Uint32X4, v0 *Poly16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU32U8 VreinterpretqU32U8
//go:noescape
func VreinterpretqU32U8(r *Uint32X4, v0 *Uint8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU32U64 VreinterpretqU32U64
//go:noescape
func VreinterpretqU32U64(r *Uint32X4, v0 *Uint64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU32U16 VreinterpretqU32U16
//go:noescape
func VreinterpretqU32U16(r *Uint32X4, v0 *Uint16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU32S8 VreinterpretqU32S8
//go:noescape
func VreinterpretqU32S8(r *Uint32X4, v0 *Int8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU32F64 VreinterpretqU32F64
//go:noescape
func VreinterpretqU32F64(r *Uint32X4, v0 *Float64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU32F32 VreinterpretqU32F32
//go:noescape
func VreinterpretqU32F32(r *Uint32X4, v0 *Float32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU32S32 VreinterpretqU32S32
//go:noescape
func VreinterpretqU32S32(r *Uint32X4, v0 *Int32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU32S64 VreinterpretqU32S64
//go:noescape
func VreinterpretqU32S64(r *Uint32X4, v0 *Int64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU32S16 VreinterpretqU32S16
//go:noescape
func VreinterpretqU32S16(r *Uint32X4, v0 *Int16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU64P8 VreinterpretqU64P8
//go:noescape
func VreinterpretqU64P8(r *Uint64X2, v0 *Poly8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU64P128 VreinterpretqU64P128
//go:noescape
func VreinterpretqU64P128(r *Uint64X2, v0 *Poly128)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU64P64 VreinterpretqU64P64
//go:noescape
func VreinterpretqU64P64(r *Uint64X2, v0 *Poly64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU64P16 VreinterpretqU64P16
//go:noescape
func VreinterpretqU64P16(r *Uint64X2, v0 *Poly16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU64U8 VreinterpretqU64U8
//go:noescape
func VreinterpretqU64U8(r *Uint64X2, v0 *Uint8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU64U32 VreinterpretqU64U32
//go:noescape
func VreinterpretqU64U32(r *Uint64X2, v0 *Uint32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU64U16 VreinterpretqU64U16
//go:noescape
func VreinterpretqU64U16(r *Uint64X2, v0 *Uint16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU64S8 VreinterpretqU64S8
//go:noescape
func VreinterpretqU64S8(r *Uint64X2, v0 *Int8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU64F64 VreinterpretqU64F64
//go:noescape
func VreinterpretqU64F64(r *Uint64X2, v0 *Float64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU64F32 VreinterpretqU64F32
//go:noescape
func VreinterpretqU64F32(r *Uint64X2, v0 *Float32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU64S32 VreinterpretqU64S32
//go:noescape
func VreinterpretqU64S32(r *Uint64X2, v0 *Int32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU64S64 VreinterpretqU64S64
//go:noescape
func VreinterpretqU64S64(r *Uint64X2, v0 *Int64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU64S16 VreinterpretqU64S16
//go:noescape
func VreinterpretqU64S16(r *Uint64X2, v0 *Int16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU16P8 VreinterpretqU16P8
//go:noescape
func VreinterpretqU16P8(r *Uint16X8, v0 *Poly8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU16P128 VreinterpretqU16P128
//go:noescape
func VreinterpretqU16P128(r *Uint16X8, v0 *Poly128)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU16P64 VreinterpretqU16P64
//go:noescape
func VreinterpretqU16P64(r *Uint16X8, v0 *Poly64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU16P16 VreinterpretqU16P16
//go:noescape
func VreinterpretqU16P16(r *Uint16X8, v0 *Poly16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU16U8 VreinterpretqU16U8
//go:noescape
func VreinterpretqU16U8(r *Uint16X8, v0 *Uint8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU16U32 VreinterpretqU16U32
//go:noescape
func VreinterpretqU16U32(r *Uint16X8, v0 *Uint32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU16U64 VreinterpretqU16U64
//go:noescape
func VreinterpretqU16U64(r *Uint16X8, v0 *Uint64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU16S8 VreinterpretqU16S8
//go:noescape
func VreinterpretqU16S8(r *Uint16X8, v0 *Int8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU16F64 VreinterpretqU16F64
//go:noescape
func VreinterpretqU16F64(r *Uint16X8, v0 *Float64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU16F32 VreinterpretqU16F32
//go:noescape
func VreinterpretqU16F32(r *Uint16X8, v0 *Float32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU16S32 VreinterpretqU16S32
//go:noescape
func VreinterpretqU16S32(r *Uint16X8, v0 *Int32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU16S64 VreinterpretqU16S64
//go:noescape
func VreinterpretqU16S64(r *Uint16X8, v0 *Int64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqU16S16 VreinterpretqU16S16
//go:noescape
func VreinterpretqU16S16(r *Uint16X8, v0 *Int16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS8P8 VreinterpretqS8P8
//go:noescape
func VreinterpretqS8P8(r *Int8X16, v0 *Poly8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS8P128 VreinterpretqS8P128
//go:noescape
func VreinterpretqS8P128(r *Int8X16, v0 *Poly128)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS8P64 VreinterpretqS8P64
//go:noescape
func VreinterpretqS8P64(r *Int8X16, v0 *Poly64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS8P16 VreinterpretqS8P16
//go:noescape
func VreinterpretqS8P16(r *Int8X16, v0 *Poly16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS8U8 VreinterpretqS8U8
//go:noescape
func VreinterpretqS8U8(r *Int8X16, v0 *Uint8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS8U32 VreinterpretqS8U32
//go:noescape
func VreinterpretqS8U32(r *Int8X16, v0 *Uint32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS8U64 VreinterpretqS8U64
//go:noescape
func VreinterpretqS8U64(r *Int8X16, v0 *Uint64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS8U16 VreinterpretqS8U16
//go:noescape
func VreinterpretqS8U16(r *Int8X16, v0 *Uint16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS8F64 VreinterpretqS8F64
//go:noescape
func VreinterpretqS8F64(r *Int8X16, v0 *Float64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS8F32 VreinterpretqS8F32
//go:noescape
func VreinterpretqS8F32(r *Int8X16, v0 *Float32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS8S32 VreinterpretqS8S32
//go:noescape
func VreinterpretqS8S32(r *Int8X16, v0 *Int32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS8S64 VreinterpretqS8S64
//go:noescape
func VreinterpretqS8S64(r *Int8X16, v0 *Int64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS8S16 VreinterpretqS8S16
//go:noescape
func VreinterpretqS8S16(r *Int8X16, v0 *Int16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF64P8 VreinterpretqF64P8
//go:noescape
func VreinterpretqF64P8(r *Float64X2, v0 *Poly8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF64P128 VreinterpretqF64P128
//go:noescape
func VreinterpretqF64P128(r *Float64X2, v0 *Poly128)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF64P64 VreinterpretqF64P64
//go:noescape
func VreinterpretqF64P64(r *Float64X2, v0 *Poly64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF64P16 VreinterpretqF64P16
//go:noescape
func VreinterpretqF64P16(r *Float64X2, v0 *Poly16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF64U8 VreinterpretqF64U8
//go:noescape
func VreinterpretqF64U8(r *Float64X2, v0 *Uint8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF64U32 VreinterpretqF64U32
//go:noescape
func VreinterpretqF64U32(r *Float64X2, v0 *Uint32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF64U64 VreinterpretqF64U64
//go:noescape
func VreinterpretqF64U64(r *Float64X2, v0 *Uint64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF64U16 VreinterpretqF64U16
//go:noescape
func VreinterpretqF64U16(r *Float64X2, v0 *Uint16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF64S8 VreinterpretqF64S8
//go:noescape
func VreinterpretqF64S8(r *Float64X2, v0 *Int8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF64F32 VreinterpretqF64F32
//go:noescape
func VreinterpretqF64F32(r *Float64X2, v0 *Float32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF64S32 VreinterpretqF64S32
//go:noescape
func VreinterpretqF64S32(r *Float64X2, v0 *Int32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF64S64 VreinterpretqF64S64
//go:noescape
func VreinterpretqF64S64(r *Float64X2, v0 *Int64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF64S16 VreinterpretqF64S16
//go:noescape
func VreinterpretqF64S16(r *Float64X2, v0 *Int16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF32P8 VreinterpretqF32P8
//go:noescape
func VreinterpretqF32P8(r *Float32X4, v0 *Poly8X16)

// vreinterpretq_f32_p128
//
//go:linkname VreinterpretqF32P128 VreinterpretqF32P128
//go:noescape
func VreinterpretqF32P128(r *Float32X4, v0 *Poly128)

// vreinterpretq_f32_p64
//
//go:linkname VreinterpretqF32P64 VreinterpretqF32P64
//go:noescape
func VreinterpretqF32P64(r *Float32X4, v0 *Poly64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF32P16 VreinterpretqF32P16
//go:noescape
func VreinterpretqF32P16(r *Float32X4, v0 *Poly16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF32U8 VreinterpretqF32U8
//go:noescape
func VreinterpretqF32U8(r *Float32X4, v0 *Uint8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF32U32 VreinterpretqF32U32
//go:noescape
func VreinterpretqF32U32(r *Float32X4, v0 *Uint32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF32U64 VreinterpretqF32U64
//go:noescape
func VreinterpretqF32U64(r *Float32X4, v0 *Uint64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF32U16 VreinterpretqF32U16
//go:noescape
func VreinterpretqF32U16(r *Float32X4, v0 *Uint16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF32S8 VreinterpretqF32S8
//go:noescape
func VreinterpretqF32S8(r *Float32X4, v0 *Int8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF32F64 VreinterpretqF32F64
//go:noescape
func VreinterpretqF32F64(r *Float32X4, v0 *Float64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF32S32 VreinterpretqF32S32
//go:noescape
func VreinterpretqF32S32(r *Float32X4, v0 *Int32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF32S64 VreinterpretqF32S64
//go:noescape
func VreinterpretqF32S64(r *Float32X4, v0 *Int64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqF32S16 VreinterpretqF32S16
//go:noescape
func VreinterpretqF32S16(r *Float32X4, v0 *Int16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS32P8 VreinterpretqS32P8
//go:noescape
func VreinterpretqS32P8(r *Int32X4, v0 *Poly8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS32P128 VreinterpretqS32P128
//go:noescape
func VreinterpretqS32P128(r *Int32X4, v0 *Poly128)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS32P64 VreinterpretqS32P64
//go:noescape
func VreinterpretqS32P64(r *Int32X4, v0 *Poly64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS32P16 VreinterpretqS32P16
//go:noescape
func VreinterpretqS32P16(r *Int32X4, v0 *Poly16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS32U8 VreinterpretqS32U8
//go:noescape
func VreinterpretqS32U8(r *Int32X4, v0 *Uint8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS32U32 VreinterpretqS32U32
//go:noescape
func VreinterpretqS32U32(r *Int32X4, v0 *Uint32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS32U64 VreinterpretqS32U64
//go:noescape
func VreinterpretqS32U64(r *Int32X4, v0 *Uint64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS32U16 VreinterpretqS32U16
//go:noescape
func VreinterpretqS32U16(r *Int32X4, v0 *Uint16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS32S8 VreinterpretqS32S8
//go:noescape
func VreinterpretqS32S8(r *Int32X4, v0 *Int8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS32F64 VreinterpretqS32F64
//go:noescape
func VreinterpretqS32F64(r *Int32X4, v0 *Float64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS32F32 VreinterpretqS32F32
//go:noescape
func VreinterpretqS32F32(r *Int32X4, v0 *Float32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS32S64 VreinterpretqS32S64
//go:noescape
func VreinterpretqS32S64(r *Int32X4, v0 *Int64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS32S16 VreinterpretqS32S16
//go:noescape
func VreinterpretqS32S16(r *Int32X4, v0 *Int16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS64P8 VreinterpretqS64P8
//go:noescape
func VreinterpretqS64P8(r *Int64X2, v0 *Poly8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS64P128 VreinterpretqS64P128
//go:noescape
func VreinterpretqS64P128(r *Int64X2, v0 *Poly128)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS64P64 VreinterpretqS64P64
//go:noescape
func VreinterpretqS64P64(r *Int64X2, v0 *Poly64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS64P16 VreinterpretqS64P16
//go:noescape
func VreinterpretqS64P16(r *Int64X2, v0 *Poly16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS64U8 VreinterpretqS64U8
//go:noescape
func VreinterpretqS64U8(r *Int64X2, v0 *Uint8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS64U32 VreinterpretqS64U32
//go:noescape
func VreinterpretqS64U32(r *Int64X2, v0 *Uint32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS64U64 VreinterpretqS64U64
//go:noescape
func VreinterpretqS64U64(r *Int64X2, v0 *Uint64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS64U16 VreinterpretqS64U16
//go:noescape
func VreinterpretqS64U16(r *Int64X2, v0 *Uint16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS64S8 VreinterpretqS64S8
//go:noescape
func VreinterpretqS64S8(r *Int64X2, v0 *Int8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS64F64 VreinterpretqS64F64
//go:noescape
func VreinterpretqS64F64(r *Int64X2, v0 *Float64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS64F32 VreinterpretqS64F32
//go:noescape
func VreinterpretqS64F32(r *Int64X2, v0 *Float32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS64S32 VreinterpretqS64S32
//go:noescape
func VreinterpretqS64S32(r *Int64X2, v0 *Int32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS64S16 VreinterpretqS64S16
//go:noescape
func VreinterpretqS64S16(r *Int64X2, v0 *Int16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS16P8 VreinterpretqS16P8
//go:noescape
func VreinterpretqS16P8(r *Int16X8, v0 *Poly8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS16P128 VreinterpretqS16P128
//go:noescape
func VreinterpretqS16P128(r *Int16X8, v0 *Poly128)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS16P64 VreinterpretqS16P64
//go:noescape
func VreinterpretqS16P64(r *Int16X8, v0 *Poly64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS16P16 VreinterpretqS16P16
//go:noescape
func VreinterpretqS16P16(r *Int16X8, v0 *Poly16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS16U8 VreinterpretqS16U8
//go:noescape
func VreinterpretqS16U8(r *Int16X8, v0 *Uint8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS16U32 VreinterpretqS16U32
//go:noescape
func VreinterpretqS16U32(r *Int16X8, v0 *Uint32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS16U64 VreinterpretqS16U64
//go:noescape
func VreinterpretqS16U64(r *Int16X8, v0 *Uint64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS16U16 VreinterpretqS16U16
//go:noescape
func VreinterpretqS16U16(r *Int16X8, v0 *Uint16X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS16S8 VreinterpretqS16S8
//go:noescape
func VreinterpretqS16S8(r *Int16X8, v0 *Int8X16)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS16F64 VreinterpretqS16F64
//go:noescape
func VreinterpretqS16F64(r *Int16X8, v0 *Float64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS16F32 VreinterpretqS16F32
//go:noescape
func VreinterpretqS16F32(r *Int16X8, v0 *Float32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS16S32 VreinterpretqS16S32
//go:noescape
func VreinterpretqS16S32(r *Int16X8, v0 *Int32X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretqS16S64 VreinterpretqS16S64
//go:noescape
func VreinterpretqS16S64(r *Int16X8, v0 *Int64X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU8P8 VreinterpretU8P8
//go:noescape
func VreinterpretU8P8(r *Uint8X8, v0 *Poly8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU8P64 VreinterpretU8P64
//go:noescape
func VreinterpretU8P64(r *Uint8X8, v0 *Poly64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU8P16 VreinterpretU8P16
//go:noescape
func VreinterpretU8P16(r *Uint8X8, v0 *Poly16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU8U32 VreinterpretU8U32
//go:noescape
func VreinterpretU8U32(r *Uint8X8, v0 *Uint32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU8U64 VreinterpretU8U64
//go:noescape
func VreinterpretU8U64(r *Uint8X8, v0 *Uint64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU8U16 VreinterpretU8U16
//go:noescape
func VreinterpretU8U16(r *Uint8X8, v0 *Uint16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU8S8 VreinterpretU8S8
//go:noescape
func VreinterpretU8S8(r *Uint8X8, v0 *Int8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU8F64 VreinterpretU8F64
//go:noescape
func VreinterpretU8F64(r *Uint8X8, v0 *Float64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU8F32 VreinterpretU8F32
//go:noescape
func VreinterpretU8F32(r *Uint8X8, v0 *Float32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU8S32 VreinterpretU8S32
//go:noescape
func VreinterpretU8S32(r *Uint8X8, v0 *Int32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU8S64 VreinterpretU8S64
//go:noescape
func VreinterpretU8S64(r *Uint8X8, v0 *Int64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU8S16 VreinterpretU8S16
//go:noescape
func VreinterpretU8S16(r *Uint8X8, v0 *Int16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU32P8 VreinterpretU32P8
//go:noescape
func VreinterpretU32P8(r *Uint32X2, v0 *Poly8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU32P64 VreinterpretU32P64
//go:noescape
func VreinterpretU32P64(r *Uint32X2, v0 *Poly64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU32P16 VreinterpretU32P16
//go:noescape
func VreinterpretU32P16(r *Uint32X2, v0 *Poly16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU32U8 VreinterpretU32U8
//go:noescape
func VreinterpretU32U8(r *Uint32X2, v0 *Uint8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU32U64 VreinterpretU32U64
//go:noescape
func VreinterpretU32U64(r *Uint32X2, v0 *Uint64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU32U16 VreinterpretU32U16
//go:noescape
func VreinterpretU32U16(r *Uint32X2, v0 *Uint16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU32S8 VreinterpretU32S8
//go:noescape
func VreinterpretU32S8(r *Uint32X2, v0 *Int8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU32F64 VreinterpretU32F64
//go:noescape
func VreinterpretU32F64(r *Uint32X2, v0 *Float64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU32F32 VreinterpretU32F32
//go:noescape
func VreinterpretU32F32(r *Uint32X2, v0 *Float32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU32S32 VreinterpretU32S32
//go:noescape
func VreinterpretU32S32(r *Uint32X2, v0 *Int32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU32S64 VreinterpretU32S64
//go:noescape
func VreinterpretU32S64(r *Uint32X2, v0 *Int64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU32S16 VreinterpretU32S16
//go:noescape
func VreinterpretU32S16(r *Uint32X2, v0 *Int16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU64P8 VreinterpretU64P8
//go:noescape
func VreinterpretU64P8(r *Uint64X1, v0 *Poly8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU64P64 VreinterpretU64P64
//go:noescape
func VreinterpretU64P64(r *Uint64X1, v0 *Poly64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU64P16 VreinterpretU64P16
//go:noescape
func VreinterpretU64P16(r *Uint64X1, v0 *Poly16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU64U8 VreinterpretU64U8
//go:noescape
func VreinterpretU64U8(r *Uint64X1, v0 *Uint8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU64U32 VreinterpretU64U32
//go:noescape
func VreinterpretU64U32(r *Uint64X1, v0 *Uint32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU64U16 VreinterpretU64U16
//go:noescape
func VreinterpretU64U16(r *Uint64X1, v0 *Uint16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU64S8 VreinterpretU64S8
//go:noescape
func VreinterpretU64S8(r *Uint64X1, v0 *Int8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU64F64 VreinterpretU64F64
//go:noescape
func VreinterpretU64F64(r *Uint64X1, v0 *Float64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU64F32 VreinterpretU64F32
//go:noescape
func VreinterpretU64F32(r *Uint64X1, v0 *Float32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU64S32 VreinterpretU64S32
//go:noescape
func VreinterpretU64S32(r *Uint64X1, v0 *Int32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU64S64 VreinterpretU64S64
//go:noescape
func VreinterpretU64S64(r *Uint64X1, v0 *Int64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU64S16 VreinterpretU64S16
//go:noescape
func VreinterpretU64S16(r *Uint64X1, v0 *Int16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU16P8 VreinterpretU16P8
//go:noescape
func VreinterpretU16P8(r *Uint16X4, v0 *Poly8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU16P64 VreinterpretU16P64
//go:noescape
func VreinterpretU16P64(r *Uint16X4, v0 *Poly64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU16P16 VreinterpretU16P16
//go:noescape
func VreinterpretU16P16(r *Uint16X4, v0 *Poly16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU16U8 VreinterpretU16U8
//go:noescape
func VreinterpretU16U8(r *Uint16X4, v0 *Uint8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU16U32 VreinterpretU16U32
//go:noescape
func VreinterpretU16U32(r *Uint16X4, v0 *Uint32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU16U64 VreinterpretU16U64
//go:noescape
func VreinterpretU16U64(r *Uint16X4, v0 *Uint64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU16S8 VreinterpretU16S8
//go:noescape
func VreinterpretU16S8(r *Uint16X4, v0 *Int8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU16F64 VreinterpretU16F64
//go:noescape
func VreinterpretU16F64(r *Uint16X4, v0 *Float64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU16F32 VreinterpretU16F32
//go:noescape
func VreinterpretU16F32(r *Uint16X4, v0 *Float32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU16S32 VreinterpretU16S32
//go:noescape
func VreinterpretU16S32(r *Uint16X4, v0 *Int32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU16S64 VreinterpretU16S64
//go:noescape
func VreinterpretU16S64(r *Uint16X4, v0 *Int64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretU16S16 VreinterpretU16S16
//go:noescape
func VreinterpretU16S16(r *Uint16X4, v0 *Int16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS8P8 VreinterpretS8P8
//go:noescape
func VreinterpretS8P8(r *Int8X8, v0 *Poly8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS8P64 VreinterpretS8P64
//go:noescape
func VreinterpretS8P64(r *Int8X8, v0 *Poly64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS8P16 VreinterpretS8P16
//go:noescape
func VreinterpretS8P16(r *Int8X8, v0 *Poly16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS8U8 VreinterpretS8U8
//go:noescape
func VreinterpretS8U8(r *Int8X8, v0 *Uint8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS8U32 VreinterpretS8U32
//go:noescape
func VreinterpretS8U32(r *Int8X8, v0 *Uint32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS8U64 VreinterpretS8U64
//go:noescape
func VreinterpretS8U64(r *Int8X8, v0 *Uint64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS8U16 VreinterpretS8U16
//go:noescape
func VreinterpretS8U16(r *Int8X8, v0 *Uint16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS8F64 VreinterpretS8F64
//go:noescape
func VreinterpretS8F64(r *Int8X8, v0 *Float64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS8F32 VreinterpretS8F32
//go:noescape
func VreinterpretS8F32(r *Int8X8, v0 *Float32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS8S32 VreinterpretS8S32
//go:noescape
func VreinterpretS8S32(r *Int8X8, v0 *Int32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS8S64 VreinterpretS8S64
//go:noescape
func VreinterpretS8S64(r *Int8X8, v0 *Int64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS8S16 VreinterpretS8S16
//go:noescape
func VreinterpretS8S16(r *Int8X8, v0 *Int16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretF64P8 VreinterpretF64P8
//go:noescape
func VreinterpretF64P8(r *Float64X1, v0 *Poly8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretF64P64 VreinterpretF64P64
//go:noescape
func VreinterpretF64P64(r *Float64X1, v0 *Poly64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretF64P16 VreinterpretF64P16
//go:noescape
func VreinterpretF64P16(r *Float64X1, v0 *Poly16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretF64U8 VreinterpretF64U8
//go:noescape
func VreinterpretF64U8(r *Float64X1, v0 *Uint8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretF64U32 VreinterpretF64U32
//go:noescape
func VreinterpretF64U32(r *Float64X1, v0 *Uint32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretF64U64 VreinterpretF64U64
//go:noescape
func VreinterpretF64U64(r *Float64X1, v0 *Uint64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretF64U16 VreinterpretF64U16
//go:noescape
func VreinterpretF64U16(r *Float64X1, v0 *Uint16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretF64S8 VreinterpretF64S8
//go:noescape
func VreinterpretF64S8(r *Float64X1, v0 *Int8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretF64F32 VreinterpretF64F32
//go:noescape
func VreinterpretF64F32(r *Float64X1, v0 *Float32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretF64S32 VreinterpretF64S32
//go:noescape
func VreinterpretF64S32(r *Float64X1, v0 *Int32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretF64S64 VreinterpretF64S64
//go:noescape
func VreinterpretF64S64(r *Float64X1, v0 *Int64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretF64S16 VreinterpretF64S16
//go:noescape
func VreinterpretF64S16(r *Float64X1, v0 *Int16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretF32P8 VreinterpretF32P8
//go:noescape
func VreinterpretF32P8(r *Float32X2, v0 *Poly8X8)

// vreinterpret_f32_p64
//
//go:linkname VreinterpretF32P64 VreinterpretF32P64
//go:noescape
func VreinterpretF32P64(r *Float32X2, v0 *Poly64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretF32P16 VreinterpretF32P16
//go:noescape
func VreinterpretF32P16(r *Float32X2, v0 *Poly16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretF32U8 VreinterpretF32U8
//go:noescape
func VreinterpretF32U8(r *Float32X2, v0 *Uint8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretF32U32 VreinterpretF32U32
//go:noescape
func VreinterpretF32U32(r *Float32X2, v0 *Uint32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretF32U64 VreinterpretF32U64
//go:noescape
func VreinterpretF32U64(r *Float32X2, v0 *Uint64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretF32U16 VreinterpretF32U16
//go:noescape
func VreinterpretF32U16(r *Float32X2, v0 *Uint16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretF32S8 VreinterpretF32S8
//go:noescape
func VreinterpretF32S8(r *Float32X2, v0 *Int8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretF32F64 VreinterpretF32F64
//go:noescape
func VreinterpretF32F64(r *Float32X2, v0 *Float64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretF32S32 VreinterpretF32S32
//go:noescape
func VreinterpretF32S32(r *Float32X2, v0 *Int32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretF32S64 VreinterpretF32S64
//go:noescape
func VreinterpretF32S64(r *Float32X2, v0 *Int64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretF32S16 VreinterpretF32S16
//go:noescape
func VreinterpretF32S16(r *Float32X2, v0 *Int16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS32P8 VreinterpretS32P8
//go:noescape
func VreinterpretS32P8(r *Int32X2, v0 *Poly8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS32P64 VreinterpretS32P64
//go:noescape
func VreinterpretS32P64(r *Int32X2, v0 *Poly64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS32P16 VreinterpretS32P16
//go:noescape
func VreinterpretS32P16(r *Int32X2, v0 *Poly16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS32U8 VreinterpretS32U8
//go:noescape
func VreinterpretS32U8(r *Int32X2, v0 *Uint8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS32U32 VreinterpretS32U32
//go:noescape
func VreinterpretS32U32(r *Int32X2, v0 *Uint32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS32U64 VreinterpretS32U64
//go:noescape
func VreinterpretS32U64(r *Int32X2, v0 *Uint64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS32U16 VreinterpretS32U16
//go:noescape
func VreinterpretS32U16(r *Int32X2, v0 *Uint16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS32S8 VreinterpretS32S8
//go:noescape
func VreinterpretS32S8(r *Int32X2, v0 *Int8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS32F64 VreinterpretS32F64
//go:noescape
func VreinterpretS32F64(r *Int32X2, v0 *Float64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS32F32 VreinterpretS32F32
//go:noescape
func VreinterpretS32F32(r *Int32X2, v0 *Float32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS32S64 VreinterpretS32S64
//go:noescape
func VreinterpretS32S64(r *Int32X2, v0 *Int64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS32S16 VreinterpretS32S16
//go:noescape
func VreinterpretS32S16(r *Int32X2, v0 *Int16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS64P8 VreinterpretS64P8
//go:noescape
func VreinterpretS64P8(r *Int64X1, v0 *Poly8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS64P64 VreinterpretS64P64
//go:noescape
func VreinterpretS64P64(r *Int64X1, v0 *Poly64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS64P16 VreinterpretS64P16
//go:noescape
func VreinterpretS64P16(r *Int64X1, v0 *Poly16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS64U8 VreinterpretS64U8
//go:noescape
func VreinterpretS64U8(r *Int64X1, v0 *Uint8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS64U32 VreinterpretS64U32
//go:noescape
func VreinterpretS64U32(r *Int64X1, v0 *Uint32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS64U64 VreinterpretS64U64
//go:noescape
func VreinterpretS64U64(r *Int64X1, v0 *Uint64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS64U16 VreinterpretS64U16
//go:noescape
func VreinterpretS64U16(r *Int64X1, v0 *Uint16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS64S8 VreinterpretS64S8
//go:noescape
func VreinterpretS64S8(r *Int64X1, v0 *Int8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS64F64 VreinterpretS64F64
//go:noescape
func VreinterpretS64F64(r *Int64X1, v0 *Float64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS64F32 VreinterpretS64F32
//go:noescape
func VreinterpretS64F32(r *Int64X1, v0 *Float32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS64S32 VreinterpretS64S32
//go:noescape
func VreinterpretS64S32(r *Int64X1, v0 *Int32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS64S16 VreinterpretS64S16
//go:noescape
func VreinterpretS64S16(r *Int64X1, v0 *Int16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS16P8 VreinterpretS16P8
//go:noescape
func VreinterpretS16P8(r *Int16X4, v0 *Poly8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS16P64 VreinterpretS16P64
//go:noescape
func VreinterpretS16P64(r *Int16X4, v0 *Poly64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS16P16 VreinterpretS16P16
//go:noescape
func VreinterpretS16P16(r *Int16X4, v0 *Poly16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS16U8 VreinterpretS16U8
//go:noescape
func VreinterpretS16U8(r *Int16X4, v0 *Uint8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS16U32 VreinterpretS16U32
//go:noescape
func VreinterpretS16U32(r *Int16X4, v0 *Uint32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS16U64 VreinterpretS16U64
//go:noescape
func VreinterpretS16U64(r *Int16X4, v0 *Uint64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS16U16 VreinterpretS16U16
//go:noescape
func VreinterpretS16U16(r *Int16X4, v0 *Uint16X4)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS16S8 VreinterpretS16S8
//go:noescape
func VreinterpretS16S8(r *Int16X4, v0 *Int8X8)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS16F64 VreinterpretS16F64
//go:noescape
func VreinterpretS16F64(r *Int16X4, v0 *Float64X1)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS16F32 VreinterpretS16F32
//go:noescape
func VreinterpretS16F32(r *Int16X4, v0 *Float32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS16S32 VreinterpretS16S32
//go:noescape
func VreinterpretS16S32(r *Int16X4, v0 *Int32X2)

// Vector reinterpret cast operation
//
//go:linkname VreinterpretS16S64 VreinterpretS16S64
//go:noescape
func VreinterpretS16S64(r *Int16X4, v0 *Int64X1)

// Floating-point Round to Integral, toward Zero (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndqF64 VrndqF64
//go:noescape
func VrndqF64(r *Float64X2, v0 *Float64X2)

// Floating-point Round to Integral, toward Zero (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndF64 VrndF64
//go:noescape
func VrndF64(r *Float64X1, v0 *Float64X1)

// Floating-point Round to Integral, to nearest with ties to Away (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round to Nearest with Ties to Away rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndaqF64 VrndaqF64
//go:noescape
func VrndaqF64(r *Float64X2, v0 *Float64X2)

// Floating-point Round to Integral, to nearest with ties to Away (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round to Nearest with Ties to Away rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndaF64 VrndaF64
//go:noescape
func VrndaF64(r *Float64X1, v0 *Float64X1)

// Floating-point Round to Integral, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndiqF64 VrndiqF64
//go:noescape
func VrndiqF64(r *Float64X2, v0 *Float64X2)

// Floating-point Round to Integral, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndiF64 VrndiF64
//go:noescape
func VrndiF64(r *Float64X1, v0 *Float64X1)

// Floating-point Round to Integral, toward Minus infinity (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndmqF64 VrndmqF64
//go:noescape
func VrndmqF64(r *Float64X2, v0 *Float64X2)

// Floating-point Round to Integral, toward Minus infinity (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndmF64 VrndmF64
//go:noescape
func VrndmF64(r *Float64X1, v0 *Float64X1)

// Floating-point Round to Integral, to nearest with ties to even (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndnqF64 VrndnqF64
//go:noescape
func VrndnqF64(r *Float64X2, v0 *Float64X2)

// Floating-point Round to Integral, to nearest with ties to even (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndnF64 VrndnF64
//go:noescape
func VrndnF64(r *Float64X1, v0 *Float64X1)

// Floating-point Round to Integral, toward Plus infinity (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndpqF64 VrndpqF64
//go:noescape
func VrndpqF64(r *Float64X2, v0 *Float64X2)

// Floating-point Round to Integral, toward Plus infinity (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndpF64 VrndpF64
//go:noescape
func VrndpF64(r *Float64X1, v0 *Float64X1)

// Floating-point Round to Integral exact, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndxqF64 VrndxqF64
//go:noescape
func VrndxqF64(r *Float64X2, v0 *Float64X2)

// Floating-point Round to Integral exact, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname VrndxF64 VrndxF64
//go:noescape
func VrndxF64(r *Float64X1, v0 *Float64X1)

// Floating-point Round to 32-bit Integer, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values that fit into a 32-bit integer size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname Vrnd32XqF32 Vrnd32XqF32
//go:noescape
func Vrnd32XqF32(r *Float32X4, v0 *Float32X4)

// Floating-point Round to 32-bit Integer, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values that fit into a 32-bit integer size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname Vrnd32XF32 Vrnd32XF32
//go:noescape
func Vrnd32XF32(r *Float32X2, v0 *Float32X2)

// Floating-point Round to 32-bit Integer toward Zero (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values that fit into a 32-bit integer size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname Vrnd32ZqF32 Vrnd32ZqF32
//go:noescape
func Vrnd32ZqF32(r *Float32X4, v0 *Float32X4)

// Floating-point Round to 32-bit Integer toward Zero (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values that fit into a 32-bit integer size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname Vrnd32ZF32 Vrnd32ZF32
//go:noescape
func Vrnd32ZF32(r *Float32X2, v0 *Float32X2)

// Floating-point Round to 64-bit Integer, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values that fit into a 64-bit integer size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname Vrnd64XqF32 Vrnd64XqF32
//go:noescape
func Vrnd64XqF32(r *Float32X4, v0 *Float32X4)

// Floating-point Round to 64-bit Integer, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values that fit into a 64-bit integer size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname Vrnd64XF32 Vrnd64XF32
//go:noescape
func Vrnd64XF32(r *Float32X2, v0 *Float32X2)

// Floating-point Round to 64-bit Integer toward Zero (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values that fit into a 64-bit integer size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname Vrnd64ZqF32 Vrnd64ZqF32
//go:noescape
func Vrnd64ZqF32(r *Float32X4, v0 *Float32X4)

// Floating-point Round to 64-bit Integer toward Zero (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values that fit into a 64-bit integer size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname Vrnd64ZF32 Vrnd64ZF32
//go:noescape
func Vrnd64ZF32(r *Float32X2, v0 *Float32X2)

// Floating-point Maximum Number (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, writes the larger of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmaxnmqF64 VmaxnmqF64
//go:noescape
func VmaxnmqF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Floating-point Maximum Number (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, writes the larger of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmaxnmF64 VmaxnmF64
//go:noescape
func VmaxnmF64(r *Float64X1, v0 *Float64X1, v1 *Float64X1)

// Floating-point Minimum Number (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, writes the smaller of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VminnmqF64 VminnmqF64
//go:noescape
func VminnmqF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Floating-point Minimum Number (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, writes the smaller of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VminnmF64 VminnmF64
//go:noescape
func VminnmF64(r *Float64X1, v0 *Float64X1, v1 *Float64X1)

// Floating-point Complex Add.
//
//go:linkname VcaddRot270F32 VcaddRot270F32
//go:noescape
func VcaddRot270F32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Floating-point Complex Add.
//
//go:linkname VcaddRot90F32 VcaddRot90F32
//go:noescape
func VcaddRot90F32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Floating-point Complex Add.
//
//go:linkname VcaddqRot270F32 VcaddqRot270F32
//go:noescape
func VcaddqRot270F32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Floating-point Complex Add.
//
//go:linkname VcaddqRot90F32 VcaddqRot90F32
//go:noescape
func VcaddqRot90F32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Floating-point Complex Add.
//
//go:linkname VcaddqRot270F64 VcaddqRot270F64
//go:noescape
func VcaddqRot270F64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Floating-point Complex Add.
//
//go:linkname VcaddqRot90F64 VcaddqRot90F64
//go:noescape
func VcaddqRot90F64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Dot Product unsigned arithmetic (vector). This instruction performs the dot product of the four unsigned 8-bit elements in each 32-bit element of the first source register with the four unsigned 8-bit elements of the corresponding 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register.
//
//go:linkname VdotqU32 VdotqU32
//go:noescape
func VdotqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint8X16, v2 *Uint8X16)

// Dot Product signed arithmetic (vector). This instruction performs the dot product of the four signed 8-bit elements in each 32-bit element of the first source register with the four signed 8-bit elements of the corresponding 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register.
//
//go:linkname VdotqS32 VdotqS32
//go:noescape
func VdotqS32(r *Int32X4, v0 *Int32X4, v1 *Int8X16, v2 *Int8X16)

// Dot Product unsigned arithmetic (vector). This instruction performs the dot product of the four unsigned 8-bit elements in each 32-bit element of the first source register with the four unsigned 8-bit elements of the corresponding 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register.
//
//go:linkname VdotU32 VdotU32
//go:noescape
func VdotU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint8X8, v2 *Uint8X8)

// Dot Product signed arithmetic (vector). This instruction performs the dot product of the four signed 8-bit elements in each 32-bit element of the first source register with the four signed 8-bit elements of the corresponding 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register.
//
//go:linkname VdotS32 VdotS32
//go:noescape
func VdotS32(r *Int32X2, v0 *Int32X2, v1 *Int8X8, v2 *Int8X8)

// Floating-point fused Multiply-Add to accumulator (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, adds the product to the corresponding vector element of the destination SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VfmaqF32 VfmaqF32
//go:noescape
func VfmaqF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4, v2 *Float32X4)

// Floating-point fused Multiply-Add to accumulator (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, adds the product to the corresponding vector element of the destination SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VfmaF32 VfmaF32
//go:noescape
func VfmaF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2, v2 *Float32X2)

// Floating-point fused Multiply-Add to accumulator (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, adds the product to the corresponding vector element of the destination SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VfmaqNF32 VfmaqNF32
//go:noescape
func VfmaqNF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4, v2 *Float32)

// Floating-point fused Multiply-Add to accumulator (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, adds the product to the corresponding vector element of the destination SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VfmaNF32 VfmaNF32
//go:noescape
func VfmaNF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2, v2 *Float32)

// Floating-point fused Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, negates the product, adds the result to the corresponding vector element of the destination SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VfmsqF32 VfmsqF32
//go:noescape
func VfmsqF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4, v2 *Float32X4)

// Floating-point fused Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, negates the product, adds the result to the corresponding vector element of the destination SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VfmsF32 VfmsF32
//go:noescape
func VfmsF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2, v2 *Float32X2)

// Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (vector). This instruction multiplies the vector elements of the first source SIMD&FP register with the corresponding vector elements of the second source SIMD&FP register without saturating the multiply results, doubles the results, and accumulates the most significant half of the final results with the vector elements of the destination SIMD&FP register. The results are rounded.
//
//go:linkname VqrdmlahqS32 VqrdmlahqS32
//go:noescape
func VqrdmlahqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4, v2 *Int32X4)

// Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (vector). This instruction multiplies the vector elements of the first source SIMD&FP register with the corresponding vector elements of the second source SIMD&FP register without saturating the multiply results, doubles the results, and accumulates the most significant half of the final results with the vector elements of the destination SIMD&FP register. The results are rounded.
//
//go:linkname VqrdmlahqS16 VqrdmlahqS16
//go:noescape
func VqrdmlahqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8, v2 *Int16X8)

// Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (vector). This instruction multiplies the vector elements of the first source SIMD&FP register with the corresponding vector elements of the second source SIMD&FP register without saturating the multiply results, doubles the results, and accumulates the most significant half of the final results with the vector elements of the destination SIMD&FP register. The results are rounded.
//
//go:linkname VqrdmlahS32 VqrdmlahS32
//go:noescape
func VqrdmlahS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2, v2 *Int32X2)

// Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (vector). This instruction multiplies the vector elements of the first source SIMD&FP register with the corresponding vector elements of the second source SIMD&FP register without saturating the multiply results, doubles the results, and accumulates the most significant half of the final results with the vector elements of the destination SIMD&FP register. The results are rounded.
//
//go:linkname VqrdmlahS16 VqrdmlahS16
//go:noescape
func VqrdmlahS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4, v2 *Int16X4)

// Signed Saturating Rounding Doubling Multiply Subtract returning High Half (vector). This instruction multiplies the vector elements of the first source SIMD&FP register with the corresponding vector elements of the second source SIMD&FP register without saturating the multiply results, doubles the results, and subtracts the most significant half of the final results from the vector elements of the destination SIMD&FP register. The results are rounded.
//
//go:linkname VqrdmlshqS32 VqrdmlshqS32
//go:noescape
func VqrdmlshqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4, v2 *Int32X4)

// Signed Saturating Rounding Doubling Multiply Subtract returning High Half (vector). This instruction multiplies the vector elements of the first source SIMD&FP register with the corresponding vector elements of the second source SIMD&FP register without saturating the multiply results, doubles the results, and subtracts the most significant half of the final results from the vector elements of the destination SIMD&FP register. The results are rounded.
//
//go:linkname VqrdmlshqS16 VqrdmlshqS16
//go:noescape
func VqrdmlshqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8, v2 *Int16X8)

// Signed Saturating Rounding Doubling Multiply Subtract returning High Half (vector). This instruction multiplies the vector elements of the first source SIMD&FP register with the corresponding vector elements of the second source SIMD&FP register without saturating the multiply results, doubles the results, and subtracts the most significant half of the final results from the vector elements of the destination SIMD&FP register. The results are rounded.
//
//go:linkname VqrdmlshS32 VqrdmlshS32
//go:noescape
func VqrdmlshS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2, v2 *Int32X2)

// Signed Saturating Rounding Doubling Multiply Subtract returning High Half (vector). This instruction multiplies the vector elements of the first source SIMD&FP register with the corresponding vector elements of the second source SIMD&FP register without saturating the multiply results, doubles the results, and subtracts the most significant half of the final results from the vector elements of the destination SIMD&FP register. The results are rounded.
//
//go:linkname VqrdmlshS16 VqrdmlshS16
//go:noescape
func VqrdmlshS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4, v2 *Int16X4)

// Floating-point Absolute Difference (vector). This instruction subtracts the floating-point values in the elements of the second source SIMD&FP register, from the corresponding floating-point values in the elements of the first source SIMD&FP register, places the absolute value of each result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabdqF64 VabdqF64
//go:noescape
func VabdqF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Floating-point Absolute Difference (vector). This instruction subtracts the floating-point values in the elements of the second source SIMD&FP register, from the corresponding floating-point values in the elements of the first source SIMD&FP register, places the absolute value of each result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabdF64 VabdF64
//go:noescape
func VabdF64(r *Float64X1, v0 *Float64X1, v1 *Float64X1)

// Floating-point Absolute Difference (vector). This instruction subtracts the floating-point values in the elements of the second source SIMD&FP register, from the corresponding floating-point values in the elements of the first source SIMD&FP register, places the absolute value of each result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabddF64 VabddF64
//go:noescape
func VabddF64(r *Float64, v0 *Float64, v1 *Float64)

// Floating-point Absolute Difference (vector). This instruction subtracts the floating-point values in the elements of the second source SIMD&FP register, from the corresponding floating-point values in the elements of the first source SIMD&FP register, places the absolute value of each result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabdsF32 VabdsF32
//go:noescape
func VabdsF32(r *Float32, v0 *Float32, v1 *Float32)

// Floating-point Absolute value (vector). This instruction calculates the absolute value of each vector element in the source SIMD&FP register, writes the result to a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabsqF64 VabsqF64
//go:noescape
func VabsqF64(r *Float64X2, v0 *Float64X2)

// Absolute value (vector). This instruction calculates the absolute value of each vector element in the source SIMD&FP register, puts the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabsqS64 VabsqS64
//go:noescape
func VabsqS64(r *Int64X2, v0 *Int64X2)

// Floating-point Absolute value (vector). This instruction calculates the absolute value of each vector element in the source SIMD&FP register, writes the result to a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabsF64 VabsF64
//go:noescape
func VabsF64(r *Float64X1, v0 *Float64X1)

// Absolute value (vector). This instruction calculates the absolute value of each vector element in the source SIMD&FP register, puts the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabsS64 VabsS64
//go:noescape
func VabsS64(r *Int64X1, v0 *Int64X1)

// Absolute value (vector). This instruction calculates the absolute value of each vector element in the source SIMD&FP register, puts the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VabsdS64 VabsdS64
//go:noescape
func VabsdS64(r *Int64, v0 *Int64)

// Floating-point Add (vector). This instruction adds corresponding vector elements in the two source SIMD&FP registers, writes the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VaddqF64 VaddqF64
//go:noescape
func VaddqF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Floating-point Add (vector). This instruction adds corresponding vector elements in the two source SIMD&FP registers, writes the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VaddF64 VaddF64
//go:noescape
func VaddF64(r *Float64X1, v0 *Float64X1, v1 *Float64X1)

// Add (vector). This instruction adds corresponding elements in the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VadddU64 VadddU64
//go:noescape
func VadddU64(r *Uint64, v0 *Uint64, v1 *Uint64)

// Add (vector). This instruction adds corresponding elements in the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VadddS64 VadddS64
//go:noescape
func VadddS64(r *Int64, v0 *Int64, v1 *Int64)

// Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register.
//
//go:linkname VaddqP128 VaddqP128
//go:noescape
func VaddqP128(r *Poly128, v0 *Poly128, v1 *Poly128)

// Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VaddhnHighU32 VaddhnHighU32
//go:noescape
func VaddhnHighU32(r *Uint16X8, v0 *Uint16X4, v1 *Uint32X4, v2 *Uint32X4)

// Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VaddhnHighU64 VaddhnHighU64
//go:noescape
func VaddhnHighU64(r *Uint32X4, v0 *Uint32X2, v1 *Uint64X2, v2 *Uint64X2)

// Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VaddhnHighU16 VaddhnHighU16
//go:noescape
func VaddhnHighU16(r *Uint8X16, v0 *Uint8X8, v1 *Uint16X8, v2 *Uint16X8)

// Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VaddhnHighS32 VaddhnHighS32
//go:noescape
func VaddhnHighS32(r *Int16X8, v0 *Int16X4, v1 *Int32X4, v2 *Int32X4)

// Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VaddhnHighS64 VaddhnHighS64
//go:noescape
func VaddhnHighS64(r *Int32X4, v0 *Int32X2, v1 *Int64X2, v2 *Int64X2)

// Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VaddhnHighS16 VaddhnHighS16
//go:noescape
func VaddhnHighS16(r *Int8X16, v0 *Int8X8, v1 *Int16X8, v2 *Int16X8)

// Unsigned sum Long across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register. The destination scalar is twice as long as the source vector elements. All the values in this instruction are unsigned integer values.
//
//go:linkname VaddlvqU8 VaddlvqU8
//go:noescape
func VaddlvqU8(r *Uint16, v0 *Uint8X16)

// Unsigned sum Long across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register. The destination scalar is twice as long as the source vector elements. All the values in this instruction are unsigned integer values.
//
//go:linkname VaddlvqU32 VaddlvqU32
//go:noescape
func VaddlvqU32(r *Uint64, v0 *Uint32X4)

// Unsigned sum Long across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register. The destination scalar is twice as long as the source vector elements. All the values in this instruction are unsigned integer values.
//
//go:linkname VaddlvqU16 VaddlvqU16
//go:noescape
func VaddlvqU16(r *Uint32, v0 *Uint16X8)

// Signed Add Long across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register. The destination scalar is twice as long as the source vector elements. All the values in this instruction are signed integer values.
//
//go:linkname VaddlvqS8 VaddlvqS8
//go:noescape
func VaddlvqS8(r *Int16, v0 *Int8X16)

// Signed Add Long across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register. The destination scalar is twice as long as the source vector elements. All the values in this instruction are signed integer values.
//
//go:linkname VaddlvqS32 VaddlvqS32
//go:noescape
func VaddlvqS32(r *Int64, v0 *Int32X4)

// Signed Add Long across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register. The destination scalar is twice as long as the source vector elements. All the values in this instruction are signed integer values.
//
//go:linkname VaddlvqS16 VaddlvqS16
//go:noescape
func VaddlvqS16(r *Int32, v0 *Int16X8)

// Unsigned sum Long across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register. The destination scalar is twice as long as the source vector elements. All the values in this instruction are unsigned integer values.
//
//go:linkname VaddlvU8 VaddlvU8
//go:noescape
func VaddlvU8(r *Uint16, v0 *Uint8X8)

// Unsigned Add Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VaddlvU32 VaddlvU32
//go:noescape
func VaddlvU32(r *Uint64, v0 *Uint32X2)

// Unsigned sum Long across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register. The destination scalar is twice as long as the source vector elements. All the values in this instruction are unsigned integer values.
//
//go:linkname VaddlvU16 VaddlvU16
//go:noescape
func VaddlvU16(r *Uint32, v0 *Uint16X4)

// Signed Add Long across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register. The destination scalar is twice as long as the source vector elements. All the values in this instruction are signed integer values.
//
//go:linkname VaddlvS8 VaddlvS8
//go:noescape
func VaddlvS8(r *Int16, v0 *Int8X8)

// Signed Add Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VaddlvS32 VaddlvS32
//go:noescape
func VaddlvS32(r *Int64, v0 *Int32X2)

// Signed Add Long across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register. The destination scalar is twice as long as the source vector elements. All the values in this instruction are signed integer values.
//
//go:linkname VaddlvS16 VaddlvS16
//go:noescape
func VaddlvS16(r *Int32, v0 *Int16X4)

// Add across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register.
//
//go:linkname VaddvqU8 VaddvqU8
//go:noescape
func VaddvqU8(r *Uint8, v0 *Uint8X16)

// Add across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register.
//
//go:linkname VaddvqU32 VaddvqU32
//go:noescape
func VaddvqU32(r *Uint32, v0 *Uint32X4)

// Add across vector
//
//go:linkname VaddvqU64 VaddvqU64
//go:noescape
func VaddvqU64(r *Uint64, v0 *Uint64X2)

// Add across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register.
//
//go:linkname VaddvqU16 VaddvqU16
//go:noescape
func VaddvqU16(r *Uint16, v0 *Uint16X8)

// Add across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register.
//
//go:linkname VaddvqS8 VaddvqS8
//go:noescape
func VaddvqS8(r *Int8, v0 *Int8X16)

// Floating-point add across vector
//
//go:linkname VaddvqF64 VaddvqF64
//go:noescape
func VaddvqF64(r *Float64, v0 *Float64X2)

// Floating-point add across vector
//
//go:linkname VaddvqF32 VaddvqF32
//go:noescape
func VaddvqF32(r *Float32, v0 *Float32X4)

// Add across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register.
//
//go:linkname VaddvqS32 VaddvqS32
//go:noescape
func VaddvqS32(r *Int32, v0 *Int32X4)

// Add across vector
//
//go:linkname VaddvqS64 VaddvqS64
//go:noescape
func VaddvqS64(r *Int64, v0 *Int64X2)

// Add across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register.
//
//go:linkname VaddvqS16 VaddvqS16
//go:noescape
func VaddvqS16(r *Int16, v0 *Int16X8)

// Add across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register.
//
//go:linkname VaddvU8 VaddvU8
//go:noescape
func VaddvU8(r *Uint8, v0 *Uint8X8)

// Add across vector
//
//go:linkname VaddvU32 VaddvU32
//go:noescape
func VaddvU32(r *Uint32, v0 *Uint32X2)

// Add across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register.
//
//go:linkname VaddvU16 VaddvU16
//go:noescape
func VaddvU16(r *Uint16, v0 *Uint16X4)

// Add across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register.
//
//go:linkname VaddvS8 VaddvS8
//go:noescape
func VaddvS8(r *Int8, v0 *Int8X8)

// Floating-point add across vector
//
//go:linkname VaddvF32 VaddvF32
//go:noescape
func VaddvF32(r *Float32, v0 *Float32X2)

// Add across vector
//
//go:linkname VaddvS32 VaddvS32
//go:noescape
func VaddvS32(r *Int32, v0 *Int32X2)

// Add across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register.
//
//go:linkname VaddvS16 VaddvS16
//go:noescape
func VaddvS16(r *Int16, v0 *Int16X4)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslP64 VbslP64
//go:noescape
func VbslP64(r *Poly64X1, v0 *Uint64X1, v1 *Poly64X1, v2 *Poly64X1)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslqP64 VbslqP64
//go:noescape
func VbslqP64(r *Poly64X2, v0 *Uint64X2, v1 *Poly64X2, v2 *Poly64X2)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslqF64 VbslqF64
//go:noescape
func VbslqF64(r *Float64X2, v0 *Uint64X2, v1 *Float64X2, v2 *Float64X2)

// Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register.
//
//go:linkname VbslF64 VbslF64
//go:noescape
func VbslF64(r *Float64X1, v0 *Uint64X1, v1 *Float64X1, v2 *Float64X1)

// Floating-point Absolute Compare Greater than or Equal (vector). This instruction compares the absolute value of each floating-point value in the first source SIMD&FP register with the absolute value of the corresponding floating-point value in the second source SIMD&FP register and if the first value is greater than or equal to the second value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcageqF64 VcageqF64
//go:noescape
func VcageqF64(r *Uint64X2, v0 *Float64X2, v1 *Float64X2)

// Floating-point Absolute Compare Greater than or Equal (vector). This instruction compares the absolute value of each floating-point value in the first source SIMD&FP register with the absolute value of the corresponding floating-point value in the second source SIMD&FP register and if the first value is greater than or equal to the second value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcageF64 VcageF64
//go:noescape
func VcageF64(r *Uint64X1, v0 *Float64X1, v1 *Float64X1)

// Floating-point Absolute Compare Greater than or Equal (vector). This instruction compares the absolute value of each floating-point value in the first source SIMD&FP register with the absolute value of the corresponding floating-point value in the second source SIMD&FP register and if the first value is greater than or equal to the second value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcagedF64 VcagedF64
//go:noescape
func VcagedF64(r *Uint64, v0 *Float64, v1 *Float64)

// Floating-point Absolute Compare Greater than or Equal (vector). This instruction compares the absolute value of each floating-point value in the first source SIMD&FP register with the absolute value of the corresponding floating-point value in the second source SIMD&FP register and if the first value is greater than or equal to the second value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcagesF32 VcagesF32
//go:noescape
func VcagesF32(r *Uint32, v0 *Float32, v1 *Float32)

// Floating-point Absolute Compare Greater than (vector). This instruction compares the absolute value of each vector element in the first source SIMD&FP register with the absolute value of the corresponding vector element in the second source SIMD&FP register and if the first value is greater than the second value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcagtqF64 VcagtqF64
//go:noescape
func VcagtqF64(r *Uint64X2, v0 *Float64X2, v1 *Float64X2)

// Floating-point Absolute Compare Greater than (vector). This instruction compares the absolute value of each vector element in the first source SIMD&FP register with the absolute value of the corresponding vector element in the second source SIMD&FP register and if the first value is greater than the second value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcagtF64 VcagtF64
//go:noescape
func VcagtF64(r *Uint64X1, v0 *Float64X1, v1 *Float64X1)

// Floating-point Absolute Compare Greater than (vector). This instruction compares the absolute value of each vector element in the first source SIMD&FP register with the absolute value of the corresponding vector element in the second source SIMD&FP register and if the first value is greater than the second value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcagtdF64 VcagtdF64
//go:noescape
func VcagtdF64(r *Uint64, v0 *Float64, v1 *Float64)

// Floating-point Absolute Compare Greater than (vector). This instruction compares the absolute value of each vector element in the first source SIMD&FP register with the absolute value of the corresponding vector element in the second source SIMD&FP register and if the first value is greater than the second value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcagtsF32 VcagtsF32
//go:noescape
func VcagtsF32(r *Uint32, v0 *Float32, v1 *Float32)

// Floating-point absolute compare less than or equal
//
//go:linkname VcaleqF64 VcaleqF64
//go:noescape
func VcaleqF64(r *Uint64X2, v0 *Float64X2, v1 *Float64X2)

// Floating-point absolute compare less than or equal
//
//go:linkname VcaleF64 VcaleF64
//go:noescape
func VcaleF64(r *Uint64X1, v0 *Float64X1, v1 *Float64X1)

// Floating-point absolute compare less than or equal
//
//go:linkname VcaledF64 VcaledF64
//go:noescape
func VcaledF64(r *Uint64, v0 *Float64, v1 *Float64)

// Floating-point absolute compare less than or equal
//
//go:linkname VcalesF32 VcalesF32
//go:noescape
func VcalesF32(r *Uint32, v0 *Float32, v1 *Float32)

// Floating-point absolute compare less than
//
//go:linkname VcaltqF64 VcaltqF64
//go:noescape
func VcaltqF64(r *Uint64X2, v0 *Float64X2, v1 *Float64X2)

// Floating-point absolute compare less than
//
//go:linkname VcaltF64 VcaltF64
//go:noescape
func VcaltF64(r *Uint64X1, v0 *Float64X1, v1 *Float64X1)

// Floating-point absolute compare less than
//
//go:linkname VcaltdF64 VcaltdF64
//go:noescape
func VcaltdF64(r *Uint64, v0 *Float64, v1 *Float64)

// Floating-point absolute compare less than
//
//go:linkname VcaltsF32 VcaltsF32
//go:noescape
func VcaltsF32(r *Uint32, v0 *Float32, v1 *Float32)

// Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqP64 VceqP64
//go:noescape
func VceqP64(r *Uint64X1, v0 *Poly64X1, v1 *Poly64X1)

// Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqqP64 VceqqP64
//go:noescape
func VceqqP64(r *Uint64X2, v0 *Poly64X2, v1 *Poly64X2)

// Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqqU64 VceqqU64
//go:noescape
func VceqqU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// Floating-point Compare Equal (vector). This instruction compares each floating-point value from the first source SIMD&FP register, with the corresponding floating-point value from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqqF64 VceqqF64
//go:noescape
func VceqqF64(r *Uint64X2, v0 *Float64X2, v1 *Float64X2)

// Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqqS64 VceqqS64
//go:noescape
func VceqqS64(r *Uint64X2, v0 *Int64X2, v1 *Int64X2)

// Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqU64 VceqU64
//go:noescape
func VceqU64(r *Uint64X1, v0 *Uint64X1, v1 *Uint64X1)

// Floating-point Compare Equal (vector). This instruction compares each floating-point value from the first source SIMD&FP register, with the corresponding floating-point value from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqF64 VceqF64
//go:noescape
func VceqF64(r *Uint64X1, v0 *Float64X1, v1 *Float64X1)

// Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqS64 VceqS64
//go:noescape
func VceqS64(r *Uint64X1, v0 *Int64X1, v1 *Int64X1)

// Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqdU64 VceqdU64
//go:noescape
func VceqdU64(r *Uint64, v0 *Uint64, v1 *Uint64)

// Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqdS64 VceqdS64
//go:noescape
func VceqdS64(r *Uint64, v0 *Int64, v1 *Int64)

// Floating-point Compare Equal (vector). This instruction compares each floating-point value from the first source SIMD&FP register, with the corresponding floating-point value from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqdF64 VceqdF64
//go:noescape
func VceqdF64(r *Uint64, v0 *Float64, v1 *Float64)

// Floating-point Compare Equal (vector). This instruction compares each floating-point value from the first source SIMD&FP register, with the corresponding floating-point value from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqsF32 VceqsF32
//go:noescape
func VceqsF32(r *Uint32, v0 *Float32, v1 *Float32)

// Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzP8 VceqzP8
//go:noescape
func VceqzP8(r *Uint8X8, v0 *Poly8X8)

// Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzP64 VceqzP64
//go:noescape
func VceqzP64(r *Uint64X1, v0 *Poly64X1)

// Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzqP8 VceqzqP8
//go:noescape
func VceqzqP8(r *Uint8X16, v0 *Poly8X16)

// Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzqP64 VceqzqP64
//go:noescape
func VceqzqP64(r *Uint64X2, v0 *Poly64X2)

// Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzqU8 VceqzqU8
//go:noescape
func VceqzqU8(r *Uint8X16, v0 *Uint8X16)

// Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzqU32 VceqzqU32
//go:noescape
func VceqzqU32(r *Uint32X4, v0 *Uint32X4)

// Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzqU64 VceqzqU64
//go:noescape
func VceqzqU64(r *Uint64X2, v0 *Uint64X2)

// Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzqU16 VceqzqU16
//go:noescape
func VceqzqU16(r *Uint16X8, v0 *Uint16X8)

// Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzqS8 VceqzqS8
//go:noescape
func VceqzqS8(r *Uint8X16, v0 *Int8X16)

// Floating-point Compare Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzqF64 VceqzqF64
//go:noescape
func VceqzqF64(r *Uint64X2, v0 *Float64X2)

// Floating-point Compare Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzqF32 VceqzqF32
//go:noescape
func VceqzqF32(r *Uint32X4, v0 *Float32X4)

// Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzqS32 VceqzqS32
//go:noescape
func VceqzqS32(r *Uint32X4, v0 *Int32X4)

// Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzqS64 VceqzqS64
//go:noescape
func VceqzqS64(r *Uint64X2, v0 *Int64X2)

// Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzqS16 VceqzqS16
//go:noescape
func VceqzqS16(r *Uint16X8, v0 *Int16X8)

// Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzU8 VceqzU8
//go:noescape
func VceqzU8(r *Uint8X8, v0 *Uint8X8)

// Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzU32 VceqzU32
//go:noescape
func VceqzU32(r *Uint32X2, v0 *Uint32X2)

// Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzU64 VceqzU64
//go:noescape
func VceqzU64(r *Uint64X1, v0 *Uint64X1)

// Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzU16 VceqzU16
//go:noescape
func VceqzU16(r *Uint16X4, v0 *Uint16X4)

// Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzS8 VceqzS8
//go:noescape
func VceqzS8(r *Uint8X8, v0 *Int8X8)

// Floating-point Compare Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzF64 VceqzF64
//go:noescape
func VceqzF64(r *Uint64X1, v0 *Float64X1)

// Floating-point Compare Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzF32 VceqzF32
//go:noescape
func VceqzF32(r *Uint32X2, v0 *Float32X2)

// Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzS32 VceqzS32
//go:noescape
func VceqzS32(r *Uint32X2, v0 *Int32X2)

// Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzS64 VceqzS64
//go:noescape
func VceqzS64(r *Uint64X1, v0 *Int64X1)

// Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzS16 VceqzS16
//go:noescape
func VceqzS16(r *Uint16X4, v0 *Int16X4)

// Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzdU64 VceqzdU64
//go:noescape
func VceqzdU64(r *Uint64, v0 *Uint64)

// Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzdS64 VceqzdS64
//go:noescape
func VceqzdS64(r *Uint64, v0 *Int64)

// Floating-point Compare Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzdF64 VceqzdF64
//go:noescape
func VceqzdF64(r *Uint64, v0 *Float64)

// Floating-point Compare Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VceqzsF32 VceqzsF32
//go:noescape
func VceqzsF32(r *Uint32, v0 *Float32)

// Compare unsigned Higher or Same (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than or equal to the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgeqU64 VcgeqU64
//go:noescape
func VcgeqU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// Floating-point Compare Greater than or Equal (vector). This instruction reads each floating-point value in the first source SIMD&FP register and if the value is greater than or equal to the corresponding floating-point value in the second source SIMD&FP register sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgeqF64 VcgeqF64
//go:noescape
func VcgeqF64(r *Uint64X2, v0 *Float64X2, v1 *Float64X2)

// Compare signed Greater than or Equal (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than or equal to the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgeqS64 VcgeqS64
//go:noescape
func VcgeqS64(r *Uint64X2, v0 *Int64X2, v1 *Int64X2)

// Compare unsigned Higher or Same (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than or equal to the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgeU64 VcgeU64
//go:noescape
func VcgeU64(r *Uint64X1, v0 *Uint64X1, v1 *Uint64X1)

// Floating-point Compare Greater than or Equal (vector). This instruction reads each floating-point value in the first source SIMD&FP register and if the value is greater than or equal to the corresponding floating-point value in the second source SIMD&FP register sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgeF64 VcgeF64
//go:noescape
func VcgeF64(r *Uint64X1, v0 *Float64X1, v1 *Float64X1)

// Compare signed Greater than or Equal (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than or equal to the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgeS64 VcgeS64
//go:noescape
func VcgeS64(r *Uint64X1, v0 *Int64X1, v1 *Int64X1)

// Compare signed Greater than or Equal (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than or equal to the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgedS64 VcgedS64
//go:noescape
func VcgedS64(r *Uint64, v0 *Int64, v1 *Int64)

// Compare unsigned Higher or Same (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than or equal to the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgedU64 VcgedU64
//go:noescape
func VcgedU64(r *Uint64, v0 *Uint64, v1 *Uint64)

// Floating-point Compare Greater than or Equal (vector). This instruction reads each floating-point value in the first source SIMD&FP register and if the value is greater than or equal to the corresponding floating-point value in the second source SIMD&FP register sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgedF64 VcgedF64
//go:noescape
func VcgedF64(r *Uint64, v0 *Float64, v1 *Float64)

// Floating-point Compare Greater than or Equal (vector). This instruction reads each floating-point value in the first source SIMD&FP register and if the value is greater than or equal to the corresponding floating-point value in the second source SIMD&FP register sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgesF32 VcgesF32
//go:noescape
func VcgesF32(r *Uint32, v0 *Float32, v1 *Float32)

// Compare signed Greater than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgezqS8 VcgezqS8
//go:noescape
func VcgezqS8(r *Uint8X16, v0 *Int8X16)

// Floating-point Compare Greater than or Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgezqF64 VcgezqF64
//go:noescape
func VcgezqF64(r *Uint64X2, v0 *Float64X2)

// Floating-point Compare Greater than or Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgezqF32 VcgezqF32
//go:noescape
func VcgezqF32(r *Uint32X4, v0 *Float32X4)

// Compare signed Greater than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgezqS32 VcgezqS32
//go:noescape
func VcgezqS32(r *Uint32X4, v0 *Int32X4)

// Compare signed Greater than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgezqS64 VcgezqS64
//go:noescape
func VcgezqS64(r *Uint64X2, v0 *Int64X2)

// Compare signed Greater than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgezqS16 VcgezqS16
//go:noescape
func VcgezqS16(r *Uint16X8, v0 *Int16X8)

// Compare signed Greater than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgezS8 VcgezS8
//go:noescape
func VcgezS8(r *Uint8X8, v0 *Int8X8)

// Floating-point Compare Greater than or Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgezF64 VcgezF64
//go:noescape
func VcgezF64(r *Uint64X1, v0 *Float64X1)

// Floating-point Compare Greater than or Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgezF32 VcgezF32
//go:noescape
func VcgezF32(r *Uint32X2, v0 *Float32X2)

// Compare signed Greater than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgezS32 VcgezS32
//go:noescape
func VcgezS32(r *Uint32X2, v0 *Int32X2)

// Compare signed Greater than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgezS64 VcgezS64
//go:noescape
func VcgezS64(r *Uint64X1, v0 *Int64X1)

// Compare signed Greater than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgezS16 VcgezS16
//go:noescape
func VcgezS16(r *Uint16X4, v0 *Int16X4)

// Compare signed Greater than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgezdS64 VcgezdS64
//go:noescape
func VcgezdS64(r *Uint64, v0 *Int64)

// Floating-point Compare Greater than or Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgezdF64 VcgezdF64
//go:noescape
func VcgezdF64(r *Uint64, v0 *Float64)

// Floating-point Compare Greater than or Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgezsF32 VcgezsF32
//go:noescape
func VcgezsF32(r *Uint32, v0 *Float32)

// Compare unsigned Higher (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtqU64 VcgtqU64
//go:noescape
func VcgtqU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// Floating-point Compare Greater than (vector). This instruction reads each floating-point value in the first source SIMD&FP register and if the value is greater than the corresponding floating-point value in the second source SIMD&FP register sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtqF64 VcgtqF64
//go:noescape
func VcgtqF64(r *Uint64X2, v0 *Float64X2, v1 *Float64X2)

// Compare signed Greater than (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtqS64 VcgtqS64
//go:noescape
func VcgtqS64(r *Uint64X2, v0 *Int64X2, v1 *Int64X2)

// Compare unsigned Higher (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtU64 VcgtU64
//go:noescape
func VcgtU64(r *Uint64X1, v0 *Uint64X1, v1 *Uint64X1)

// Floating-point Compare Greater than (vector). This instruction reads each floating-point value in the first source SIMD&FP register and if the value is greater than the corresponding floating-point value in the second source SIMD&FP register sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtF64 VcgtF64
//go:noescape
func VcgtF64(r *Uint64X1, v0 *Float64X1, v1 *Float64X1)

// Compare signed Greater than (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtS64 VcgtS64
//go:noescape
func VcgtS64(r *Uint64X1, v0 *Int64X1, v1 *Int64X1)

// Compare signed Greater than (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtdS64 VcgtdS64
//go:noescape
func VcgtdS64(r *Uint64, v0 *Int64, v1 *Int64)

// Compare unsigned Higher (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtdU64 VcgtdU64
//go:noescape
func VcgtdU64(r *Uint64, v0 *Uint64, v1 *Uint64)

// Floating-point Compare Greater than (vector). This instruction reads each floating-point value in the first source SIMD&FP register and if the value is greater than the corresponding floating-point value in the second source SIMD&FP register sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtdF64 VcgtdF64
//go:noescape
func VcgtdF64(r *Uint64, v0 *Float64, v1 *Float64)

// Floating-point Compare Greater than (vector). This instruction reads each floating-point value in the first source SIMD&FP register and if the value is greater than the corresponding floating-point value in the second source SIMD&FP register sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtsF32 VcgtsF32
//go:noescape
func VcgtsF32(r *Uint32, v0 *Float32, v1 *Float32)

// Compare signed Greater than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtzqS8 VcgtzqS8
//go:noescape
func VcgtzqS8(r *Uint8X16, v0 *Int8X16)

// Floating-point Compare Greater than zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtzqF64 VcgtzqF64
//go:noescape
func VcgtzqF64(r *Uint64X2, v0 *Float64X2)

// Floating-point Compare Greater than zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtzqF32 VcgtzqF32
//go:noescape
func VcgtzqF32(r *Uint32X4, v0 *Float32X4)

// Compare signed Greater than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtzqS32 VcgtzqS32
//go:noescape
func VcgtzqS32(r *Uint32X4, v0 *Int32X4)

// Compare signed Greater than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtzqS64 VcgtzqS64
//go:noescape
func VcgtzqS64(r *Uint64X2, v0 *Int64X2)

// Compare signed Greater than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtzqS16 VcgtzqS16
//go:noescape
func VcgtzqS16(r *Uint16X8, v0 *Int16X8)

// Compare signed Greater than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtzS8 VcgtzS8
//go:noescape
func VcgtzS8(r *Uint8X8, v0 *Int8X8)

// Floating-point Compare Greater than zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtzF64 VcgtzF64
//go:noescape
func VcgtzF64(r *Uint64X1, v0 *Float64X1)

// Floating-point Compare Greater than zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtzF32 VcgtzF32
//go:noescape
func VcgtzF32(r *Uint32X2, v0 *Float32X2)

// Compare signed Greater than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtzS32 VcgtzS32
//go:noescape
func VcgtzS32(r *Uint32X2, v0 *Int32X2)

// Compare signed Greater than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtzS64 VcgtzS64
//go:noescape
func VcgtzS64(r *Uint64X1, v0 *Int64X1)

// Compare signed Greater than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtzS16 VcgtzS16
//go:noescape
func VcgtzS16(r *Uint16X4, v0 *Int16X4)

// Compare signed Greater than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtzdS64 VcgtzdS64
//go:noescape
func VcgtzdS64(r *Uint64, v0 *Int64)

// Floating-point Compare Greater than zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtzdF64 VcgtzdF64
//go:noescape
func VcgtzdF64(r *Uint64, v0 *Float64)

// Floating-point Compare Greater than zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcgtzsF32 VcgtzsF32
//go:noescape
func VcgtzsF32(r *Uint32, v0 *Float32)

// Compare unsigned less than or equal
//
//go:linkname VcleqU64 VcleqU64
//go:noescape
func VcleqU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// Floating-point compare less than or equal
//
//go:linkname VcleqF64 VcleqF64
//go:noescape
func VcleqF64(r *Uint64X2, v0 *Float64X2, v1 *Float64X2)

// Compare signed less than or equal
//
//go:linkname VcleqS64 VcleqS64
//go:noescape
func VcleqS64(r *Uint64X2, v0 *Int64X2, v1 *Int64X2)

// Compare unsigned less than or equal
//
//go:linkname VcleU64 VcleU64
//go:noescape
func VcleU64(r *Uint64X1, v0 *Uint64X1, v1 *Uint64X1)

// Floating-point compare less than or equal
//
//go:linkname VcleF64 VcleF64
//go:noescape
func VcleF64(r *Uint64X1, v0 *Float64X1, v1 *Float64X1)

// Compare signed less than or equal
//
//go:linkname VcleS64 VcleS64
//go:noescape
func VcleS64(r *Uint64X1, v0 *Int64X1, v1 *Int64X1)

// Compare unsigned less than or equal
//
//go:linkname VcledU64 VcledU64
//go:noescape
func VcledU64(r *Uint64, v0 *Uint64, v1 *Uint64)

// Compare signed less than or equal
//
//go:linkname VcledS64 VcledS64
//go:noescape
func VcledS64(r *Uint64, v0 *Int64, v1 *Int64)

// Floating-point compare less than or equal
//
//go:linkname VcledF64 VcledF64
//go:noescape
func VcledF64(r *Uint64, v0 *Float64, v1 *Float64)

// Floating-point compare less than or equal
//
//go:linkname VclesF32 VclesF32
//go:noescape
func VclesF32(r *Uint32, v0 *Float32, v1 *Float32)

// Compare signed Less than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VclezqS8 VclezqS8
//go:noescape
func VclezqS8(r *Uint8X16, v0 *Int8X16)

// Floating-point Compare Less than or Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VclezqF64 VclezqF64
//go:noescape
func VclezqF64(r *Uint64X2, v0 *Float64X2)

// Floating-point Compare Less than or Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VclezqF32 VclezqF32
//go:noescape
func VclezqF32(r *Uint32X4, v0 *Float32X4)

// Compare signed Less than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VclezqS32 VclezqS32
//go:noescape
func VclezqS32(r *Uint32X4, v0 *Int32X4)

// Compare signed Less than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VclezqS64 VclezqS64
//go:noescape
func VclezqS64(r *Uint64X2, v0 *Int64X2)

// Compare signed Less than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VclezqS16 VclezqS16
//go:noescape
func VclezqS16(r *Uint16X8, v0 *Int16X8)

// Compare signed Less than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VclezS8 VclezS8
//go:noescape
func VclezS8(r *Uint8X8, v0 *Int8X8)

// Floating-point Compare Less than or Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VclezF64 VclezF64
//go:noescape
func VclezF64(r *Uint64X1, v0 *Float64X1)

// Compare signed Less than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VclezF32 VclezF32
//go:noescape
func VclezF32(r *Uint32X2, v0 *Float32X2)

// Compare signed Less than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VclezS32 VclezS32
//go:noescape
func VclezS32(r *Uint32X2, v0 *Int32X2)

// Compare signed Less than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VclezS64 VclezS64
//go:noescape
func VclezS64(r *Uint64X1, v0 *Int64X1)

// Compare signed Less than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VclezS16 VclezS16
//go:noescape
func VclezS16(r *Uint16X4, v0 *Int16X4)

// Compare signed Less than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VclezdS64 VclezdS64
//go:noescape
func VclezdS64(r *Uint64, v0 *Int64)

// Floating-point Compare Less than or Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VclezdF64 VclezdF64
//go:noescape
func VclezdF64(r *Uint64, v0 *Float64)

// Floating-point Compare Less than or Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VclezsF32 VclezsF32
//go:noescape
func VclezsF32(r *Uint32, v0 *Float32)

// Compare unsigned less than
//
//go:linkname VcltqU64 VcltqU64
//go:noescape
func VcltqU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// Floating-point compare less than
//
//go:linkname VcltqF64 VcltqF64
//go:noescape
func VcltqF64(r *Uint64X2, v0 *Float64X2, v1 *Float64X2)

// Compare signed less than
//
//go:linkname VcltqS64 VcltqS64
//go:noescape
func VcltqS64(r *Uint64X2, v0 *Int64X2, v1 *Int64X2)

// Compare unsigned less than
//
//go:linkname VcltU64 VcltU64
//go:noescape
func VcltU64(r *Uint64X1, v0 *Uint64X1, v1 *Uint64X1)

// Floating-point compare less than
//
//go:linkname VcltF64 VcltF64
//go:noescape
func VcltF64(r *Uint64X1, v0 *Float64X1, v1 *Float64X1)

// Compare signed less than
//
//go:linkname VcltS64 VcltS64
//go:noescape
func VcltS64(r *Uint64X1, v0 *Int64X1, v1 *Int64X1)

// Compare unsigned less than
//
//go:linkname VcltdU64 VcltdU64
//go:noescape
func VcltdU64(r *Uint64, v0 *Uint64, v1 *Uint64)

// Compare signed less than
//
//go:linkname VcltdS64 VcltdS64
//go:noescape
func VcltdS64(r *Uint64, v0 *Int64, v1 *Int64)

// Floating-point compare less than
//
//go:linkname VcltdF64 VcltdF64
//go:noescape
func VcltdF64(r *Uint64, v0 *Float64, v1 *Float64)

// Floating-point compare less than
//
//go:linkname VcltsF32 VcltsF32
//go:noescape
func VcltsF32(r *Uint32, v0 *Float32, v1 *Float32)

// Compare signed Less than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcltzqS8 VcltzqS8
//go:noescape
func VcltzqS8(r *Uint8X16, v0 *Int8X16)

// Floating-point Compare Less than zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is less than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcltzqF64 VcltzqF64
//go:noescape
func VcltzqF64(r *Uint64X2, v0 *Float64X2)

// Floating-point Compare Less than zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is less than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcltzqF32 VcltzqF32
//go:noescape
func VcltzqF32(r *Uint32X4, v0 *Float32X4)

// Compare signed Less than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcltzqS32 VcltzqS32
//go:noescape
func VcltzqS32(r *Uint32X4, v0 *Int32X4)

// Compare signed Less than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcltzqS64 VcltzqS64
//go:noescape
func VcltzqS64(r *Uint64X2, v0 *Int64X2)

// Compare signed Less than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcltzqS16 VcltzqS16
//go:noescape
func VcltzqS16(r *Uint16X8, v0 *Int16X8)

// Compare signed Less than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcltzS8 VcltzS8
//go:noescape
func VcltzS8(r *Uint8X8, v0 *Int8X8)

// Floating-point Compare Less than zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is less than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcltzF64 VcltzF64
//go:noescape
func VcltzF64(r *Uint64X1, v0 *Float64X1)

// Floating-point Compare Less than zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is less than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcltzF32 VcltzF32
//go:noescape
func VcltzF32(r *Uint32X2, v0 *Float32X2)

// Compare signed Less than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcltzS32 VcltzS32
//go:noescape
func VcltzS32(r *Uint32X2, v0 *Int32X2)

// Compare signed Less than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcltzS64 VcltzS64
//go:noescape
func VcltzS64(r *Uint64X1, v0 *Int64X1)

// Compare signed Less than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcltzS16 VcltzS16
//go:noescape
func VcltzS16(r *Uint16X4, v0 *Int16X4)

// Compare signed Less than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcltzdS64 VcltzdS64
//go:noescape
func VcltzdS64(r *Uint64, v0 *Int64)

// Floating-point Compare Less than zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is less than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcltzdF64 VcltzdF64
//go:noescape
func VcltzdF64(r *Uint64, v0 *Float64)

// Floating-point Compare Less than zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is less than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VcltzsF32 VcltzsF32
//go:noescape
func VcltzsF32(r *Uint32, v0 *Float32)

// Join two smaller vectors into a single larger vector
//
//go:linkname VcombineP64 VcombineP64
//go:noescape
func VcombineP64(r *Poly64X2, v0 *Poly64X1, v1 *Poly64X1)

// Join two smaller vectors into a single larger vector
//
//go:linkname VcombineF64 VcombineF64
//go:noescape
func VcombineF64(r *Float64X2, v0 *Float64X1, v1 *Float64X1)

// Signed fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtsF32S32 VcvtsF32S32
//go:noescape
func VcvtsF32S32(r *Float32, v0 *Int32)

// Unsigned fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtsF32U32 VcvtsF32U32
//go:noescape
func VcvtsF32U32(r *Float32, v0 *Uint32)

// Floating-point Convert to lower precision Narrow (vector). This instruction reads each vector element in the SIMD&FP source register, converts each result to half the precision of the source element, writes the final result to a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. The rounding mode is determined by the FPCR.
//
//go:linkname VcvtF32F64 VcvtF32F64
//go:noescape
func VcvtF32F64(r *Float32X2, v0 *Float64X2)

// Signed fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtdF64S64 VcvtdF64S64
//go:noescape
func VcvtdF64S64(r *Float64, v0 *Int64)

// Unsigned fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtdF64U64 VcvtdF64U64
//go:noescape
func VcvtdF64U64(r *Float64, v0 *Uint64)

// Unsigned fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtqF64U64 VcvtqF64U64
//go:noescape
func VcvtqF64U64(r *Float64X2, v0 *Uint64X2)

// Signed fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtqF64S64 VcvtqF64S64
//go:noescape
func VcvtqF64S64(r *Float64X2, v0 *Int64X2)

// Unsigned fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtF64U64 VcvtF64U64
//go:noescape
func VcvtF64U64(r *Float64X1, v0 *Uint64X1)

// Signed fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtF64S64 VcvtF64S64
//go:noescape
func VcvtF64S64(r *Float64X1, v0 *Int64X1)

// Floating-point Convert to higher precision Long (vector). This instruction reads each element in a vector in the SIMD&FP source register, converts each value to double the precision of the source element using the rounding mode that is determined by the FPCR, and writes each result to the equivalent element of the vector in the SIMD&FP destination register.
//
//go:linkname VcvtF64F32 VcvtF64F32
//go:noescape
func VcvtF64F32(r *Float64X2, v0 *Float32X2)

// Floating-point Convert to lower precision Narrow (vector). This instruction reads each vector element in the SIMD&FP source register, converts each result to half the precision of the source element, writes the final result to a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. The rounding mode is determined by the FPCR.
//
//go:linkname VcvtHighF32F64 VcvtHighF32F64
//go:noescape
func VcvtHighF32F64(r *Float32X4, v0 *Float32X2, v1 *Float64X2)

// Floating-point Convert to higher precision Long (vector). This instruction reads each element in a vector in the SIMD&FP source register, converts each value to double the precision of the source element using the rounding mode that is determined by the FPCR, and writes each result to the equivalent element of the vector in the SIMD&FP destination register.
//
//go:linkname VcvtHighF64F32 VcvtHighF64F32
//go:noescape
func VcvtHighF64F32(r *Float64X2, v0 *Float32X4)

// Floating-point Convert to Signed fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point signed integer using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtsS32F32 VcvtsS32F32
//go:noescape
func VcvtsS32F32(r *Int32, v0 *Float32)

// Floating-point Convert to Signed fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point signed integer using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtdS64F64 VcvtdS64F64
//go:noescape
func VcvtdS64F64(r *Int64, v0 *Float64)

// Floating-point Convert to Signed fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point signed integer using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtqS64F64 VcvtqS64F64
//go:noescape
func VcvtqS64F64(r *Int64X2, v0 *Float64X2)

// Floating-point Convert to Signed fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point signed integer using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtS64F64 VcvtS64F64
//go:noescape
func VcvtS64F64(r *Int64X1, v0 *Float64X1)

// Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point unsigned integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.
//
//go:linkname VcvtsU32F32 VcvtsU32F32
//go:noescape
func VcvtsU32F32(r *Uint32, v0 *Float32)

// Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point unsigned integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.
//
//go:linkname VcvtdU64F64 VcvtdU64F64
//go:noescape
func VcvtdU64F64(r *Uint64, v0 *Float64)

// Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point unsigned integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.
//
//go:linkname VcvtqU64F64 VcvtqU64F64
//go:noescape
func VcvtqU64F64(r *Uint64X2, v0 *Float64X2)

// Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point unsigned integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register.
//
//go:linkname VcvtU64F64 VcvtU64F64
//go:noescape
func VcvtU64F64(r *Uint64X1, v0 *Float64X1)

// Floating-point Convert to Signed integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to a signed integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtasS32F32 VcvtasS32F32
//go:noescape
func VcvtasS32F32(r *Int32, v0 *Float32)

// Floating-point Convert to Signed integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to a signed integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtadS64F64 VcvtadS64F64
//go:noescape
func VcvtadS64F64(r *Int64, v0 *Float64)

// Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtasU32F32 VcvtasU32F32
//go:noescape
func VcvtasU32F32(r *Uint32, v0 *Float32)

// Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtadU64F64 VcvtadU64F64
//go:noescape
func VcvtadU64F64(r *Uint64, v0 *Float64)

// Floating-point Convert to Signed integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtmsS32F32 VcvtmsS32F32
//go:noescape
func VcvtmsS32F32(r *Int32, v0 *Float32)

// Floating-point Convert to Signed integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtmdS64F64 VcvtmdS64F64
//go:noescape
func VcvtmdS64F64(r *Int64, v0 *Float64)

// Floating-point Convert to Unsigned integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtmsU32F32 VcvtmsU32F32
//go:noescape
func VcvtmsU32F32(r *Uint32, v0 *Float32)

// Floating-point Convert to Unsigned integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtmdU64F64 VcvtmdU64F64
//go:noescape
func VcvtmdU64F64(r *Uint64, v0 *Float64)

// Floating-point Convert to Signed integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtnsS32F32 VcvtnsS32F32
//go:noescape
func VcvtnsS32F32(r *Int32, v0 *Float32)

// Floating-point Convert to Signed integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtndS64F64 VcvtndS64F64
//go:noescape
func VcvtndS64F64(r *Int64, v0 *Float64)

// Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtnsU32F32 VcvtnsU32F32
//go:noescape
func VcvtnsU32F32(r *Uint32, v0 *Float32)

// Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtndU64F64 VcvtndU64F64
//go:noescape
func VcvtndU64F64(r *Uint64, v0 *Float64)

// Floating-point Convert to Signed integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtpsS32F32 VcvtpsS32F32
//go:noescape
func VcvtpsS32F32(r *Int32, v0 *Float32)

// Floating-point Convert to Signed integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtpdS64F64 VcvtpdS64F64
//go:noescape
func VcvtpdS64F64(r *Int64, v0 *Float64)

// Floating-point Convert to Unsigned integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtpsU32F32 VcvtpsU32F32
//go:noescape
func VcvtpsU32F32(r *Uint32, v0 *Float32)

// Floating-point Convert to Unsigned integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
//
//go:linkname VcvtpdU64F64 VcvtpdU64F64
//go:noescape
func VcvtpdU64F64(r *Uint64, v0 *Float64)

// Floating-point Convert to lower precision Narrow, rounding to odd (vector). This instruction reads each vector element in the source SIMD&FP register, narrows each value to half the precision of the source element using the Round to Odd rounding mode, writes the result to a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VcvtxdF32F64 VcvtxdF32F64
//go:noescape
func VcvtxdF32F64(r *Float32, v0 *Float64)

// Floating-point Convert to lower precision Narrow, rounding to odd (vector). This instruction reads each vector element in the source SIMD&FP register, narrows each value to half the precision of the source element using the Round to Odd rounding mode, writes the result to a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VcvtxF32F64 VcvtxF32F64
//go:noescape
func VcvtxF32F64(r *Float32X2, v0 *Float64X2)

// Floating-point Convert to lower precision Narrow, rounding to odd (vector). This instruction reads each vector element in the source SIMD&FP register, narrows each value to half the precision of the source element using the Round to Odd rounding mode, writes the result to a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VcvtxHighF32F64 VcvtxHighF32F64
//go:noescape
func VcvtxHighF32F64(r *Float32X4, v0 *Float32X2, v1 *Float64X2)

// Floating-point Divide (vector). This instruction divides the floating-point values in the elements in the first source SIMD&FP register, by the floating-point values in the corresponding elements in the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VdivqF64 VdivqF64
//go:noescape
func VdivqF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Floating-point Divide (vector). This instruction divides the floating-point values in the elements in the first source SIMD&FP register, by the floating-point values in the corresponding elements in the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VdivqF32 VdivqF32
//go:noescape
func VdivqF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Floating-point Divide (vector). This instruction divides the floating-point values in the elements in the first source SIMD&FP register, by the floating-point values in the corresponding elements in the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VdivF64 VdivF64
//go:noescape
func VdivF64(r *Float64X1, v0 *Float64X1, v1 *Float64X1)

// Floating-point Divide (vector). This instruction divides the floating-point values in the elements in the first source SIMD&FP register, by the floating-point values in the corresponding elements in the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VdivF32 VdivF32
//go:noescape
func VdivF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Insert vector element from another vector element. This instruction copies the vector element of the source SIMD&FP register to the specified vector element of the destination SIMD&FP register.
//
//go:linkname VdupNP64 VdupNP64
//go:noescape
func VdupNP64(r *Poly64X1, v0 *Poly64)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VdupqNP64 VdupqNP64
//go:noescape
func VdupqNP64(r *Poly64X2, v0 *Poly64)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VdupqNF64 VdupqNF64
//go:noescape
func VdupqNF64(r *Float64X2, v0 *Float64)

// Insert vector element from another vector element. This instruction copies the vector element of the source SIMD&FP register to the specified vector element of the destination SIMD&FP register.
//
//go:linkname VdupNF64 VdupNF64
//go:noescape
func VdupNF64(r *Float64X1, v0 *Float64)

// Floating-point fused Multiply-Add to accumulator (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, adds the product to the corresponding vector element of the destination SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VfmaqF64 VfmaqF64
//go:noescape
func VfmaqF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2, v2 *Float64X2)

// Floating-point fused Multiply-Add (scalar). This instruction multiplies the values of the first two SIMD&FP source registers, adds the product to the value of the third SIMD&FP source register, and writes the result to the SIMD&FP destination register.
//
//go:linkname VfmaF64 VfmaF64
//go:noescape
func VfmaF64(r *Float64X1, v0 *Float64X1, v1 *Float64X1, v2 *Float64X1)

// Floating-point fused Multiply-Add to accumulator (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, adds the product to the corresponding vector element of the destination SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VfmaqNF64 VfmaqNF64
//go:noescape
func VfmaqNF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2, v2 *Float64)

// Floating-point fused Multiply-Add (scalar). This instruction multiplies the values of the first two SIMD&FP source registers, adds the product to the value of the third SIMD&FP source register, and writes the result to the SIMD&FP destination register.
//
//go:linkname VfmaNF64 VfmaNF64
//go:noescape
func VfmaNF64(r *Float64X1, v0 *Float64X1, v1 *Float64X1, v2 *Float64)

// Floating-point fused Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, negates the product, adds the result to the corresponding vector element of the destination SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VfmsqF64 VfmsqF64
//go:noescape
func VfmsqF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2, v2 *Float64X2)

// Floating-point Fused Multiply-Subtract (scalar). This instruction multiplies the values of the first two SIMD&FP source registers, negates the product, adds that to the value of the third SIMD&FP source register, and writes the result to the SIMD&FP destination register.
//
//go:linkname VfmsF64 VfmsF64
//go:noescape
func VfmsF64(r *Float64X1, v0 *Float64X1, v1 *Float64X1, v2 *Float64X1)

// Floating-point fused Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, negates the product, adds the result to the corresponding vector element of the destination SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VfmsqNF64 VfmsqNF64
//go:noescape
func VfmsqNF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2, v2 *Float64)

// Floating-point fused Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, negates the product, adds the result to the corresponding vector element of the destination SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VfmsqNF32 VfmsqNF32
//go:noescape
func VfmsqNF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4, v2 *Float32)

// Floating-point Fused Multiply-Subtract (scalar). This instruction multiplies the values of the first two SIMD&FP source registers, negates the product, adds that to the value of the third SIMD&FP source register, and writes the result to the SIMD&FP destination register.
//
//go:linkname VfmsNF64 VfmsNF64
//go:noescape
func VfmsNF64(r *Float64X1, v0 *Float64X1, v1 *Float64X1, v2 *Float64)

// Floating-point fused Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, negates the product, adds the result to the corresponding vector element of the destination SIMD&FP register, and writes the result to the destination SIMD&FP register.
//
//go:linkname VfmsNF32 VfmsNF32
//go:noescape
func VfmsNF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2, v2 *Float32)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetHighP64 VgetHighP64
//go:noescape
func VgetHighP64(r *Poly64X1, v0 *Poly64X2)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetHighF64 VgetHighF64
//go:noescape
func VgetHighF64(r *Float64X1, v0 *Float64X2)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetLowP64 VgetLowP64
//go:noescape
func VgetLowP64(r *Poly64X1, v0 *Poly64X2)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VgetLowF64 VgetLowF64
//go:noescape
func VgetLowF64(r *Float64X1, v0 *Float64X2)

// Floating-point Maximum (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, places the larger of each of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmaxqF64 VmaxqF64
//go:noescape
func VmaxqF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Floating-point Maximum (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, places the larger of each of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmaxF64 VmaxF64
//go:noescape
func VmaxF64(r *Float64X1, v0 *Float64X1, v1 *Float64X1)

// Floating-point Maximum Number Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VmaxnmvqF64 VmaxnmvqF64
//go:noescape
func VmaxnmvqF64(r *Float64, v0 *Float64X2)

// Floating-point Maximum Number across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VmaxnmvqF32 VmaxnmvqF32
//go:noescape
func VmaxnmvqF32(r *Float32, v0 *Float32X4)

// Floating-point Maximum Number Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VmaxnmvF32 VmaxnmvF32
//go:noescape
func VmaxnmvF32(r *Float32, v0 *Float32X2)

// Unsigned Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
//
//go:linkname VmaxvqU8 VmaxvqU8
//go:noescape
func VmaxvqU8(r *Uint8, v0 *Uint8X16)

// Unsigned Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
//
//go:linkname VmaxvqU32 VmaxvqU32
//go:noescape
func VmaxvqU32(r *Uint32, v0 *Uint32X4)

// Unsigned Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
//
//go:linkname VmaxvqU16 VmaxvqU16
//go:noescape
func VmaxvqU16(r *Uint16, v0 *Uint16X8)

// Signed Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VmaxvqS8 VmaxvqS8
//go:noescape
func VmaxvqS8(r *Int8, v0 *Int8X16)

// Floating-point Maximum Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the larger of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VmaxvqF64 VmaxvqF64
//go:noescape
func VmaxvqF64(r *Float64, v0 *Float64X2)

// Floating-point Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VmaxvqF32 VmaxvqF32
//go:noescape
func VmaxvqF32(r *Float32, v0 *Float32X4)

// Signed Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VmaxvqS32 VmaxvqS32
//go:noescape
func VmaxvqS32(r *Int32, v0 *Int32X4)

// Signed Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VmaxvqS16 VmaxvqS16
//go:noescape
func VmaxvqS16(r *Int16, v0 *Int16X8)

// Unsigned Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
//
//go:linkname VmaxvU8 VmaxvU8
//go:noescape
func VmaxvU8(r *Uint8, v0 *Uint8X8)

// Unsigned Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmaxvU32 VmaxvU32
//go:noescape
func VmaxvU32(r *Uint32, v0 *Uint32X2)

// Unsigned Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
//
//go:linkname VmaxvU16 VmaxvU16
//go:noescape
func VmaxvU16(r *Uint16, v0 *Uint16X4)

// Signed Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VmaxvS8 VmaxvS8
//go:noescape
func VmaxvS8(r *Int8, v0 *Int8X8)

// Floating-point Maximum Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the larger of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VmaxvF32 VmaxvF32
//go:noescape
func VmaxvF32(r *Float32, v0 *Float32X2)

// Signed Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmaxvS32 VmaxvS32
//go:noescape
func VmaxvS32(r *Int32, v0 *Int32X2)

// Signed Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VmaxvS16 VmaxvS16
//go:noescape
func VmaxvS16(r *Int16, v0 *Int16X4)

// Floating-point minimum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the smaller of each of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VminqF64 VminqF64
//go:noescape
func VminqF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Floating-point minimum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the smaller of each of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VminF64 VminF64
//go:noescape
func VminF64(r *Float64X1, v0 *Float64X1, v1 *Float64X1)

// Floating-point Minimum Number Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of floating-point values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VminnmvqF64 VminnmvqF64
//go:noescape
func VminnmvqF64(r *Float64, v0 *Float64X2)

// Floating-point Minimum Number across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VminnmvqF32 VminnmvqF32
//go:noescape
func VminnmvqF32(r *Float32, v0 *Float32X4)

// Floating-point Minimum Number Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of floating-point values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VminnmvF32 VminnmvF32
//go:noescape
func VminnmvF32(r *Float32, v0 *Float32X2)

// Unsigned Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
//
//go:linkname VminvqU8 VminvqU8
//go:noescape
func VminvqU8(r *Uint8, v0 *Uint8X16)

// Unsigned Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
//
//go:linkname VminvqU32 VminvqU32
//go:noescape
func VminvqU32(r *Uint32, v0 *Uint32X4)

// Unsigned Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
//
//go:linkname VminvqU16 VminvqU16
//go:noescape
func VminvqU16(r *Uint16, v0 *Uint16X8)

// Signed Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VminvqS8 VminvqS8
//go:noescape
func VminvqS8(r *Int8, v0 *Int8X16)

// Floating-point Minimum Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the smaller of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VminvqF64 VminvqF64
//go:noescape
func VminvqF64(r *Float64, v0 *Float64X2)

// Floating-point Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VminvqF32 VminvqF32
//go:noescape
func VminvqF32(r *Float32, v0 *Float32X4)

// Signed Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VminvqS32 VminvqS32
//go:noescape
func VminvqS32(r *Int32, v0 *Int32X4)

// Signed Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VminvqS16 VminvqS16
//go:noescape
func VminvqS16(r *Int16, v0 *Int16X8)

// Unsigned Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
//
//go:linkname VminvU8 VminvU8
//go:noescape
func VminvU8(r *Uint8, v0 *Uint8X8)

// Unsigned Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VminvU32 VminvU32
//go:noescape
func VminvU32(r *Uint32, v0 *Uint32X2)

// Unsigned Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
//
//go:linkname VminvU16 VminvU16
//go:noescape
func VminvU16(r *Uint16, v0 *Uint16X4)

// Signed Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VminvS8 VminvS8
//go:noescape
func VminvS8(r *Int8, v0 *Int8X8)

// Floating-point Minimum Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the smaller of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VminvF32 VminvF32
//go:noescape
func VminvF32(r *Float32, v0 *Float32X2)

// Signed Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VminvS32 VminvS32
//go:noescape
func VminvS32(r *Int32, v0 *Int32X2)

// Signed Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VminvS16 VminvS16
//go:noescape
func VminvS16(r *Int16, v0 *Int16X4)

// Floating-point multiply-add to accumulator
//
//go:linkname VmlaqF64 VmlaqF64
//go:noescape
func VmlaqF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2, v2 *Float64X2)

// Floating-point multiply-add to accumulator
//
//go:linkname VmlaF64 VmlaF64
//go:noescape
func VmlaF64(r *Float64X1, v0 *Float64X1, v1 *Float64X1, v2 *Float64X1)

// Multiply-subtract from accumulator
//
//go:linkname VmlsqF64 VmlsqF64
//go:noescape
func VmlsqF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2, v2 *Float64X2)

// Multiply-subtract from accumulator
//
//go:linkname VmlsF64 VmlsF64
//go:noescape
func VmlsF64(r *Float64X1, v0 *Float64X1, v1 *Float64X1, v2 *Float64X1)

// vmov_n_p64
//
//go:linkname VmovNP64 VmovNP64
//go:noescape
func VmovNP64(r *Poly64X1, v0 *Poly64)

// vmovq_n_p64
//
//go:linkname VmovqNP64 VmovqNP64
//go:noescape
func VmovqNP64(r *Poly64X2, v0 *Poly64)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovqNF64 VmovqNF64
//go:noescape
func VmovqNF64(r *Float64X2, v0 *Float64)

// Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register.
//
//go:linkname VmovNF64 VmovNF64
//go:noescape
func VmovNF64(r *Float64X1, v0 *Float64)

// Vector move
//
//go:linkname VmovlHighU8 VmovlHighU8
//go:noescape
func VmovlHighU8(r *Uint16X8, v0 *Uint8X16)

// Vector move
//
//go:linkname VmovlHighU32 VmovlHighU32
//go:noescape
func VmovlHighU32(r *Uint64X2, v0 *Uint32X4)

// Vector move
//
//go:linkname VmovlHighU16 VmovlHighU16
//go:noescape
func VmovlHighU16(r *Uint32X4, v0 *Uint16X8)

// Vector move
//
//go:linkname VmovlHighS8 VmovlHighS8
//go:noescape
func VmovlHighS8(r *Int16X8, v0 *Int8X16)

// Vector move
//
//go:linkname VmovlHighS32 VmovlHighS32
//go:noescape
func VmovlHighS32(r *Int64X2, v0 *Int32X4)

// Vector move
//
//go:linkname VmovlHighS16 VmovlHighS16
//go:noescape
func VmovlHighS16(r *Int32X4, v0 *Int16X8)

// Extract Narrow. This instruction reads each vector element from the source SIMD&FP register, narrows each value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.
//
//go:linkname VmovnHighU32 VmovnHighU32
//go:noescape
func VmovnHighU32(r *Uint16X8, v0 *Uint16X4, v1 *Uint32X4)

// Extract Narrow. This instruction reads each vector element from the source SIMD&FP register, narrows each value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.
//
//go:linkname VmovnHighU64 VmovnHighU64
//go:noescape
func VmovnHighU64(r *Uint32X4, v0 *Uint32X2, v1 *Uint64X2)

// Extract Narrow. This instruction reads each vector element from the source SIMD&FP register, narrows each value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.
//
//go:linkname VmovnHighU16 VmovnHighU16
//go:noescape
func VmovnHighU16(r *Uint8X16, v0 *Uint8X8, v1 *Uint16X8)

// Extract Narrow. This instruction reads each vector element from the source SIMD&FP register, narrows each value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.
//
//go:linkname VmovnHighS32 VmovnHighS32
//go:noescape
func VmovnHighS32(r *Int16X8, v0 *Int16X4, v1 *Int32X4)

// Extract Narrow. This instruction reads each vector element from the source SIMD&FP register, narrows each value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.
//
//go:linkname VmovnHighS64 VmovnHighS64
//go:noescape
func VmovnHighS64(r *Int32X4, v0 *Int32X2, v1 *Int64X2)

// Extract Narrow. This instruction reads each vector element from the source SIMD&FP register, narrows each value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.
//
//go:linkname VmovnHighS16 VmovnHighS16
//go:noescape
func VmovnHighS16(r *Int8X16, v0 *Int8X8, v1 *Int16X8)

// Floating-point Multiply (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulqF64 VmulqF64
//go:noescape
func VmulqF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Floating-point Multiply (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulF64 VmulF64
//go:noescape
func VmulF64(r *Float64X1, v0 *Float64X1, v1 *Float64X1)

// Floating-point Multiply (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulNF64 VmulNF64
//go:noescape
func VmulNF64(r *Float64X1, v0 *Float64X1, v1 *Float64)

// Floating-point Multiply (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulqNF64 VmulqNF64
//go:noescape
func VmulqNF64(r *Float64X2, v0 *Float64X2, v1 *Float64)

// Polynomial Multiply Long. This instruction multiplies corresponding elements in the lower or upper half of the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmullP64 VmullP64
//go:noescape
func VmullP64(r *Poly128, v0 *Poly64, v1 *Poly64)

// Polynomial Multiply Long. This instruction multiplies corresponding elements in the lower or upper half of the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmullHighP8 VmullHighP8
//go:noescape
func VmullHighP8(r *Poly16X8, v0 *Poly8X16, v1 *Poly8X16)

// Unsigned Multiply long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.
//
//go:linkname VmullHighU8 VmullHighU8
//go:noescape
func VmullHighU8(r *Uint16X8, v0 *Uint8X16, v1 *Uint8X16)

// Unsigned Multiply long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.
//
//go:linkname VmullHighU32 VmullHighU32
//go:noescape
func VmullHighU32(r *Uint64X2, v0 *Uint32X4, v1 *Uint32X4)

// Unsigned Multiply long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.
//
//go:linkname VmullHighU16 VmullHighU16
//go:noescape
func VmullHighU16(r *Uint32X4, v0 *Uint16X8, v1 *Uint16X8)

// Signed Multiply Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmullHighS8 VmullHighS8
//go:noescape
func VmullHighS8(r *Int16X8, v0 *Int8X16, v1 *Int8X16)

// Signed Multiply Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmullHighS32 VmullHighS32
//go:noescape
func VmullHighS32(r *Int64X2, v0 *Int32X4, v1 *Int32X4)

// Signed Multiply Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmullHighS16 VmullHighS16
//go:noescape
func VmullHighS16(r *Int32X4, v0 *Int16X8, v1 *Int16X8)

// Polynomial Multiply Long. This instruction multiplies corresponding elements in the lower or upper half of the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmullHighP64 VmullHighP64
//go:noescape
func VmullHighP64(r *Poly128, v0 *Poly64X2, v1 *Poly64X2)

// Unsigned Multiply long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.
//
//go:linkname VmullHighNU32 VmullHighNU32
//go:noescape
func VmullHighNU32(r *Uint64X2, v0 *Uint32X4, v1 *Uint32)

// Unsigned Multiply long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.
//
//go:linkname VmullHighNU16 VmullHighNU16
//go:noescape
func VmullHighNU16(r *Uint32X4, v0 *Uint16X8, v1 *Uint16)

// Signed Multiply Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmullHighNS32 VmullHighNS32
//go:noescape
func VmullHighNS32(r *Int64X2, v0 *Int32X4, v1 *Int32)

// Signed Multiply Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmullHighNS16 VmullHighNS16
//go:noescape
func VmullHighNS16(r *Int32X4, v0 *Int16X8, v1 *Int16)

// Floating-point Multiply extended. This instruction multiplies corresponding floating-point values in the vectors of the two source SIMD&FP registers, places the resulting floating-point values in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulxqF64 VmulxqF64
//go:noescape
func VmulxqF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Floating-point Multiply extended. This instruction multiplies corresponding floating-point values in the vectors of the two source SIMD&FP registers, places the resulting floating-point values in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulxqF32 VmulxqF32
//go:noescape
func VmulxqF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Floating-point Multiply extended. This instruction multiplies corresponding floating-point values in the vectors of the two source SIMD&FP registers, places the resulting floating-point values in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulxF64 VmulxF64
//go:noescape
func VmulxF64(r *Float64X1, v0 *Float64X1, v1 *Float64X1)

// Floating-point Multiply extended. This instruction multiplies corresponding floating-point values in the vectors of the two source SIMD&FP registers, places the resulting floating-point values in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulxF32 VmulxF32
//go:noescape
func VmulxF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Floating-point Multiply extended. This instruction multiplies corresponding floating-point values in the vectors of the two source SIMD&FP registers, places the resulting floating-point values in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulxdF64 VmulxdF64
//go:noescape
func VmulxdF64(r *Float64, v0 *Float64, v1 *Float64)

// Floating-point Multiply extended. This instruction multiplies corresponding floating-point values in the vectors of the two source SIMD&FP registers, places the resulting floating-point values in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VmulxsF32 VmulxsF32
//go:noescape
func VmulxsF32(r *Float32, v0 *Float32, v1 *Float32)

// Floating-point Negate (vector). This instruction negates the value of each vector element in the source SIMD&FP register, writes the result to a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VnegqF64 VnegqF64
//go:noescape
func VnegqF64(r *Float64X2, v0 *Float64X2)

// Negate (vector). This instruction reads each vector element from the source SIMD&FP register, negates each value, puts the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VnegqS64 VnegqS64
//go:noescape
func VnegqS64(r *Int64X2, v0 *Int64X2)

// Floating-point Negate (vector). This instruction negates the value of each vector element in the source SIMD&FP register, writes the result to a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VnegF64 VnegF64
//go:noescape
func VnegF64(r *Float64X1, v0 *Float64X1)

// Negate (vector). This instruction reads each vector element from the source SIMD&FP register, negates each value, puts the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VnegS64 VnegS64
//go:noescape
func VnegS64(r *Int64X1, v0 *Int64X1)

// Negate (vector). This instruction reads each vector element from the source SIMD&FP register, negates each value, puts the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VnegdS64 VnegdS64
//go:noescape
func VnegdS64(r *Int64, v0 *Int64)

// Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpaddqU8 VpaddqU8
//go:noescape
func VpaddqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpaddqU32 VpaddqU32
//go:noescape
func VpaddqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpaddqU64 VpaddqU64
//go:noescape
func VpaddqU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpaddqU16 VpaddqU16
//go:noescape
func VpaddqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpaddqS8 VpaddqS8
//go:noescape
func VpaddqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Floating-point Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpaddqF64 VpaddqF64
//go:noescape
func VpaddqF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Floating-point Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpaddqF32 VpaddqF32
//go:noescape
func VpaddqF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpaddqS32 VpaddqS32
//go:noescape
func VpaddqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpaddqS64 VpaddqS64
//go:noescape
func VpaddqS64(r *Int64X2, v0 *Int64X2, v1 *Int64X2)

// Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpaddqS16 VpaddqS16
//go:noescape
func VpaddqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpadddU64 VpadddU64
//go:noescape
func VpadddU64(r *Uint64, v0 *Uint64X2)

// Floating-point Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpadddF64 VpadddF64
//go:noescape
func VpadddF64(r *Float64, v0 *Float64X2)

// Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpadddS64 VpadddS64
//go:noescape
func VpadddS64(r *Int64, v0 *Int64X2)

// Floating-point Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpaddsF32 VpaddsF32
//go:noescape
func VpaddsF32(r *Float32, v0 *Float32X2)

// Unsigned Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpmaxqU8 VpmaxqU8
//go:noescape
func VpmaxqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Unsigned Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpmaxqU32 VpmaxqU32
//go:noescape
func VpmaxqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Unsigned Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpmaxqU16 VpmaxqU16
//go:noescape
func VpmaxqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Signed Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpmaxqS8 VpmaxqS8
//go:noescape
func VpmaxqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Floating-point Maximum Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the larger of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpmaxqF64 VpmaxqF64
//go:noescape
func VpmaxqF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Floating-point Maximum Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the larger of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpmaxqF32 VpmaxqF32
//go:noescape
func VpmaxqF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Signed Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpmaxqS32 VpmaxqS32
//go:noescape
func VpmaxqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Signed Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpmaxqS16 VpmaxqS16
//go:noescape
func VpmaxqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Floating-point Maximum Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the larger of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpmaxqdF64 VpmaxqdF64
//go:noescape
func VpmaxqdF64(r *Float64, v0 *Float64X2)

// Floating-point Maximum Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the larger of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpmaxsF32 VpmaxsF32
//go:noescape
func VpmaxsF32(r *Float32, v0 *Float32X2)

// Floating-point Maximum Number Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpmaxnmqF64 VpmaxnmqF64
//go:noescape
func VpmaxnmqF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Floating-point Maximum Number Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpmaxnmqF32 VpmaxnmqF32
//go:noescape
func VpmaxnmqF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Floating-point Maximum Number Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpmaxnmF32 VpmaxnmF32
//go:noescape
func VpmaxnmF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Floating-point Maximum Number Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpmaxnmqdF64 VpmaxnmqdF64
//go:noescape
func VpmaxnmqdF64(r *Float64, v0 *Float64X2)

// Floating-point Maximum Number Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpmaxnmsF32 VpmaxnmsF32
//go:noescape
func VpmaxnmsF32(r *Float32, v0 *Float32X2)

// Unsigned Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpminqU8 VpminqU8
//go:noescape
func VpminqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Unsigned Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpminqU32 VpminqU32
//go:noescape
func VpminqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Unsigned Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpminqU16 VpminqU16
//go:noescape
func VpminqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Signed Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpminqS8 VpminqS8
//go:noescape
func VpminqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Floating-point Minimum Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the smaller of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpminqF64 VpminqF64
//go:noescape
func VpminqF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Floating-point Minimum Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the smaller of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpminqF32 VpminqF32
//go:noescape
func VpminqF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Signed Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpminqS32 VpminqS32
//go:noescape
func VpminqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Signed Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VpminqS16 VpminqS16
//go:noescape
func VpminqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Floating-point Minimum Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the smaller of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpminqdF64 VpminqdF64
//go:noescape
func VpminqdF64(r *Float64, v0 *Float64X2)

// Floating-point Minimum Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the smaller of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpminsF32 VpminsF32
//go:noescape
func VpminsF32(r *Float32, v0 *Float32X2)

// Floating-point Minimum Number Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of floating-point values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpminnmqF64 VpminnmqF64
//go:noescape
func VpminnmqF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Floating-point Minimum Number Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of floating-point values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpminnmqF32 VpminnmqF32
//go:noescape
func VpminnmqF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Floating-point Minimum Number Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of floating-point values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpminnmF32 VpminnmF32
//go:noescape
func VpminnmF32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Floating-point Minimum Number Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of floating-point values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpminnmqdF64 VpminnmqdF64
//go:noescape
func VpminnmqdF64(r *Float64, v0 *Float64X2)

// Floating-point Minimum Number Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of floating-point values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
//
//go:linkname VpminnmsF32 VpminnmsF32
//go:noescape
func VpminnmsF32(r *Float32, v0 *Float32X2)

// Signed saturating Absolute value. This instruction reads each vector element from the source SIMD&FP register, puts the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqabsqS64 VqabsqS64
//go:noescape
func VqabsqS64(r *Int64X2, v0 *Int64X2)

// Signed saturating Absolute value. This instruction reads each vector element from the source SIMD&FP register, puts the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqabsS64 VqabsS64
//go:noescape
func VqabsS64(r *Int64X1, v0 *Int64X1)

// Signed saturating Absolute value. This instruction reads each vector element from the source SIMD&FP register, puts the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqabsbS8 VqabsbS8
//go:noescape
func VqabsbS8(r *Int8, v0 *Int8)

// Signed saturating Absolute value. This instruction reads each vector element from the source SIMD&FP register, puts the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqabssS32 VqabssS32
//go:noescape
func VqabssS32(r *Int32, v0 *Int32)

// Signed saturating Absolute value. This instruction reads each vector element from the source SIMD&FP register, puts the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqabsdS64 VqabsdS64
//go:noescape
func VqabsdS64(r *Int64, v0 *Int64)

// Signed saturating Absolute value. This instruction reads each vector element from the source SIMD&FP register, puts the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqabshS16 VqabshS16
//go:noescape
func VqabshS16(r *Int16, v0 *Int16)

// Unsigned saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqaddbU8 VqaddbU8
//go:noescape
func VqaddbU8(r *Uint8, v0 *Uint8, v1 *Uint8)

// Unsigned saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqaddsU32 VqaddsU32
//go:noescape
func VqaddsU32(r *Uint32, v0 *Uint32, v1 *Uint32)

// Unsigned saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqadddU64 VqadddU64
//go:noescape
func VqadddU64(r *Uint64, v0 *Uint64, v1 *Uint64)

// Unsigned saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqaddhU16 VqaddhU16
//go:noescape
func VqaddhU16(r *Uint16, v0 *Uint16, v1 *Uint16)

// Signed saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqaddbS8 VqaddbS8
//go:noescape
func VqaddbS8(r *Int8, v0 *Int8, v1 *Int8)

// Signed saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqaddsS32 VqaddsS32
//go:noescape
func VqaddsS32(r *Int32, v0 *Int32, v1 *Int32)

// Signed saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqadddS64 VqadddS64
//go:noescape
func VqadddS64(r *Int64, v0 *Int64, v1 *Int64)

// Signed saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqaddhS16 VqaddhS16
//go:noescape
func VqaddhS16(r *Int16, v0 *Int16, v1 *Int16)

// Signed saturating Doubling Multiply-Add Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and accumulates the final results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VqdmlalsS32 VqdmlalsS32
//go:noescape
func VqdmlalsS32(r *Int64, v0 *Int64, v1 *Int32, v2 *Int32)

// Signed saturating Doubling Multiply-Add Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and accumulates the final results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VqdmlalhS16 VqdmlalhS16
//go:noescape
func VqdmlalhS16(r *Int32, v0 *Int32, v1 *Int16, v2 *Int16)

// Signed saturating Doubling Multiply-Add Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and accumulates the final results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VqdmlalHighS32 VqdmlalHighS32
//go:noescape
func VqdmlalHighS32(r *Int64X2, v0 *Int64X2, v1 *Int32X4, v2 *Int32X4)

// Signed saturating Doubling Multiply-Add Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and accumulates the final results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VqdmlalHighS16 VqdmlalHighS16
//go:noescape
func VqdmlalHighS16(r *Int32X4, v0 *Int32X4, v1 *Int16X8, v2 *Int16X8)

// Signed saturating Doubling Multiply-Add Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and accumulates the final results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VqdmlalHighNS32 VqdmlalHighNS32
//go:noescape
func VqdmlalHighNS32(r *Int64X2, v0 *Int64X2, v1 *Int32X4, v2 *Int32)

// Signed saturating Doubling Multiply-Add Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and accumulates the final results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VqdmlalHighNS16 VqdmlalHighNS16
//go:noescape
func VqdmlalHighNS16(r *Int32X4, v0 *Int32X4, v1 *Int16X8, v2 *Int16)

// Signed saturating Doubling Multiply-Subtract Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and subtracts the final results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VqdmlslsS32 VqdmlslsS32
//go:noescape
func VqdmlslsS32(r *Int64, v0 *Int64, v1 *Int32, v2 *Int32)

// Signed saturating Doubling Multiply-Subtract Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and subtracts the final results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VqdmlslhS16 VqdmlslhS16
//go:noescape
func VqdmlslhS16(r *Int32, v0 *Int32, v1 *Int16, v2 *Int16)

// Signed saturating Doubling Multiply-Subtract Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and subtracts the final results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VqdmlslHighS32 VqdmlslHighS32
//go:noescape
func VqdmlslHighS32(r *Int64X2, v0 *Int64X2, v1 *Int32X4, v2 *Int32X4)

// Signed saturating Doubling Multiply-Subtract Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and subtracts the final results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VqdmlslHighS16 VqdmlslHighS16
//go:noescape
func VqdmlslHighS16(r *Int32X4, v0 *Int32X4, v1 *Int16X8, v2 *Int16X8)

// Signed saturating Doubling Multiply-Subtract Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and subtracts the final results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VqdmlslHighNS32 VqdmlslHighNS32
//go:noescape
func VqdmlslHighNS32(r *Int64X2, v0 *Int64X2, v1 *Int32X4, v2 *Int32)

// Signed saturating Doubling Multiply-Subtract Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and subtracts the final results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VqdmlslHighNS16 VqdmlslHighNS16
//go:noescape
func VqdmlslHighNS16(r *Int32X4, v0 *Int32X4, v1 *Int16X8, v2 *Int16)

// Signed saturating Doubling Multiply returning High half. This instruction multiplies the values of corresponding elements of the two source SIMD&FP registers, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqdmulhsS32 VqdmulhsS32
//go:noescape
func VqdmulhsS32(r *Int32, v0 *Int32, v1 *Int32)

// Signed saturating Doubling Multiply returning High half. This instruction multiplies the values of corresponding elements of the two source SIMD&FP registers, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqdmulhhS16 VqdmulhhS16
//go:noescape
func VqdmulhhS16(r *Int16, v0 *Int16, v1 *Int16)

// Signed saturating Doubling Multiply Long. This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, doubles the results, places the final results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqdmullsS32 VqdmullsS32
//go:noescape
func VqdmullsS32(r *Int64, v0 *Int32, v1 *Int32)

// Signed saturating Doubling Multiply Long. This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, doubles the results, places the final results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqdmullhS16 VqdmullhS16
//go:noescape
func VqdmullhS16(r *Int32, v0 *Int16, v1 *Int16)

// Signed saturating Doubling Multiply Long. This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, doubles the results, places the final results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqdmullHighS32 VqdmullHighS32
//go:noescape
func VqdmullHighS32(r *Int64X2, v0 *Int32X4, v1 *Int32X4)

// Signed saturating Doubling Multiply Long. This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, doubles the results, places the final results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqdmullHighS16 VqdmullHighS16
//go:noescape
func VqdmullHighS16(r *Int32X4, v0 *Int16X8, v1 *Int16X8)

// Signed saturating Doubling Multiply Long. This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, doubles the results, places the final results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqdmullHighNS32 VqdmullHighNS32
//go:noescape
func VqdmullHighNS32(r *Int64X2, v0 *Int32X4, v1 *Int32)

// Signed saturating Doubling Multiply Long. This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, doubles the results, places the final results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqdmullHighNS16 VqdmullHighNS16
//go:noescape
func VqdmullHighNS16(r *Int32X4, v0 *Int16X8, v1 *Int16)

// Signed saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates the value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. All the values in this instruction are signed integer values.
//
//go:linkname VqmovnsS32 VqmovnsS32
//go:noescape
func VqmovnsS32(r *Int16, v0 *Int32)

// Signed saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates the value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. All the values in this instruction are signed integer values.
//
//go:linkname VqmovndS64 VqmovndS64
//go:noescape
func VqmovndS64(r *Int32, v0 *Int64)

// Signed saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates the value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. All the values in this instruction are signed integer values.
//
//go:linkname VqmovnhS16 VqmovnhS16
//go:noescape
func VqmovnhS16(r *Int8, v0 *Int16)

// Unsigned saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates each value to half the original width, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
//
//go:linkname VqmovnsU32 VqmovnsU32
//go:noescape
func VqmovnsU32(r *Uint16, v0 *Uint32)

// Unsigned saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates each value to half the original width, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
//
//go:linkname VqmovndU64 VqmovndU64
//go:noescape
func VqmovndU64(r *Uint32, v0 *Uint64)

// Unsigned saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates each value to half the original width, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
//
//go:linkname VqmovnhU16 VqmovnhU16
//go:noescape
func VqmovnhU16(r *Uint8, v0 *Uint16)

// Unsigned saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates each value to half the original width, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
//
//go:linkname VqmovnHighU32 VqmovnHighU32
//go:noescape
func VqmovnHighU32(r *Uint16X8, v0 *Uint16X4, v1 *Uint32X4)

// Unsigned saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates each value to half the original width, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
//
//go:linkname VqmovnHighU64 VqmovnHighU64
//go:noescape
func VqmovnHighU64(r *Uint32X4, v0 *Uint32X2, v1 *Uint64X2)

// Unsigned saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates each value to half the original width, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
//
//go:linkname VqmovnHighU16 VqmovnHighU16
//go:noescape
func VqmovnHighU16(r *Uint8X16, v0 *Uint8X8, v1 *Uint16X8)

// Signed saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates the value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. All the values in this instruction are signed integer values.
//
//go:linkname VqmovnHighS32 VqmovnHighS32
//go:noescape
func VqmovnHighS32(r *Int16X8, v0 *Int16X4, v1 *Int32X4)

// Signed saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates the value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. All the values in this instruction are signed integer values.
//
//go:linkname VqmovnHighS64 VqmovnHighS64
//go:noescape
func VqmovnHighS64(r *Int32X4, v0 *Int32X2, v1 *Int64X2)

// Signed saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates the value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. All the values in this instruction are signed integer values.
//
//go:linkname VqmovnHighS16 VqmovnHighS16
//go:noescape
func VqmovnHighS16(r *Int8X16, v0 *Int8X8, v1 *Int16X8)

// Signed saturating extract Unsigned Narrow. This instruction reads each signed integer value in the vector of the source SIMD&FP register, saturates the value to an unsigned integer value that is half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.
//
//go:linkname VqmovunsS32 VqmovunsS32
//go:noescape
func VqmovunsS32(r *Uint16, v0 *Int32)

// Signed saturating extract Unsigned Narrow. This instruction reads each signed integer value in the vector of the source SIMD&FP register, saturates the value to an unsigned integer value that is half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.
//
//go:linkname VqmovundS64 VqmovundS64
//go:noescape
func VqmovundS64(r *Uint32, v0 *Int64)

// Signed saturating extract Unsigned Narrow. This instruction reads each signed integer value in the vector of the source SIMD&FP register, saturates the value to an unsigned integer value that is half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.
//
//go:linkname VqmovunhS16 VqmovunhS16
//go:noescape
func VqmovunhS16(r *Uint8, v0 *Int16)

// Signed saturating extract Unsigned Narrow. This instruction reads each signed integer value in the vector of the source SIMD&FP register, saturates the value to an unsigned integer value that is half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.
//
//go:linkname VqmovunHighS32 VqmovunHighS32
//go:noescape
func VqmovunHighS32(r *Uint16X8, v0 *Uint16X4, v1 *Int32X4)

// Signed saturating extract Unsigned Narrow. This instruction reads each signed integer value in the vector of the source SIMD&FP register, saturates the value to an unsigned integer value that is half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.
//
//go:linkname VqmovunHighS64 VqmovunHighS64
//go:noescape
func VqmovunHighS64(r *Uint32X4, v0 *Uint32X2, v1 *Int64X2)

// Signed saturating extract Unsigned Narrow. This instruction reads each signed integer value in the vector of the source SIMD&FP register, saturates the value to an unsigned integer value that is half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.
//
//go:linkname VqmovunHighS16 VqmovunHighS16
//go:noescape
func VqmovunHighS16(r *Uint8X16, v0 *Uint8X8, v1 *Int16X8)

// Signed saturating Negate. This instruction reads each vector element from the source SIMD&FP register, negates each value, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqnegqS64 VqnegqS64
//go:noescape
func VqnegqS64(r *Int64X2, v0 *Int64X2)

// Signed saturating Negate. This instruction reads each vector element from the source SIMD&FP register, negates each value, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqnegS64 VqnegS64
//go:noescape
func VqnegS64(r *Int64X1, v0 *Int64X1)

// Signed saturating Negate. This instruction reads each vector element from the source SIMD&FP register, negates each value, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqnegbS8 VqnegbS8
//go:noescape
func VqnegbS8(r *Int8, v0 *Int8)

// Signed saturating Negate. This instruction reads each vector element from the source SIMD&FP register, negates each value, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqnegsS32 VqnegsS32
//go:noescape
func VqnegsS32(r *Int32, v0 *Int32)

// Signed saturating Negate. This instruction reads each vector element from the source SIMD&FP register, negates each value, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqnegdS64 VqnegdS64
//go:noescape
func VqnegdS64(r *Int64, v0 *Int64)

// Signed saturating Negate. This instruction reads each vector element from the source SIMD&FP register, negates each value, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VqneghS16 VqneghS16
//go:noescape
func VqneghS16(r *Int16, v0 *Int16)

// Signed saturating Rounding Doubling Multiply returning High half. This instruction multiplies the values of corresponding elements of the two source SIMD&FP registers, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrdmulhsS32 VqrdmulhsS32
//go:noescape
func VqrdmulhsS32(r *Int32, v0 *Int32, v1 *Int32)

// Signed saturating Rounding Doubling Multiply returning High half. This instruction multiplies the values of corresponding elements of the two source SIMD&FP registers, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrdmulhhS16 VqrdmulhhS16
//go:noescape
func VqrdmulhhS16(r *Int16, v0 *Int16, v1 *Int16)

// Unsigned saturating Rounding Shift Left (register). This instruction takes each vector element of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshlbU8 VqrshlbU8
//go:noescape
func VqrshlbU8(r *Uint8, v0 *Uint8, v1 *Int8)

// Unsigned saturating Rounding Shift Left (register). This instruction takes each vector element of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshlsU32 VqrshlsU32
//go:noescape
func VqrshlsU32(r *Uint32, v0 *Uint32, v1 *Int32)

// Unsigned saturating Rounding Shift Left (register). This instruction takes each vector element of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshldU64 VqrshldU64
//go:noescape
func VqrshldU64(r *Uint64, v0 *Uint64, v1 *Int64)

// Unsigned saturating Rounding Shift Left (register). This instruction takes each vector element of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshlhU16 VqrshlhU16
//go:noescape
func VqrshlhU16(r *Uint16, v0 *Uint16, v1 *Int16)

// Signed saturating Rounding Shift Left (register). This instruction takes each vector element in the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshlbS8 VqrshlbS8
//go:noescape
func VqrshlbS8(r *Int8, v0 *Int8, v1 *Int8)

// Signed saturating Rounding Shift Left (register). This instruction takes each vector element in the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshlsS32 VqrshlsS32
//go:noescape
func VqrshlsS32(r *Int32, v0 *Int32, v1 *Int32)

// Signed saturating Rounding Shift Left (register). This instruction takes each vector element in the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshldS64 VqrshldS64
//go:noescape
func VqrshldS64(r *Int64, v0 *Int64, v1 *Int64)

// Signed saturating Rounding Shift Left (register). This instruction takes each vector element in the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqrshlhS16 VqrshlhS16
//go:noescape
func VqrshlhS16(r *Int16, v0 *Int16, v1 *Int16)

// Unsigned saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshlbU8 VqshlbU8
//go:noescape
func VqshlbU8(r *Uint8, v0 *Uint8, v1 *Int8)

// Unsigned saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshlsU32 VqshlsU32
//go:noescape
func VqshlsU32(r *Uint32, v0 *Uint32, v1 *Int32)

// Unsigned saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshldU64 VqshldU64
//go:noescape
func VqshldU64(r *Uint64, v0 *Uint64, v1 *Int64)

// Unsigned saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshlhU16 VqshlhU16
//go:noescape
func VqshlhU16(r *Uint16, v0 *Uint16, v1 *Int16)

// Signed saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshlbS8 VqshlbS8
//go:noescape
func VqshlbS8(r *Int8, v0 *Int8, v1 *Int8)

// Signed saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshlsS32 VqshlsS32
//go:noescape
func VqshlsS32(r *Int32, v0 *Int32, v1 *Int32)

// Signed saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshldS64 VqshldS64
//go:noescape
func VqshldS64(r *Int64, v0 *Int64, v1 *Int64)

// Signed saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqshlhS16 VqshlhS16
//go:noescape
func VqshlhS16(r *Int16, v0 *Int16, v1 *Int16)

// Unsigned saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubbU8 VqsubbU8
//go:noescape
func VqsubbU8(r *Uint8, v0 *Uint8, v1 *Uint8)

// Unsigned saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubsU32 VqsubsU32
//go:noescape
func VqsubsU32(r *Uint32, v0 *Uint32, v1 *Uint32)

// Unsigned saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubdU64 VqsubdU64
//go:noescape
func VqsubdU64(r *Uint64, v0 *Uint64, v1 *Uint64)

// Unsigned saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubhU16 VqsubhU16
//go:noescape
func VqsubhU16(r *Uint16, v0 *Uint16, v1 *Uint16)

// Signed saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubbS8 VqsubbS8
//go:noescape
func VqsubbS8(r *Int8, v0 *Int8, v1 *Int8)

// Signed saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubsS32 VqsubsS32
//go:noescape
func VqsubsS32(r *Int32, v0 *Int32, v1 *Int32)

// Signed saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubdS64 VqsubdS64
//go:noescape
func VqsubdS64(r *Int64, v0 *Int64, v1 *Int64)

// Signed saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VqsubhS16 VqsubhS16
//go:noescape
func VqsubhS16(r *Int16, v0 *Int16, v1 *Int16)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl1P8 Vqtbl1P8
//go:noescape
func Vqtbl1P8(r *Poly8X8, v0 *Poly8X16, v1 *Uint8X8)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl1QP8 Vqtbl1QP8
//go:noescape
func Vqtbl1QP8(r *Poly8X16, v0 *Poly8X16, v1 *Uint8X16)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl1QU8 Vqtbl1QU8
//go:noescape
func Vqtbl1QU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl1QS8 Vqtbl1QS8
//go:noescape
func Vqtbl1QS8(r *Int8X16, v0 *Int8X16, v1 *Uint8X16)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl1U8 Vqtbl1U8
//go:noescape
func Vqtbl1U8(r *Uint8X8, v0 *Uint8X16, v1 *Uint8X8)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl1S8 Vqtbl1S8
//go:noescape
func Vqtbl1S8(r *Int8X8, v0 *Int8X16, v1 *Uint8X8)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl2P8 Vqtbl2P8
//go:noescape
func Vqtbl2P8(r *Poly8X8, v0 *Poly8X16X2, v1 *Uint8X8)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl2QP8 Vqtbl2QP8
//go:noescape
func Vqtbl2QP8(r *Poly8X16, v0 *Poly8X16X2, v1 *Uint8X16)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl2QU8 Vqtbl2QU8
//go:noescape
func Vqtbl2QU8(r *Uint8X16, v0 *Uint8X16X2, v1 *Uint8X16)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl2QS8 Vqtbl2QS8
//go:noescape
func Vqtbl2QS8(r *Int8X16, v0 *Int8X16X2, v1 *Uint8X16)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl2U8 Vqtbl2U8
//go:noescape
func Vqtbl2U8(r *Uint8X8, v0 *Uint8X16X2, v1 *Uint8X8)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl2S8 Vqtbl2S8
//go:noescape
func Vqtbl2S8(r *Int8X8, v0 *Int8X16X2, v1 *Uint8X8)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl3P8 Vqtbl3P8
//go:noescape
func Vqtbl3P8(r *Poly8X8, v0 *Poly8X16X3, v1 *Uint8X8)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl3QP8 Vqtbl3QP8
//go:noescape
func Vqtbl3QP8(r *Poly8X16, v0 *Poly8X16X3, v1 *Uint8X16)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl3QU8 Vqtbl3QU8
//go:noescape
func Vqtbl3QU8(r *Uint8X16, v0 *Uint8X16X3, v1 *Uint8X16)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl3QS8 Vqtbl3QS8
//go:noescape
func Vqtbl3QS8(r *Int8X16, v0 *Int8X16X3, v1 *Uint8X16)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl3U8 Vqtbl3U8
//go:noescape
func Vqtbl3U8(r *Uint8X8, v0 *Uint8X16X3, v1 *Uint8X8)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl3S8 Vqtbl3S8
//go:noescape
func Vqtbl3S8(r *Int8X8, v0 *Int8X16X3, v1 *Uint8X8)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl4P8 Vqtbl4P8
//go:noescape
func Vqtbl4P8(r *Poly8X8, v0 *Poly8X16X4, v1 *Uint8X8)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl4QP8 Vqtbl4QP8
//go:noescape
func Vqtbl4QP8(r *Poly8X16, v0 *Poly8X16X4, v1 *Uint8X16)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl4QU8 Vqtbl4QU8
//go:noescape
func Vqtbl4QU8(r *Uint8X16, v0 *Uint8X16X4, v1 *Uint8X16)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl4QS8 Vqtbl4QS8
//go:noescape
func Vqtbl4QS8(r *Int8X16, v0 *Int8X16X4, v1 *Uint8X16)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl4U8 Vqtbl4U8
//go:noescape
func Vqtbl4U8(r *Uint8X8, v0 *Uint8X16X4, v1 *Uint8X8)

// Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbl4S8 Vqtbl4S8
//go:noescape
func Vqtbl4S8(r *Int8X8, v0 *Int8X16X4, v1 *Uint8X8)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx1P8 Vqtbx1P8
//go:noescape
func Vqtbx1P8(r *Poly8X8, v0 *Poly8X8, v1 *Poly8X16, v2 *Uint8X8)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx1QP8 Vqtbx1QP8
//go:noescape
func Vqtbx1QP8(r *Poly8X16, v0 *Poly8X16, v1 *Poly8X16, v2 *Uint8X16)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx1QU8 Vqtbx1QU8
//go:noescape
func Vqtbx1QU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16, v2 *Uint8X16)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx1QS8 Vqtbx1QS8
//go:noescape
func Vqtbx1QS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16, v2 *Uint8X16)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx1U8 Vqtbx1U8
//go:noescape
func Vqtbx1U8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X16, v2 *Uint8X8)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx1S8 Vqtbx1S8
//go:noescape
func Vqtbx1S8(r *Int8X8, v0 *Int8X8, v1 *Int8X16, v2 *Uint8X8)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx2P8 Vqtbx2P8
//go:noescape
func Vqtbx2P8(r *Poly8X8, v0 *Poly8X8, v1 *Poly8X16X2, v2 *Uint8X8)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx2QP8 Vqtbx2QP8
//go:noescape
func Vqtbx2QP8(r *Poly8X16, v0 *Poly8X16, v1 *Poly8X16X2, v2 *Uint8X16)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx2QU8 Vqtbx2QU8
//go:noescape
func Vqtbx2QU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16X2, v2 *Uint8X16)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx2QS8 Vqtbx2QS8
//go:noescape
func Vqtbx2QS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16X2, v2 *Uint8X16)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx2U8 Vqtbx2U8
//go:noescape
func Vqtbx2U8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X16X2, v2 *Uint8X8)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx2S8 Vqtbx2S8
//go:noescape
func Vqtbx2S8(r *Int8X8, v0 *Int8X8, v1 *Int8X16X2, v2 *Uint8X8)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx3P8 Vqtbx3P8
//go:noescape
func Vqtbx3P8(r *Poly8X8, v0 *Poly8X8, v1 *Poly8X16X3, v2 *Uint8X8)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx3QP8 Vqtbx3QP8
//go:noescape
func Vqtbx3QP8(r *Poly8X16, v0 *Poly8X16, v1 *Poly8X16X3, v2 *Uint8X16)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx3QU8 Vqtbx3QU8
//go:noescape
func Vqtbx3QU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16X3, v2 *Uint8X16)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx3QS8 Vqtbx3QS8
//go:noescape
func Vqtbx3QS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16X3, v2 *Uint8X16)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx3U8 Vqtbx3U8
//go:noescape
func Vqtbx3U8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X16X3, v2 *Uint8X8)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx3S8 Vqtbx3S8
//go:noescape
func Vqtbx3S8(r *Int8X8, v0 *Int8X8, v1 *Int8X16X3, v2 *Uint8X8)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx4P8 Vqtbx4P8
//go:noescape
func Vqtbx4P8(r *Poly8X8, v0 *Poly8X8, v1 *Poly8X16X4, v2 *Uint8X8)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx4QP8 Vqtbx4QP8
//go:noescape
func Vqtbx4QP8(r *Poly8X16, v0 *Poly8X16, v1 *Poly8X16X4, v2 *Uint8X16)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx4QU8 Vqtbx4QU8
//go:noescape
func Vqtbx4QU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16X4, v2 *Uint8X16)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx4QS8 Vqtbx4QS8
//go:noescape
func Vqtbx4QS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16X4, v2 *Uint8X16)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx4U8 Vqtbx4U8
//go:noescape
func Vqtbx4U8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X16X4, v2 *Uint8X8)

// Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table.
//
//go:linkname Vqtbx4S8 Vqtbx4S8
//go:noescape
func Vqtbx4S8(r *Int8X8, v0 *Int8X8, v1 *Int8X16X4, v2 *Uint8X8)

// Rounding Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VraddhnHighU32 VraddhnHighU32
//go:noescape
func VraddhnHighU32(r *Uint16X8, v0 *Uint16X4, v1 *Uint32X4, v2 *Uint32X4)

// Rounding Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VraddhnHighU64 VraddhnHighU64
//go:noescape
func VraddhnHighU64(r *Uint32X4, v0 *Uint32X2, v1 *Uint64X2, v2 *Uint64X2)

// Rounding Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VraddhnHighU16 VraddhnHighU16
//go:noescape
func VraddhnHighU16(r *Uint8X16, v0 *Uint8X8, v1 *Uint16X8, v2 *Uint16X8)

// Rounding Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VraddhnHighS32 VraddhnHighS32
//go:noescape
func VraddhnHighS32(r *Int16X8, v0 *Int16X4, v1 *Int32X4, v2 *Int32X4)

// Rounding Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VraddhnHighS64 VraddhnHighS64
//go:noescape
func VraddhnHighS64(r *Int32X4, v0 *Int32X2, v1 *Int64X2, v2 *Int64X2)

// Rounding Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VraddhnHighS16 VraddhnHighS16
//go:noescape
func VraddhnHighS16(r *Int8X16, v0 *Int8X8, v1 *Int16X8, v2 *Int16X8)

// Reverse Bit order (vector). This instruction reads each vector element from the source SIMD&FP register, reverses the bits of the element, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrbitP8 VrbitP8
//go:noescape
func VrbitP8(r *Poly8X8, v0 *Poly8X8)

// Reverse Bit order (vector). This instruction reads each vector element from the source SIMD&FP register, reverses the bits of the element, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrbitqP8 VrbitqP8
//go:noescape
func VrbitqP8(r *Poly8X16, v0 *Poly8X16)

// Reverse Bit order (vector). This instruction reads each vector element from the source SIMD&FP register, reverses the bits of the element, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrbitqU8 VrbitqU8
//go:noescape
func VrbitqU8(r *Uint8X16, v0 *Uint8X16)

// Reverse Bit order (vector). This instruction reads each vector element from the source SIMD&FP register, reverses the bits of the element, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrbitqS8 VrbitqS8
//go:noescape
func VrbitqS8(r *Int8X16, v0 *Int8X16)

// Reverse Bit order (vector). This instruction reads each vector element from the source SIMD&FP register, reverses the bits of the element, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrbitU8 VrbitU8
//go:noescape
func VrbitU8(r *Uint8X8, v0 *Uint8X8)

// Reverse Bit order (vector). This instruction reads each vector element from the source SIMD&FP register, reverses the bits of the element, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrbitS8 VrbitS8
//go:noescape
func VrbitS8(r *Int8X8, v0 *Int8X8)

// Floating-point Reciprocal Estimate. This instruction finds an approximate reciprocal estimate for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrecpeqF64 VrecpeqF64
//go:noescape
func VrecpeqF64(r *Float64X2, v0 *Float64X2)

// Floating-point Reciprocal Estimate. This instruction finds an approximate reciprocal estimate for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrecpeF64 VrecpeF64
//go:noescape
func VrecpeF64(r *Float64X1, v0 *Float64X1)

// Floating-point Reciprocal Estimate. This instruction finds an approximate reciprocal estimate for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrecpedF64 VrecpedF64
//go:noescape
func VrecpedF64(r *Float64, v0 *Float64)

// Floating-point Reciprocal Estimate. This instruction finds an approximate reciprocal estimate for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrecpesF32 VrecpesF32
//go:noescape
func VrecpesF32(r *Float32, v0 *Float32)

// Floating-point Reciprocal Step. This instruction multiplies the corresponding floating-point values in the vectors of the two source SIMD&FP registers, subtracts each of the products from 2.0, places the resulting floating-point values in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrecpsqF64 VrecpsqF64
//go:noescape
func VrecpsqF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Floating-point Reciprocal Step. This instruction multiplies the corresponding floating-point values in the vectors of the two source SIMD&FP registers, subtracts each of the products from 2.0, places the resulting floating-point values in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrecpsF64 VrecpsF64
//go:noescape
func VrecpsF64(r *Float64X1, v0 *Float64X1, v1 *Float64X1)

// Floating-point Reciprocal Step. This instruction multiplies the corresponding floating-point values in the vectors of the two source SIMD&FP registers, subtracts each of the products from 2.0, places the resulting floating-point values in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrecpsdF64 VrecpsdF64
//go:noescape
func VrecpsdF64(r *Float64, v0 *Float64, v1 *Float64)

// Floating-point Reciprocal Step. This instruction multiplies the corresponding floating-point values in the vectors of the two source SIMD&FP registers, subtracts each of the products from 2.0, places the resulting floating-point values in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrecpssF32 VrecpssF32
//go:noescape
func VrecpssF32(r *Float32, v0 *Float32, v1 *Float32)

// Floating-point Reciprocal exponent (scalar). This instruction finds an approximate reciprocal exponent for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrecpxdF64 VrecpxdF64
//go:noescape
func VrecpxdF64(r *Float64, v0 *Float64)

// Floating-point Reciprocal exponent (scalar). This instruction finds an approximate reciprocal exponent for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrecpxsF32 VrecpxsF32
//go:noescape
func VrecpxsF32(r *Float32, v0 *Float32)

// Unsigned Rounding Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrshldU64 VrshldU64
//go:noescape
func VrshldU64(r *Uint64, v0 *Uint64, v1 *Int64)

// Signed Rounding Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrshldS64 VrshldS64
//go:noescape
func VrshldS64(r *Int64, v0 *Int64, v1 *Int64)

// Floating-point Reciprocal Square Root Estimate. This instruction calculates an approximate square root for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrsqrteqF64 VrsqrteqF64
//go:noescape
func VrsqrteqF64(r *Float64X2, v0 *Float64X2)

// Floating-point Reciprocal Square Root Estimate. This instruction calculates an approximate square root for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrsqrteF64 VrsqrteF64
//go:noescape
func VrsqrteF64(r *Float64X1, v0 *Float64X1)

// Floating-point Reciprocal Square Root Estimate. This instruction calculates an approximate square root for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrsqrtedF64 VrsqrtedF64
//go:noescape
func VrsqrtedF64(r *Float64, v0 *Float64)

// Floating-point Reciprocal Square Root Estimate. This instruction calculates an approximate square root for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrsqrtesF32 VrsqrtesF32
//go:noescape
func VrsqrtesF32(r *Float32, v0 *Float32)

// Floating-point Reciprocal Square Root Step. This instruction multiplies corresponding floating-point values in the vectors of the two source SIMD&FP registers, subtracts each of the products from 3.0, divides these results by 2.0, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrsqrtsqF64 VrsqrtsqF64
//go:noescape
func VrsqrtsqF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Floating-point Reciprocal Square Root Step. This instruction multiplies corresponding floating-point values in the vectors of the two source SIMD&FP registers, subtracts each of the products from 3.0, divides these results by 2.0, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrsqrtsF64 VrsqrtsF64
//go:noescape
func VrsqrtsF64(r *Float64X1, v0 *Float64X1, v1 *Float64X1)

// Floating-point Reciprocal Square Root Step. This instruction multiplies corresponding floating-point values in the vectors of the two source SIMD&FP registers, subtracts each of the products from 3.0, divides these results by 2.0, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrsqrtsdF64 VrsqrtsdF64
//go:noescape
func VrsqrtsdF64(r *Float64, v0 *Float64, v1 *Float64)

// Floating-point Reciprocal Square Root Step. This instruction multiplies corresponding floating-point values in the vectors of the two source SIMD&FP registers, subtracts each of the products from 3.0, divides these results by 2.0, places the results into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VrsqrtssF32 VrsqrtssF32
//go:noescape
func VrsqrtssF32(r *Float32, v0 *Float32, v1 *Float32)

// Rounding Subtract returning High Narrow. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VrsubhnHighU32 VrsubhnHighU32
//go:noescape
func VrsubhnHighU32(r *Uint16X8, v0 *Uint16X4, v1 *Uint32X4, v2 *Uint32X4)

// Rounding Subtract returning High Narrow. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VrsubhnHighU64 VrsubhnHighU64
//go:noescape
func VrsubhnHighU64(r *Uint32X4, v0 *Uint32X2, v1 *Uint64X2, v2 *Uint64X2)

// Rounding Subtract returning High Narrow. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VrsubhnHighU16 VrsubhnHighU16
//go:noescape
func VrsubhnHighU16(r *Uint8X16, v0 *Uint8X8, v1 *Uint16X8, v2 *Uint16X8)

// Rounding Subtract returning High Narrow. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VrsubhnHighS32 VrsubhnHighS32
//go:noescape
func VrsubhnHighS32(r *Int16X8, v0 *Int16X4, v1 *Int32X4, v2 *Int32X4)

// Rounding Subtract returning High Narrow. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VrsubhnHighS64 VrsubhnHighS64
//go:noescape
func VrsubhnHighS64(r *Int32X4, v0 *Int32X2, v1 *Int64X2, v2 *Int64X2)

// Rounding Subtract returning High Narrow. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
//
//go:linkname VrsubhnHighS16 VrsubhnHighS16
//go:noescape
func VrsubhnHighS16(r *Int8X16, v0 *Int8X8, v1 *Int16X8, v2 *Int16X8)

// Unsigned Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VshldU64 VshldU64
//go:noescape
func VshldU64(r *Uint64, v0 *Uint64, v1 *Int64)

// Signed Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts each value by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VshldS64 VshldS64
//go:noescape
func VshldS64(r *Int64, v0 *Int64, v1 *Int64)

// Unsigned saturating Accumulate of Signed value. This instruction adds the signed integer values of the vector elements in the source SIMD&FP register to corresponding unsigned integer values of the vector elements in the destination SIMD&FP register, and accumulates the resulting unsigned integer values with the vector elements of the destination SIMD&FP register.
//
//go:linkname VsqaddbU8 VsqaddbU8
//go:noescape
func VsqaddbU8(r *Uint8, v0 *Uint8, v1 *Int8)

// Unsigned saturating Accumulate of Signed value. This instruction adds the signed integer values of the vector elements in the source SIMD&FP register to corresponding unsigned integer values of the vector elements in the destination SIMD&FP register, and accumulates the resulting unsigned integer values with the vector elements of the destination SIMD&FP register.
//
//go:linkname VsqaddsU32 VsqaddsU32
//go:noescape
func VsqaddsU32(r *Uint32, v0 *Uint32, v1 *Int32)

// Unsigned saturating Accumulate of Signed value. This instruction adds the signed integer values of the vector elements in the source SIMD&FP register to corresponding unsigned integer values of the vector elements in the destination SIMD&FP register, and accumulates the resulting unsigned integer values with the vector elements of the destination SIMD&FP register.
//
//go:linkname VsqadddU64 VsqadddU64
//go:noescape
func VsqadddU64(r *Uint64, v0 *Uint64, v1 *Int64)

// Unsigned saturating Accumulate of Signed value. This instruction adds the signed integer values of the vector elements in the source SIMD&FP register to corresponding unsigned integer values of the vector elements in the destination SIMD&FP register, and accumulates the resulting unsigned integer values with the vector elements of the destination SIMD&FP register.
//
//go:linkname VsqaddhU16 VsqaddhU16
//go:noescape
func VsqaddhU16(r *Uint16, v0 *Uint16, v1 *Int16)

// Unsigned saturating Accumulate of Signed value. This instruction adds the signed integer values of the vector elements in the source SIMD&FP register to corresponding unsigned integer values of the vector elements in the destination SIMD&FP register, and accumulates the resulting unsigned integer values with the vector elements of the destination SIMD&FP register.
//
//go:linkname VsqaddqU8 VsqaddqU8
//go:noescape
func VsqaddqU8(r *Uint8X16, v0 *Uint8X16, v1 *Int8X16)

// Unsigned saturating Accumulate of Signed value. This instruction adds the signed integer values of the vector elements in the source SIMD&FP register to corresponding unsigned integer values of the vector elements in the destination SIMD&FP register, and accumulates the resulting unsigned integer values with the vector elements of the destination SIMD&FP register.
//
//go:linkname VsqaddqU32 VsqaddqU32
//go:noescape
func VsqaddqU32(r *Uint32X4, v0 *Uint32X4, v1 *Int32X4)

// Unsigned saturating Accumulate of Signed value. This instruction adds the signed integer values of the vector elements in the source SIMD&FP register to corresponding unsigned integer values of the vector elements in the destination SIMD&FP register, and accumulates the resulting unsigned integer values with the vector elements of the destination SIMD&FP register.
//
//go:linkname VsqaddqU64 VsqaddqU64
//go:noescape
func VsqaddqU64(r *Uint64X2, v0 *Uint64X2, v1 *Int64X2)

// Unsigned saturating Accumulate of Signed value. This instruction adds the signed integer values of the vector elements in the source SIMD&FP register to corresponding unsigned integer values of the vector elements in the destination SIMD&FP register, and accumulates the resulting unsigned integer values with the vector elements of the destination SIMD&FP register.
//
//go:linkname VsqaddqU16 VsqaddqU16
//go:noescape
func VsqaddqU16(r *Uint16X8, v0 *Uint16X8, v1 *Int16X8)

// Unsigned saturating Accumulate of Signed value. This instruction adds the signed integer values of the vector elements in the source SIMD&FP register to corresponding unsigned integer values of the vector elements in the destination SIMD&FP register, and accumulates the resulting unsigned integer values with the vector elements of the destination SIMD&FP register.
//
//go:linkname VsqaddU8 VsqaddU8
//go:noescape
func VsqaddU8(r *Uint8X8, v0 *Uint8X8, v1 *Int8X8)

// Unsigned saturating Accumulate of Signed value. This instruction adds the signed integer values of the vector elements in the source SIMD&FP register to corresponding unsigned integer values of the vector elements in the destination SIMD&FP register, and accumulates the resulting unsigned integer values with the vector elements of the destination SIMD&FP register.
//
//go:linkname VsqaddU32 VsqaddU32
//go:noescape
func VsqaddU32(r *Uint32X2, v0 *Uint32X2, v1 *Int32X2)

// Unsigned saturating Accumulate of Signed value. This instruction adds the signed integer values of the vector elements in the source SIMD&FP register to corresponding unsigned integer values of the vector elements in the destination SIMD&FP register, and accumulates the resulting unsigned integer values with the vector elements of the destination SIMD&FP register.
//
//go:linkname VsqaddU64 VsqaddU64
//go:noescape
func VsqaddU64(r *Uint64X1, v0 *Uint64X1, v1 *Int64X1)

// Unsigned saturating Accumulate of Signed value. This instruction adds the signed integer values of the vector elements in the source SIMD&FP register to corresponding unsigned integer values of the vector elements in the destination SIMD&FP register, and accumulates the resulting unsigned integer values with the vector elements of the destination SIMD&FP register.
//
//go:linkname VsqaddU16 VsqaddU16
//go:noescape
func VsqaddU16(r *Uint16X4, v0 *Uint16X4, v1 *Int16X4)

// Floating-point Square Root (vector). This instruction calculates the square root for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsqrtqF64 VsqrtqF64
//go:noescape
func VsqrtqF64(r *Float64X2, v0 *Float64X2)

// Floating-point Square Root (vector). This instruction calculates the square root for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsqrtqF32 VsqrtqF32
//go:noescape
func VsqrtqF32(r *Float32X4, v0 *Float32X4)

// Floating-point Square Root (vector). This instruction calculates the square root for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsqrtF64 VsqrtF64
//go:noescape
func VsqrtF64(r *Float64X1, v0 *Float64X1)

// Floating-point Square Root (vector). This instruction calculates the square root for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsqrtF32 VsqrtF32
//go:noescape
func VsqrtF32(r *Float32X2, v0 *Float32X2)

// Subtract (vector). This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsubdU64 VsubdU64
//go:noescape
func VsubdU64(r *Uint64, v0 *Uint64, v1 *Uint64)

// Subtract (vector). This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsubdS64 VsubdS64
//go:noescape
func VsubdS64(r *Int64, v0 *Int64, v1 *Int64)

// Floating-point Subtract (vector). This instruction subtracts the elements in the vector in the second source SIMD&FP register, from the corresponding elements in the vector in the first source SIMD&FP register, places each result into elements of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsubqF64 VsubqF64
//go:noescape
func VsubqF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Floating-point Subtract (vector). This instruction subtracts the elements in the vector in the second source SIMD&FP register, from the corresponding elements in the vector in the first source SIMD&FP register, places each result into elements of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname VsubF64 VsubF64
//go:noescape
func VsubF64(r *Float64X1, v0 *Float64X1, v1 *Float64X1)

// Subtract returning High Narrow. This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VsubhnHighU32 VsubhnHighU32
//go:noescape
func VsubhnHighU32(r *Uint16X8, v0 *Uint16X4, v1 *Uint32X4, v2 *Uint32X4)

// Subtract returning High Narrow. This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VsubhnHighU64 VsubhnHighU64
//go:noescape
func VsubhnHighU64(r *Uint32X4, v0 *Uint32X2, v1 *Uint64X2, v2 *Uint64X2)

// Subtract returning High Narrow. This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VsubhnHighU16 VsubhnHighU16
//go:noescape
func VsubhnHighU16(r *Uint8X16, v0 *Uint8X8, v1 *Uint16X8, v2 *Uint16X8)

// Subtract returning High Narrow. This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VsubhnHighS32 VsubhnHighS32
//go:noescape
func VsubhnHighS32(r *Int16X8, v0 *Int16X4, v1 *Int32X4, v2 *Int32X4)

// Subtract returning High Narrow. This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VsubhnHighS64 VsubhnHighS64
//go:noescape
func VsubhnHighS64(r *Int32X4, v0 *Int32X2, v1 *Int64X2, v2 *Int64X2)

// Subtract returning High Narrow. This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values.
//
//go:linkname VsubhnHighS16 VsubhnHighS16
//go:noescape
func VsubhnHighS16(r *Int8X16, v0 *Int8X8, v1 *Int16X8, v2 *Int16X8)

// Unsigned Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VsublHighU8 VsublHighU8
//go:noescape
func VsublHighU8(r *Uint16X8, v0 *Uint8X16, v1 *Uint8X16)

// Unsigned Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VsublHighU32 VsublHighU32
//go:noescape
func VsublHighU32(r *Uint64X2, v0 *Uint32X4, v1 *Uint32X4)

// Unsigned Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VsublHighU16 VsublHighU16
//go:noescape
func VsublHighU16(r *Uint32X4, v0 *Uint16X8, v1 *Uint16X8)

// Signed Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VsublHighS8 VsublHighS8
//go:noescape
func VsublHighS8(r *Int16X8, v0 *Int8X16, v1 *Int8X16)

// Signed Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VsublHighS32 VsublHighS32
//go:noescape
func VsublHighS32(r *Int64X2, v0 *Int32X4, v1 *Int32X4)

// Signed Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VsublHighS16 VsublHighS16
//go:noescape
func VsublHighS16(r *Int32X4, v0 *Int16X8, v1 *Int16X8)

// Unsigned Subtract Wide. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element in the lower or upper half of the first source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. All the values in this instruction are signed integer values.
//
//go:linkname VsubwHighU8 VsubwHighU8
//go:noescape
func VsubwHighU8(r *Uint16X8, v0 *Uint16X8, v1 *Uint8X16)

// Unsigned Subtract Wide. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element in the lower or upper half of the first source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. All the values in this instruction are signed integer values.
//
//go:linkname VsubwHighU32 VsubwHighU32
//go:noescape
func VsubwHighU32(r *Uint64X2, v0 *Uint64X2, v1 *Uint32X4)

// Unsigned Subtract Wide. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element in the lower or upper half of the first source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. All the values in this instruction are signed integer values.
//
//go:linkname VsubwHighU16 VsubwHighU16
//go:noescape
func VsubwHighU16(r *Uint32X4, v0 *Uint32X4, v1 *Uint16X8)

// Signed Subtract Wide. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. All the values in this instruction are signed integer values.
//
//go:linkname VsubwHighS8 VsubwHighS8
//go:noescape
func VsubwHighS8(r *Int16X8, v0 *Int16X8, v1 *Int8X16)

// Signed Subtract Wide. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. All the values in this instruction are signed integer values.
//
//go:linkname VsubwHighS32 VsubwHighS32
//go:noescape
func VsubwHighS32(r *Int64X2, v0 *Int64X2, v1 *Int32X4)

// Signed Subtract Wide. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. All the values in this instruction are signed integer values.
//
//go:linkname VsubwHighS16 VsubwHighS16
//go:noescape
func VsubwHighS16(r *Int32X4, v0 *Int32X4, v1 *Int16X8)

// Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn1P8 Vtrn1P8
//go:noescape
func Vtrn1P8(r *Poly8X8, v0 *Poly8X8, v1 *Poly8X8)

// Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn1P16 Vtrn1P16
//go:noescape
func Vtrn1P16(r *Poly16X4, v0 *Poly16X4, v1 *Poly16X4)

// Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn1QP8 Vtrn1QP8
//go:noescape
func Vtrn1QP8(r *Poly8X16, v0 *Poly8X16, v1 *Poly8X16)

// Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn1QP64 Vtrn1QP64
//go:noescape
func Vtrn1QP64(r *Poly64X2, v0 *Poly64X2, v1 *Poly64X2)

// Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn1QP16 Vtrn1QP16
//go:noescape
func Vtrn1QP16(r *Poly16X8, v0 *Poly16X8, v1 *Poly16X8)

// Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn1QU8 Vtrn1QU8
//go:noescape
func Vtrn1QU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn1QU32 Vtrn1QU32
//go:noescape
func Vtrn1QU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn1QU64 Vtrn1QU64
//go:noescape
func Vtrn1QU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn1QU16 Vtrn1QU16
//go:noescape
func Vtrn1QU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn1QS8 Vtrn1QS8
//go:noescape
func Vtrn1QS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn1QF64 Vtrn1QF64
//go:noescape
func Vtrn1QF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn1QF32 Vtrn1QF32
//go:noescape
func Vtrn1QF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn1QS32 Vtrn1QS32
//go:noescape
func Vtrn1QS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn1QS64 Vtrn1QS64
//go:noescape
func Vtrn1QS64(r *Int64X2, v0 *Int64X2, v1 *Int64X2)

// Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn1QS16 Vtrn1QS16
//go:noescape
func Vtrn1QS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn1U8 Vtrn1U8
//go:noescape
func Vtrn1U8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn1U32 Vtrn1U32
//go:noescape
func Vtrn1U32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn1U16 Vtrn1U16
//go:noescape
func Vtrn1U16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn1S8 Vtrn1S8
//go:noescape
func Vtrn1S8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn1F32 Vtrn1F32
//go:noescape
func Vtrn1F32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn1S32 Vtrn1S32
//go:noescape
func Vtrn1S32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn1S16 Vtrn1S16
//go:noescape
func Vtrn1S16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn2P8 Vtrn2P8
//go:noescape
func Vtrn2P8(r *Poly8X8, v0 *Poly8X8, v1 *Poly8X8)

// Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn2P16 Vtrn2P16
//go:noescape
func Vtrn2P16(r *Poly16X4, v0 *Poly16X4, v1 *Poly16X4)

// Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn2QP8 Vtrn2QP8
//go:noescape
func Vtrn2QP8(r *Poly8X16, v0 *Poly8X16, v1 *Poly8X16)

// Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn2QP64 Vtrn2QP64
//go:noescape
func Vtrn2QP64(r *Poly64X2, v0 *Poly64X2, v1 *Poly64X2)

// Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn2QP16 Vtrn2QP16
//go:noescape
func Vtrn2QP16(r *Poly16X8, v0 *Poly16X8, v1 *Poly16X8)

// Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn2QU8 Vtrn2QU8
//go:noescape
func Vtrn2QU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn2QU32 Vtrn2QU32
//go:noescape
func Vtrn2QU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn2QU64 Vtrn2QU64
//go:noescape
func Vtrn2QU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn2QU16 Vtrn2QU16
//go:noescape
func Vtrn2QU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn2QS8 Vtrn2QS8
//go:noescape
func Vtrn2QS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn2QF64 Vtrn2QF64
//go:noescape
func Vtrn2QF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn2QF32 Vtrn2QF32
//go:noescape
func Vtrn2QF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn2QS32 Vtrn2QS32
//go:noescape
func Vtrn2QS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn2QS64 Vtrn2QS64
//go:noescape
func Vtrn2QS64(r *Int64X2, v0 *Int64X2, v1 *Int64X2)

// Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn2QS16 Vtrn2QS16
//go:noescape
func Vtrn2QS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn2U8 Vtrn2U8
//go:noescape
func Vtrn2U8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn2U32 Vtrn2U32
//go:noescape
func Vtrn2U32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn2U16 Vtrn2U16
//go:noescape
func Vtrn2U16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn2S8 Vtrn2S8
//go:noescape
func Vtrn2S8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn2F32 Vtrn2F32
//go:noescape
func Vtrn2F32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn2S32 Vtrn2S32
//go:noescape
func Vtrn2S32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.
//
//go:linkname Vtrn2S16 Vtrn2S16
//go:noescape
func Vtrn2S16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VtstP64 VtstP64
//go:noescape
func VtstP64(r *Uint64X1, v0 *Poly64X1, v1 *Poly64X1)

// Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VtstqP64 VtstqP64
//go:noescape
func VtstqP64(r *Uint64X2, v0 *Poly64X2, v1 *Poly64X2)

// Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VtstqU64 VtstqU64
//go:noescape
func VtstqU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VtstqS64 VtstqS64
//go:noescape
func VtstqS64(r *Uint64X2, v0 *Int64X2, v1 *Int64X2)

// Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VtstU64 VtstU64
//go:noescape
func VtstU64(r *Uint64X1, v0 *Uint64X1, v1 *Uint64X1)

// Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VtstS64 VtstS64
//go:noescape
func VtstS64(r *Uint64X1, v0 *Int64X1, v1 *Int64X1)

// Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VtstdU64 VtstdU64
//go:noescape
func VtstdU64(r *Uint64, v0 *Uint64, v1 *Uint64)

// Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
//
//go:linkname VtstdS64 VtstdS64
//go:noescape
func VtstdS64(r *Uint64, v0 *Int64, v1 *Int64)

// Signed saturating Accumulate of Unsigned value. This instruction adds the unsigned integer values of the vector elements in the source SIMD&FP register to corresponding signed integer values of the vector elements in the destination SIMD&FP register, and writes the resulting signed integer values to the destination SIMD&FP register.
//
//go:linkname VuqaddbS8 VuqaddbS8
//go:noescape
func VuqaddbS8(r *Int8, v0 *Int8, v1 *Uint8)

// Signed saturating Accumulate of Unsigned value. This instruction adds the unsigned integer values of the vector elements in the source SIMD&FP register to corresponding signed integer values of the vector elements in the destination SIMD&FP register, and writes the resulting signed integer values to the destination SIMD&FP register.
//
//go:linkname VuqaddsS32 VuqaddsS32
//go:noescape
func VuqaddsS32(r *Int32, v0 *Int32, v1 *Uint32)

// Signed saturating Accumulate of Unsigned value. This instruction adds the unsigned integer values of the vector elements in the source SIMD&FP register to corresponding signed integer values of the vector elements in the destination SIMD&FP register, and writes the resulting signed integer values to the destination SIMD&FP register.
//
//go:linkname VuqadddS64 VuqadddS64
//go:noescape
func VuqadddS64(r *Int64, v0 *Int64, v1 *Uint64)

// Signed saturating Accumulate of Unsigned value. This instruction adds the unsigned integer values of the vector elements in the source SIMD&FP register to corresponding signed integer values of the vector elements in the destination SIMD&FP register, and writes the resulting signed integer values to the destination SIMD&FP register.
//
//go:linkname VuqaddhS16 VuqaddhS16
//go:noescape
func VuqaddhS16(r *Int16, v0 *Int16, v1 *Uint16)

// Signed saturating Accumulate of Unsigned value. This instruction adds the unsigned integer values of the vector elements in the source SIMD&FP register to corresponding signed integer values of the vector elements in the destination SIMD&FP register, and writes the resulting signed integer values to the destination SIMD&FP register.
//
//go:linkname VuqaddqS8 VuqaddqS8
//go:noescape
func VuqaddqS8(r *Int8X16, v0 *Int8X16, v1 *Uint8X16)

// Signed saturating Accumulate of Unsigned value. This instruction adds the unsigned integer values of the vector elements in the source SIMD&FP register to corresponding signed integer values of the vector elements in the destination SIMD&FP register, and writes the resulting signed integer values to the destination SIMD&FP register.
//
//go:linkname VuqaddqS32 VuqaddqS32
//go:noescape
func VuqaddqS32(r *Int32X4, v0 *Int32X4, v1 *Uint32X4)

// Signed saturating Accumulate of Unsigned value. This instruction adds the unsigned integer values of the vector elements in the source SIMD&FP register to corresponding signed integer values of the vector elements in the destination SIMD&FP register, and writes the resulting signed integer values to the destination SIMD&FP register.
//
//go:linkname VuqaddqS64 VuqaddqS64
//go:noescape
func VuqaddqS64(r *Int64X2, v0 *Int64X2, v1 *Uint64X2)

// Signed saturating Accumulate of Unsigned value. This instruction adds the unsigned integer values of the vector elements in the source SIMD&FP register to corresponding signed integer values of the vector elements in the destination SIMD&FP register, and writes the resulting signed integer values to the destination SIMD&FP register.
//
//go:linkname VuqaddqS16 VuqaddqS16
//go:noescape
func VuqaddqS16(r *Int16X8, v0 *Int16X8, v1 *Uint16X8)

// Signed saturating Accumulate of Unsigned value. This instruction adds the unsigned integer values of the vector elements in the source SIMD&FP register to corresponding signed integer values of the vector elements in the destination SIMD&FP register, and writes the resulting signed integer values to the destination SIMD&FP register.
//
//go:linkname VuqaddS8 VuqaddS8
//go:noescape
func VuqaddS8(r *Int8X8, v0 *Int8X8, v1 *Uint8X8)

// Signed saturating Accumulate of Unsigned value. This instruction adds the unsigned integer values of the vector elements in the source SIMD&FP register to corresponding signed integer values of the vector elements in the destination SIMD&FP register, and writes the resulting signed integer values to the destination SIMD&FP register.
//
//go:linkname VuqaddS32 VuqaddS32
//go:noescape
func VuqaddS32(r *Int32X2, v0 *Int32X2, v1 *Uint32X2)

// Signed saturating Accumulate of Unsigned value. This instruction adds the unsigned integer values of the vector elements in the source SIMD&FP register to corresponding signed integer values of the vector elements in the destination SIMD&FP register, and writes the resulting signed integer values to the destination SIMD&FP register.
//
//go:linkname VuqaddS64 VuqaddS64
//go:noescape
func VuqaddS64(r *Int64X1, v0 *Int64X1, v1 *Uint64X1)

// Signed saturating Accumulate of Unsigned value. This instruction adds the unsigned integer values of the vector elements in the source SIMD&FP register to corresponding signed integer values of the vector elements in the destination SIMD&FP register, and writes the resulting signed integer values to the destination SIMD&FP register.
//
//go:linkname VuqaddS16 VuqaddS16
//go:noescape
func VuqaddS16(r *Int16X4, v0 *Int16X4, v1 *Uint16X4)

// Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp1P8 Vuzp1P8
//go:noescape
func Vuzp1P8(r *Poly8X8, v0 *Poly8X8, v1 *Poly8X8)

// Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp1P16 Vuzp1P16
//go:noescape
func Vuzp1P16(r *Poly16X4, v0 *Poly16X4, v1 *Poly16X4)

// Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp1QP8 Vuzp1QP8
//go:noescape
func Vuzp1QP8(r *Poly8X16, v0 *Poly8X16, v1 *Poly8X16)

// Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp1QP64 Vuzp1QP64
//go:noescape
func Vuzp1QP64(r *Poly64X2, v0 *Poly64X2, v1 *Poly64X2)

// Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp1QP16 Vuzp1QP16
//go:noescape
func Vuzp1QP16(r *Poly16X8, v0 *Poly16X8, v1 *Poly16X8)

// Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp1QU8 Vuzp1QU8
//go:noescape
func Vuzp1QU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp1QU32 Vuzp1QU32
//go:noescape
func Vuzp1QU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp1QU64 Vuzp1QU64
//go:noescape
func Vuzp1QU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp1QU16 Vuzp1QU16
//go:noescape
func Vuzp1QU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp1QS8 Vuzp1QS8
//go:noescape
func Vuzp1QS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp1QF64 Vuzp1QF64
//go:noescape
func Vuzp1QF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp1QF32 Vuzp1QF32
//go:noescape
func Vuzp1QF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp1QS32 Vuzp1QS32
//go:noescape
func Vuzp1QS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp1QS64 Vuzp1QS64
//go:noescape
func Vuzp1QS64(r *Int64X2, v0 *Int64X2, v1 *Int64X2)

// Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp1QS16 Vuzp1QS16
//go:noescape
func Vuzp1QS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp1U8 Vuzp1U8
//go:noescape
func Vuzp1U8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp1U32 Vuzp1U32
//go:noescape
func Vuzp1U32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp1U16 Vuzp1U16
//go:noescape
func Vuzp1U16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp1S8 Vuzp1S8
//go:noescape
func Vuzp1S8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp1F32 Vuzp1F32
//go:noescape
func Vuzp1F32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp1S32 Vuzp1S32
//go:noescape
func Vuzp1S32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp1S16 Vuzp1S16
//go:noescape
func Vuzp1S16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp2P8 Vuzp2P8
//go:noescape
func Vuzp2P8(r *Poly8X8, v0 *Poly8X8, v1 *Poly8X8)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp2P16 Vuzp2P16
//go:noescape
func Vuzp2P16(r *Poly16X4, v0 *Poly16X4, v1 *Poly16X4)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp2QP8 Vuzp2QP8
//go:noescape
func Vuzp2QP8(r *Poly8X16, v0 *Poly8X16, v1 *Poly8X16)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp2QP64 Vuzp2QP64
//go:noescape
func Vuzp2QP64(r *Poly64X2, v0 *Poly64X2, v1 *Poly64X2)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp2QP16 Vuzp2QP16
//go:noescape
func Vuzp2QP16(r *Poly16X8, v0 *Poly16X8, v1 *Poly16X8)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp2QU8 Vuzp2QU8
//go:noescape
func Vuzp2QU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp2QU32 Vuzp2QU32
//go:noescape
func Vuzp2QU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp2QU64 Vuzp2QU64
//go:noescape
func Vuzp2QU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp2QU16 Vuzp2QU16
//go:noescape
func Vuzp2QU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp2QS8 Vuzp2QS8
//go:noescape
func Vuzp2QS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp2QF64 Vuzp2QF64
//go:noescape
func Vuzp2QF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp2QF32 Vuzp2QF32
//go:noescape
func Vuzp2QF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp2QS32 Vuzp2QS32
//go:noescape
func Vuzp2QS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp2QS64 Vuzp2QS64
//go:noescape
func Vuzp2QS64(r *Int64X2, v0 *Int64X2, v1 *Int64X2)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp2QS16 Vuzp2QS16
//go:noescape
func Vuzp2QS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp2U8 Vuzp2U8
//go:noescape
func Vuzp2U8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp2U32 Vuzp2U32
//go:noescape
func Vuzp2U32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp2U16 Vuzp2U16
//go:noescape
func Vuzp2U16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp2S8 Vuzp2S8
//go:noescape
func Vuzp2S8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp2F32 Vuzp2F32
//go:noescape
func Vuzp2F32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp2S32 Vuzp2S32
//go:noescape
func Vuzp2S32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.
//
//go:linkname Vuzp2S16 Vuzp2S16
//go:noescape
func Vuzp2S16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip1P8 Vzip1P8
//go:noescape
func Vzip1P8(r *Poly8X8, v0 *Poly8X8, v1 *Poly8X8)

// Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip1P16 Vzip1P16
//go:noescape
func Vzip1P16(r *Poly16X4, v0 *Poly16X4, v1 *Poly16X4)

// Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip1QP8 Vzip1QP8
//go:noescape
func Vzip1QP8(r *Poly8X16, v0 *Poly8X16, v1 *Poly8X16)

// Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip1QP64 Vzip1QP64
//go:noescape
func Vzip1QP64(r *Poly64X2, v0 *Poly64X2, v1 *Poly64X2)

// Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip1QP16 Vzip1QP16
//go:noescape
func Vzip1QP16(r *Poly16X8, v0 *Poly16X8, v1 *Poly16X8)

// Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip1QU8 Vzip1QU8
//go:noescape
func Vzip1QU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip1QU32 Vzip1QU32
//go:noescape
func Vzip1QU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip1QU64 Vzip1QU64
//go:noescape
func Vzip1QU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip1QU16 Vzip1QU16
//go:noescape
func Vzip1QU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip1QS8 Vzip1QS8
//go:noescape
func Vzip1QS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip1QF64 Vzip1QF64
//go:noescape
func Vzip1QF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip1QF32 Vzip1QF32
//go:noescape
func Vzip1QF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip1QS32 Vzip1QS32
//go:noescape
func Vzip1QS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip1QS64 Vzip1QS64
//go:noescape
func Vzip1QS64(r *Int64X2, v0 *Int64X2, v1 *Int64X2)

// Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip1QS16 Vzip1QS16
//go:noescape
func Vzip1QS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip1U8 Vzip1U8
//go:noescape
func Vzip1U8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip1U32 Vzip1U32
//go:noescape
func Vzip1U32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip1U16 Vzip1U16
//go:noescape
func Vzip1U16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip1S8 Vzip1S8
//go:noescape
func Vzip1S8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip1F32 Vzip1F32
//go:noescape
func Vzip1F32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip1S32 Vzip1S32
//go:noescape
func Vzip1S32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip1S16 Vzip1S16
//go:noescape
func Vzip1S16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip2P8 Vzip2P8
//go:noescape
func Vzip2P8(r *Poly8X8, v0 *Poly8X8, v1 *Poly8X8)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip2P16 Vzip2P16
//go:noescape
func Vzip2P16(r *Poly16X4, v0 *Poly16X4, v1 *Poly16X4)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip2QP8 Vzip2QP8
//go:noescape
func Vzip2QP8(r *Poly8X16, v0 *Poly8X16, v1 *Poly8X16)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip2QP64 Vzip2QP64
//go:noescape
func Vzip2QP64(r *Poly64X2, v0 *Poly64X2, v1 *Poly64X2)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip2QP16 Vzip2QP16
//go:noescape
func Vzip2QP16(r *Poly16X8, v0 *Poly16X8, v1 *Poly16X8)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip2QU8 Vzip2QU8
//go:noescape
func Vzip2QU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip2QU32 Vzip2QU32
//go:noescape
func Vzip2QU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip2QU64 Vzip2QU64
//go:noescape
func Vzip2QU64(r *Uint64X2, v0 *Uint64X2, v1 *Uint64X2)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip2QU16 Vzip2QU16
//go:noescape
func Vzip2QU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip2QS8 Vzip2QS8
//go:noescape
func Vzip2QS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip2QF64 Vzip2QF64
//go:noescape
func Vzip2QF64(r *Float64X2, v0 *Float64X2, v1 *Float64X2)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip2QF32 Vzip2QF32
//go:noescape
func Vzip2QF32(r *Float32X4, v0 *Float32X4, v1 *Float32X4)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip2QS32 Vzip2QS32
//go:noescape
func Vzip2QS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip2QS64 Vzip2QS64
//go:noescape
func Vzip2QS64(r *Int64X2, v0 *Int64X2, v1 *Int64X2)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip2QS16 Vzip2QS16
//go:noescape
func Vzip2QS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip2U8 Vzip2U8
//go:noescape
func Vzip2U8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip2U32 Vzip2U32
//go:noescape
func Vzip2U32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip2U16 Vzip2U16
//go:noescape
func Vzip2U16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip2S8 Vzip2S8
//go:noescape
func Vzip2S8(r *Int8X8, v0 *Int8X8, v1 *Int8X8)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip2F32 Vzip2F32
//go:noescape
func Vzip2F32(r *Float32X2, v0 *Float32X2, v1 *Float32X2)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip2S32 Vzip2S32
//go:noescape
func Vzip2S32(r *Int32X2, v0 *Int32X2, v1 *Int32X2)

// Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.
//
//go:linkname Vzip2S16 Vzip2S16
//go:noescape
func Vzip2S16(r *Int16X4, v0 *Int16X4, v1 *Int16X4)

// Unsigned Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&FP register.
//
//go:linkname VabaqU8 VabaqU8
//go:noescape
func VabaqU8(r *Uint8X16, v0 *Uint8X16, v1 *Uint8X16, v2 *Uint8X16)

// Unsigned Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&FP register.
//
//go:linkname VabaqU32 VabaqU32
//go:noescape
func VabaqU32(r *Uint32X4, v0 *Uint32X4, v1 *Uint32X4, v2 *Uint32X4)

// Unsigned Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&FP register.
//
//go:linkname VabaqU16 VabaqU16
//go:noescape
func VabaqU16(r *Uint16X8, v0 *Uint16X8, v1 *Uint16X8, v2 *Uint16X8)

// Signed Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&FP register.
//
//go:linkname VabaqS8 VabaqS8
//go:noescape
func VabaqS8(r *Int8X16, v0 *Int8X16, v1 *Int8X16, v2 *Int8X16)

// Signed Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&FP register.
//
//go:linkname VabaqS32 VabaqS32
//go:noescape
func VabaqS32(r *Int32X4, v0 *Int32X4, v1 *Int32X4, v2 *Int32X4)

// Signed Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&FP register.
//
//go:linkname VabaqS16 VabaqS16
//go:noescape
func VabaqS16(r *Int16X8, v0 *Int16X8, v1 *Int16X8, v2 *Int16X8)

// Unsigned Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&FP register.
//
//go:linkname VabaU8 VabaU8
//go:noescape
func VabaU8(r *Uint8X8, v0 *Uint8X8, v1 *Uint8X8, v2 *Uint8X8)

// Unsigned Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&FP register.
//
//go:linkname VabaU32 VabaU32
//go:noescape
func VabaU32(r *Uint32X2, v0 *Uint32X2, v1 *Uint32X2, v2 *Uint32X2)

// Unsigned Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&FP register.
//
//go:linkname VabaU16 VabaU16
//go:noescape
func VabaU16(r *Uint16X4, v0 *Uint16X4, v1 *Uint16X4, v2 *Uint16X4)

// Signed Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&FP register.
//
//go:linkname VabaS8 VabaS8
//go:noescape
func VabaS8(r *Int8X8, v0 *Int8X8, v1 *Int8X8, v2 *Int8X8)

// Signed Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&FP register.
//
//go:linkname VabaS32 VabaS32
//go:noescape
func VabaS32(r *Int32X2, v0 *Int32X2, v1 *Int32X2, v2 *Int32X2)

// Signed Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&FP register.
//
//go:linkname VabaS16 VabaS16
//go:noescape
func VabaS16(r *Int16X4, v0 *Int16X4, v1 *Int16X4, v2 *Int16X4)

// Unsigned Absolute Difference Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, places the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.
//
//go:linkname VabdlU8 VabdlU8
//go:noescape
func VabdlU8(r *Uint16X8, v0 *Uint8X8, v1 *Uint8X8)

// Unsigned Absolute Difference Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, places the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.
//
//go:linkname VabdlU32 VabdlU32
//go:noescape
func VabdlU32(r *Uint64X2, v0 *Uint32X2, v1 *Uint32X2)

// Unsigned Absolute Difference Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, places the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.
//
//go:linkname VabdlU16 VabdlU16
//go:noescape
func VabdlU16(r *Uint32X4, v0 *Uint16X4, v1 *Uint16X4)

// Signed Absolute Difference Long. This instruction subtracts the vector elements of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, places the absolute value of the results into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VabdlS8 VabdlS8
//go:noescape
func VabdlS8(r *Int16X8, v0 *Int8X8, v1 *Int8X8)

// Signed Absolute Difference Long. This instruction subtracts the vector elements of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, places the absolute value of the results into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VabdlS32 VabdlS32
//go:noescape
func VabdlS32(r *Int64X2, v0 *Int32X2, v1 *Int32X2)

// Signed Absolute Difference Long. This instruction subtracts the vector elements of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, places the absolute value of the results into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VabdlS16 VabdlS16
//go:noescape
func VabdlS16(r *Int32X4, v0 *Int16X4, v1 *Int16X4)

// Unsigned Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&FP register to the corresponding vector element of the second source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.
//
//go:linkname VaddlU8 VaddlU8
//go:noescape
func VaddlU8(r *Uint16X8, v0 *Uint8X8, v1 *Uint8X8)

// Unsigned Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&FP register to the corresponding vector element of the second source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.
//
//go:linkname VaddlU32 VaddlU32
//go:noescape
func VaddlU32(r *Uint64X2, v0 *Uint32X2, v1 *Uint32X2)

// Unsigned Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&FP register to the corresponding vector element of the second source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.
//
//go:linkname VaddlU16 VaddlU16
//go:noescape
func VaddlU16(r *Uint32X4, v0 *Uint16X4, v1 *Uint16X4)

// Signed Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&FP register to the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values.
//
//go:linkname VaddlS8 VaddlS8
//go:noescape
func VaddlS8(r *Int16X8, v0 *Int8X8, v1 *Int8X8)

// Signed Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&FP register to the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values.
//
//go:linkname VaddlS32 VaddlS32
//go:noescape
func VaddlS32(r *Int64X2, v0 *Int32X2, v1 *Int32X2)

// Signed Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&FP register to the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values.
//
//go:linkname VaddlS16 VaddlS16
//go:noescape
func VaddlS16(r *Int32X4, v0 *Int16X4, v1 *Int16X4)

// Unsigned Add Wide. This instruction adds the vector elements of the first source SIMD&FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. The vector elements of the destination register and the first source register are twice as long as the vector elements of the second source register. All the values in this instruction are unsigned integer values.
//
//go:linkname VaddwU8 VaddwU8
//go:noescape
func VaddwU8(r *Uint16X8, v0 *Uint16X8, v1 *Uint8X8)

// Unsigned Add Wide. This instruction adds the vector elements of the first source SIMD&FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. The vector elements of the destination register and the first source register are twice as long as the vector elements of the second source register. All the values in this instruction are unsigned integer values.
//
//go:linkname VaddwU32 VaddwU32
//go:noescape
func VaddwU32(r *Uint64X2, v0 *Uint64X2, v1 *Uint32X2)

// Unsigned Add Wide. This instruction adds the vector elements of the first source SIMD&FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. The vector elements of the destination register and the first source register are twice as long as the vector elements of the second source register. All the values in this instruction are unsigned integer values.
//
//go:linkname VaddwU16 VaddwU16
//go:noescape
func VaddwU16(r *Uint32X4, v0 *Uint32X4, v1 *Uint16X4)

// Signed Add Wide. This instruction adds vector elements of the first source SIMD&FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&FP register, places the results in a vector, and writes the vector to the SIMD&FP destination register.
//
//go:linkname VaddwS8 VaddwS8
//go:noescape
func VaddwS8(r *Int16X8, v0 *Int16X8, v1 *Int8X8)

// Signed Add Wide. This instruction adds vector elements of the first source SIMD&FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&FP register, places the results in a vector, and writes the vector to the SIMD&FP destination register.
//
//go:linkname VaddwS32 VaddwS32
//go:noescape
func VaddwS32(r *Int64X2, v0 *Int64X2, v1 *Int32X2)

// Signed Add Wide. This instruction adds vector elements of the first source SIMD&FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&FP register, places the results in a vector, and writes the vector to the SIMD&FP destination register.
//
//go:linkname VaddwS16 VaddwS16
//go:noescape
func VaddwS16(r *Int32X4, v0 *Int32X4, v1 *Int16X4)

// Unsigned Multiply-Add Long (vector). This instruction multiplies the vector elements in the lower or upper half of the first source SIMD&FP register by the corresponding vector elements of the second source SIMD&FP register, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlalU8 VmlalU8
//go:noescape
func VmlalU8(r *Uint16X8, v0 *Uint16X8, v1 *Uint8X8, v2 *Uint8X8)

// Unsigned Multiply-Add Long (vector). This instruction multiplies the vector elements in the lower or upper half of the first source SIMD&FP register by the corresponding vector elements of the second source SIMD&FP register, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlalU32 VmlalU32
//go:noescape
func VmlalU32(r *Uint64X2, v0 *Uint64X2, v1 *Uint32X2, v2 *Uint32X2)

// Unsigned Multiply-Add Long (vector). This instruction multiplies the vector elements in the lower or upper half of the first source SIMD&FP register by the corresponding vector elements of the second source SIMD&FP register, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlalU16 VmlalU16
//go:noescape
func VmlalU16(r *Uint32X4, v0 *Uint32X4, v1 *Uint16X4, v2 *Uint16X4)

// Signed Multiply-Add Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlalS8 VmlalS8
//go:noescape
func VmlalS8(r *Int16X8, v0 *Int16X8, v1 *Int8X8, v2 *Int8X8)

// Signed Multiply-Add Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlalS32 VmlalS32
//go:noescape
func VmlalS32(r *Int64X2, v0 *Int64X2, v1 *Int32X2, v2 *Int32X2)

// Signed Multiply-Add Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlalS16 VmlalS16
//go:noescape
func VmlalS16(r *Int32X4, v0 *Int32X4, v1 *Int16X4, v2 *Int16X4)

// Vector widening multiply accumulate with scalar
//
//go:linkname VmlalNU32 VmlalNU32
//go:noescape
func VmlalNU32(r *Uint64X2, v0 *Uint64X2, v1 *Uint32X2, v2 *Uint32)

// Vector widening multiply accumulate with scalar
//
//go:linkname VmlalNU16 VmlalNU16
//go:noescape
func VmlalNU16(r *Uint32X4, v0 *Uint32X4, v1 *Uint16X4, v2 *Uint16)

// Vector widening multiply accumulate with scalar
//
//go:linkname VmlalNS32 VmlalNS32
//go:noescape
func VmlalNS32(r *Int64X2, v0 *Int64X2, v1 *Int32X2, v2 *Int32)

// Vector widening multiply accumulate with scalar
//
//go:linkname VmlalNS16 VmlalNS16
//go:noescape
func VmlalNS16(r *Int32X4, v0 *Int32X4, v1 *Int16X4, v2 *Int16)

// Unsigned Multiply-Subtract Long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.
//
//go:linkname VmlslU8 VmlslU8
//go:noescape
func VmlslU8(r *Uint16X8, v0 *Uint16X8, v1 *Uint8X8, v2 *Uint8X8)

// Unsigned Multiply-Subtract Long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.
//
//go:linkname VmlslU32 VmlslU32
//go:noescape
func VmlslU32(r *Uint64X2, v0 *Uint64X2, v1 *Uint32X2, v2 *Uint32X2)

// Unsigned Multiply-Subtract Long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.
//
//go:linkname VmlslU16 VmlslU16
//go:noescape
func VmlslU16(r *Uint32X4, v0 *Uint32X4, v1 *Uint16X4, v2 *Uint16X4)

// Signed Multiply-Subtract Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlslS8 VmlslS8
//go:noescape
func VmlslS8(r *Int16X8, v0 *Int16X8, v1 *Int8X8, v2 *Int8X8)

// Signed Multiply-Subtract Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlslS32 VmlslS32
//go:noescape
func VmlslS32(r *Int64X2, v0 *Int64X2, v1 *Int32X2, v2 *Int32X2)

// Signed Multiply-Subtract Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlslS16 VmlslS16
//go:noescape
func VmlslS16(r *Int32X4, v0 *Int32X4, v1 *Int16X4, v2 *Int16X4)

// Vector widening multiply subtract with scalar
//
//go:linkname VmlslNU32 VmlslNU32
//go:noescape
func VmlslNU32(r *Uint64X2, v0 *Uint64X2, v1 *Uint32X2, v2 *Uint32)

// Vector widening multiply subtract with scalar
//
//go:linkname VmlslNU16 VmlslNU16
//go:noescape
func VmlslNU16(r *Uint32X4, v0 *Uint32X4, v1 *Uint16X4, v2 *Uint16)

// Vector widening multiply subtract with scalar
//
//go:linkname VmlslNS32 VmlslNS32
//go:noescape
func VmlslNS32(r *Int64X2, v0 *Int64X2, v1 *Int32X2, v2 *Int32)

// Vector widening multiply subtract with scalar
//
//go:linkname VmlslNS16 VmlslNS16
//go:noescape
func VmlslNS16(r *Int32X4, v0 *Int32X4, v1 *Int16X4, v2 *Int16)

// Signed Saturating Rounding Doubling Multiply Subtract returning High Half (vector). This instruction multiplies the vector elements of the first source SIMD&FP register with the corresponding vector elements of the second source SIMD&FP register without saturating the multiply results, doubles the results, and subtracts the most significant half of the final results from the vector elements of the destination SIMD&FP register. The results are rounded.
//
//go:linkname VqrdmlahsS32 VqrdmlahsS32
//go:noescape
func VqrdmlahsS32(r *Int32, v0 *Int32, v1 *Int32, v2 *Int32)

// Signed Saturating Rounding Doubling Multiply Subtract returning High Half (vector). This instruction multiplies the vector elements of the first source SIMD&FP register with the corresponding vector elements of the second source SIMD&FP register without saturating the multiply results, doubles the results, and subtracts the most significant half of the final results from the vector elements of the destination SIMD&FP register. The results are rounded.
//
//go:linkname VqrdmlahhS16 VqrdmlahhS16
//go:noescape
func VqrdmlahhS16(r *Int16, v0 *Int16, v1 *Int16, v2 *Int16)

// Signed Saturating Rounding Doubling Multiply Subtract returning High Half (vector). This instruction multiplies the vector elements of the first source SIMD&FP register with the corresponding vector elements of the second source SIMD&FP register without saturating the multiply results, doubles the results, and subtracts the most significant half of the final results from the vector elements of the destination SIMD&FP register. The results are rounded.
//
//go:linkname VqrdmlshsS32 VqrdmlshsS32
//go:noescape
func VqrdmlshsS32(r *Int32, v0 *Int32, v1 *Int32, v2 *Int32)

// Signed Saturating Rounding Doubling Multiply Subtract returning High Half (vector). This instruction multiplies the vector elements of the first source SIMD&FP register with the corresponding vector elements of the second source SIMD&FP register without saturating the multiply results, doubles the results, and subtracts the most significant half of the final results from the vector elements of the destination SIMD&FP register. The results are rounded.
//
//go:linkname VqrdmlshhS16 VqrdmlshhS16
//go:noescape
func VqrdmlshhS16(r *Int16, v0 *Int16, v1 *Int16, v2 *Int16)

// Unsigned Absolute Difference Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, places the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.
//
//go:linkname VabdlHighU8 VabdlHighU8
//go:noescape
func VabdlHighU8(r *Uint16X8, v0 *Uint8X16, v1 *Uint8X16)

// Unsigned Absolute Difference Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, places the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.
//
//go:linkname VabdlHighU32 VabdlHighU32
//go:noescape
func VabdlHighU32(r *Uint64X2, v0 *Uint32X4, v1 *Uint32X4)

// Unsigned Absolute Difference Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, places the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.
//
//go:linkname VabdlHighU16 VabdlHighU16
//go:noescape
func VabdlHighU16(r *Uint32X4, v0 *Uint16X8, v1 *Uint16X8)

// Signed Absolute Difference Long. This instruction subtracts the vector elements of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, places the absolute value of the results into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VabdlHighS8 VabdlHighS8
//go:noescape
func VabdlHighS8(r *Int16X8, v0 *Int8X16, v1 *Int8X16)

// Signed Absolute Difference Long. This instruction subtracts the vector elements of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, places the absolute value of the results into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VabdlHighS32 VabdlHighS32
//go:noescape
func VabdlHighS32(r *Int64X2, v0 *Int32X4, v1 *Int32X4)

// Signed Absolute Difference Long. This instruction subtracts the vector elements of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, places the absolute value of the results into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VabdlHighS16 VabdlHighS16
//go:noescape
func VabdlHighS16(r *Int32X4, v0 *Int16X8, v1 *Int16X8)

// Unsigned Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&FP register to the corresponding vector element of the second source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.
//
//go:linkname VaddlHighU8 VaddlHighU8
//go:noescape
func VaddlHighU8(r *Uint16X8, v0 *Uint8X16, v1 *Uint8X16)

// Unsigned Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&FP register to the corresponding vector element of the second source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.
//
//go:linkname VaddlHighU32 VaddlHighU32
//go:noescape
func VaddlHighU32(r *Uint64X2, v0 *Uint32X4, v1 *Uint32X4)

// Unsigned Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&FP register to the corresponding vector element of the second source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.
//
//go:linkname VaddlHighU16 VaddlHighU16
//go:noescape
func VaddlHighU16(r *Uint32X4, v0 *Uint16X8, v1 *Uint16X8)

// Signed Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&FP register to the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values.
//
//go:linkname VaddlHighS8 VaddlHighS8
//go:noescape
func VaddlHighS8(r *Int16X8, v0 *Int8X16, v1 *Int8X16)

// Signed Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&FP register to the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values.
//
//go:linkname VaddlHighS32 VaddlHighS32
//go:noescape
func VaddlHighS32(r *Int64X2, v0 *Int32X4, v1 *Int32X4)

// Signed Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&FP register to the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values.
//
//go:linkname VaddlHighS16 VaddlHighS16
//go:noescape
func VaddlHighS16(r *Int32X4, v0 *Int16X8, v1 *Int16X8)

// Unsigned Add Wide. This instruction adds the vector elements of the first source SIMD&FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. The vector elements of the destination register and the first source register are twice as long as the vector elements of the second source register. All the values in this instruction are unsigned integer values.
//
//go:linkname VaddwHighU8 VaddwHighU8
//go:noescape
func VaddwHighU8(r *Uint16X8, v0 *Uint16X8, v1 *Uint8X16)

// Unsigned Add Wide. This instruction adds the vector elements of the first source SIMD&FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. The vector elements of the destination register and the first source register are twice as long as the vector elements of the second source register. All the values in this instruction are unsigned integer values.
//
//go:linkname VaddwHighU32 VaddwHighU32
//go:noescape
func VaddwHighU32(r *Uint64X2, v0 *Uint64X2, v1 *Uint32X4)

// Unsigned Add Wide. This instruction adds the vector elements of the first source SIMD&FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. The vector elements of the destination register and the first source register are twice as long as the vector elements of the second source register. All the values in this instruction are unsigned integer values.
//
//go:linkname VaddwHighU16 VaddwHighU16
//go:noescape
func VaddwHighU16(r *Uint32X4, v0 *Uint32X4, v1 *Uint16X8)

// Signed Add Wide. This instruction adds vector elements of the first source SIMD&FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&FP register, places the results in a vector, and writes the vector to the SIMD&FP destination register.
//
//go:linkname VaddwHighS8 VaddwHighS8
//go:noescape
func VaddwHighS8(r *Int16X8, v0 *Int16X8, v1 *Int8X16)

// Signed Add Wide. This instruction adds vector elements of the first source SIMD&FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&FP register, places the results in a vector, and writes the vector to the SIMD&FP destination register.
//
//go:linkname VaddwHighS32 VaddwHighS32
//go:noescape
func VaddwHighS32(r *Int64X2, v0 *Int64X2, v1 *Int32X4)

// Signed Add Wide. This instruction adds vector elements of the first source SIMD&FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&FP register, places the results in a vector, and writes the vector to the SIMD&FP destination register.
//
//go:linkname VaddwHighS16 VaddwHighS16
//go:noescape
func VaddwHighS16(r *Int32X4, v0 *Int32X4, v1 *Int16X8)

// Unsigned Multiply-Add Long (vector). This instruction multiplies the vector elements in the lower or upper half of the first source SIMD&FP register by the corresponding vector elements of the second source SIMD&FP register, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlalHighU8 VmlalHighU8
//go:noescape
func VmlalHighU8(r *Uint16X8, v0 *Uint16X8, v1 *Uint8X16, v2 *Uint8X16)

// Unsigned Multiply-Add Long (vector). This instruction multiplies the vector elements in the lower or upper half of the first source SIMD&FP register by the corresponding vector elements of the second source SIMD&FP register, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlalHighU32 VmlalHighU32
//go:noescape
func VmlalHighU32(r *Uint64X2, v0 *Uint64X2, v1 *Uint32X4, v2 *Uint32X4)

// Unsigned Multiply-Add Long (vector). This instruction multiplies the vector elements in the lower or upper half of the first source SIMD&FP register by the corresponding vector elements of the second source SIMD&FP register, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlalHighU16 VmlalHighU16
//go:noescape
func VmlalHighU16(r *Uint32X4, v0 *Uint32X4, v1 *Uint16X8, v2 *Uint16X8)

// Signed Multiply-Add Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlalHighS8 VmlalHighS8
//go:noescape
func VmlalHighS8(r *Int16X8, v0 *Int16X8, v1 *Int8X16, v2 *Int8X16)

// Signed Multiply-Add Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlalHighS32 VmlalHighS32
//go:noescape
func VmlalHighS32(r *Int64X2, v0 *Int64X2, v1 *Int32X4, v2 *Int32X4)

// Signed Multiply-Add Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlalHighS16 VmlalHighS16
//go:noescape
func VmlalHighS16(r *Int32X4, v0 *Int32X4, v1 *Int16X8, v2 *Int16X8)

// Unsigned Multiply-Add Long (vector). This instruction multiplies the vector elements in the lower or upper half of the first source SIMD&FP register by the corresponding vector elements of the second source SIMD&FP register, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlalHighNU32 VmlalHighNU32
//go:noescape
func VmlalHighNU32(r *Uint64X2, v0 *Uint64X2, v1 *Uint32X4, v2 *Uint32)

// Unsigned Multiply-Add Long (vector). This instruction multiplies the vector elements in the lower or upper half of the first source SIMD&FP register by the corresponding vector elements of the second source SIMD&FP register, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlalHighNU16 VmlalHighNU16
//go:noescape
func VmlalHighNU16(r *Uint32X4, v0 *Uint32X4, v1 *Uint16X8, v2 *Uint16)

// Signed Multiply-Add Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlalHighNS32 VmlalHighNS32
//go:noescape
func VmlalHighNS32(r *Int64X2, v0 *Int64X2, v1 *Int32X4, v2 *Int32)

// Signed Multiply-Add Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlalHighNS16 VmlalHighNS16
//go:noescape
func VmlalHighNS16(r *Int32X4, v0 *Int32X4, v1 *Int16X8, v2 *Int16)

// Unsigned Multiply-Subtract Long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.
//
//go:linkname VmlslHighU8 VmlslHighU8
//go:noescape
func VmlslHighU8(r *Uint16X8, v0 *Uint16X8, v1 *Uint8X16, v2 *Uint8X16)

// Unsigned Multiply-Subtract Long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.
//
//go:linkname VmlslHighU32 VmlslHighU32
//go:noescape
func VmlslHighU32(r *Uint64X2, v0 *Uint64X2, v1 *Uint32X4, v2 *Uint32X4)

// Unsigned Multiply-Subtract Long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.
//
//go:linkname VmlslHighU16 VmlslHighU16
//go:noescape
func VmlslHighU16(r *Uint32X4, v0 *Uint32X4, v1 *Uint16X8, v2 *Uint16X8)

// Signed Multiply-Subtract Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlslHighS8 VmlslHighS8
//go:noescape
func VmlslHighS8(r *Int16X8, v0 *Int16X8, v1 *Int8X16, v2 *Int8X16)

// Signed Multiply-Subtract Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlslHighS32 VmlslHighS32
//go:noescape
func VmlslHighS32(r *Int64X2, v0 *Int64X2, v1 *Int32X4, v2 *Int32X4)

// Signed Multiply-Subtract Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlslHighS16 VmlslHighS16
//go:noescape
func VmlslHighS16(r *Int32X4, v0 *Int32X4, v1 *Int16X8, v2 *Int16X8)

// Unsigned Multiply-Subtract Long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.
//
//go:linkname VmlslHighNU32 VmlslHighNU32
//go:noescape
func VmlslHighNU32(r *Uint64X2, v0 *Uint64X2, v1 *Uint32X4, v2 *Uint32)

// Unsigned Multiply-Subtract Long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values.
//
//go:linkname VmlslHighNU16 VmlslHighNU16
//go:noescape
func VmlslHighNU16(r *Uint32X4, v0 *Uint32X4, v1 *Uint16X8, v2 *Uint16)

// Signed Multiply-Subtract Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlslHighNS32 VmlslHighNS32
//go:noescape
func VmlslHighNS32(r *Int64X2, v0 *Int64X2, v1 *Int32X4, v2 *Int32)

// Signed Multiply-Subtract Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
//
//go:linkname VmlslHighNS16 VmlslHighNS16
//go:noescape
func VmlslHighNS16(r *Int32X4, v0 *Int32X4, v1 *Int16X8, v2 *Int16)

// Unsigned Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.
//
//go:linkname VabalU8 VabalU8
//go:noescape
func VabalU8(r *Uint16X8, v0 *Uint16X8, v1 *Uint8X8, v2 *Uint8X8)

// Unsigned Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.
//
//go:linkname VabalU32 VabalU32
//go:noescape
func VabalU32(r *Uint64X2, v0 *Uint64X2, v1 *Uint32X2, v2 *Uint32X2)

// Unsigned Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.
//
//go:linkname VabalU16 VabalU16
//go:noescape
func VabalU16(r *Uint32X4, v0 *Uint32X4, v1 *Uint16X4, v2 *Uint16X4)

// Signed Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VabalS8 VabalS8
//go:noescape
func VabalS8(r *Int16X8, v0 *Int16X8, v1 *Int8X8, v2 *Int8X8)

// Signed Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VabalS32 VabalS32
//go:noescape
func VabalS32(r *Int64X2, v0 *Int64X2, v1 *Int32X2, v2 *Int32X2)

// Signed Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VabalS16 VabalS16
//go:noescape
func VabalS16(r *Int32X4, v0 *Int32X4, v1 *Int16X4, v2 *Int16X4)

// Unsigned Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.
//
//go:linkname VabalHighU8 VabalHighU8
//go:noescape
func VabalHighU8(r *Uint16X8, v0 *Uint16X8, v1 *Uint8X16, v2 *Uint8X16)

// Unsigned Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.
//
//go:linkname VabalHighU32 VabalHighU32
//go:noescape
func VabalHighU32(r *Uint64X2, v0 *Uint64X2, v1 *Uint32X4, v2 *Uint32X4)

// Unsigned Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values.
//
//go:linkname VabalHighU16 VabalHighU16
//go:noescape
func VabalHighU16(r *Uint32X4, v0 *Uint32X4, v1 *Uint16X8, v2 *Uint16X8)

// Signed Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VabalHighS8 VabalHighS8
//go:noescape
func VabalHighS8(r *Int16X8, v0 *Int16X8, v1 *Int8X16, v2 *Int8X16)

// Signed Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VabalHighS32 VabalHighS32
//go:noescape
func VabalHighS32(r *Int64X2, v0 *Int64X2, v1 *Int32X4, v2 *Int32X4)

// Signed Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
//
//go:linkname VabalHighS16 VabalHighS16
//go:noescape
func VabalHighS16(r *Int32X4, v0 *Int32X4, v1 *Int16X8, v2 *Int16X8)
